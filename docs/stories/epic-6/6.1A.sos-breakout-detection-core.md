# Story 6.1A: SOS Breakout Detection - Core Logic

## Status

Ready for Review

## Story

**As a** SOS detector,
**I want** to identify SOS breakout patterns (decisive break above Ice with high volume),
**so that** Phase D markup entries can be signaled.

## Acceptance Criteria

1. Function: `detect_sos_breakout(range, bars, volume_analysis, phase) -> Optional[SOSBreakout]`
2. SOS requirements (FR6): close above Ice (1%+ penetration), volume expansion (1.5x+)
3. Breakout validation: close_price > ice_level * 1.01 (minimum 1% above)
4. **CRITICAL - Volume validation (FR12):** if volume_ratio < 1.5x, REJECT immediately (insufficient confirmation) - NON-NEGOTIABLE
5. SOSBreakout dataclass: bar, breakout_pct, volume_ratio, ice_reference, breakout_price, detection_timestamp, trading_range_id
6. Phase validation (FR15): **Phase D only** (defer late Phase C to Story 6.1B)
7. Unit test: synthetic breakout with 2.0x volume detected
8. Unit test: low-volume breakout (1.4x) rejected (FR12)
9. Unit test: <1% breakout rejected
10. Unit test: wrong phase (not Phase D) rejected

## Tasks / Subtasks

- [x] **Task 1: Create SOSBreakout data model (MVP)** (AC: 1, 5)
  - [x] Create file: `backend/src/models/sos_breakout.py`
  - [x] Import required types: `Decimal`, `datetime`, `UUID`, `Optional`
  - [x] Import from Epic 3: `TradingRange` from `backend/src/models/trading_range.py`
  - [x] Import from Epic 1: `OHLCVBar` from `backend/src/models/ohlcv.py`
  - [x] Create Pydantic model: `class SOSBreakout(BaseModel):`
  - [x] **Core attributes (MVP - simplified from 6.1):**
    - `id: UUID = Field(default_factory=uuid4)` - Unique identifier
    - `bar: OHLCVBar` - The breakout bar
    - `breakout_pct: Decimal = Field(ge=0.01, decimal_places=4)` - % above Ice (minimum 1% per AC 3)
    - `volume_ratio: Decimal = Field(ge=1.5, decimal_places=4)` - Must be >=1.5x (AC 4, FR12)
    - `ice_reference: Decimal = Field(decimal_places=8, max_digits=18)` - Ice level at detection time
    - `breakout_price: Decimal = Field(decimal_places=8, max_digits=18)` - Close price of breakout bar
    - `detection_timestamp: datetime` - When SOS was detected (UTC)
    - `trading_range_id: UUID` - Associated trading range
  - [x] Add Pydantic validators:
    - `@validator('detection_timestamp')`: Ensure UTC timezone
    - `@validator('breakout_pct')`: Ensure >= 0.01 (1% minimum per AC 3)
    - `@validator('volume_ratio')`: Ensure >= 1.5 (AC 4, FR12 enforcement)
  - [x] Add docstring explaining SOS (Sign of Strength) breakout requirements per AC 2
  - [x] Configure JSON serialization for Decimal and datetime types

- [x] **Task 2: Implement detect_sos_breakout function signature** (AC: 1)
  - [x] Create file: `backend/src/pattern_engine/detectors/sos_detector.py`
  - [x] Import dependencies:
    - `from typing import Optional, List, Dict`
    - `from decimal import Decimal`
    - `from backend.src.models.sos_breakout import SOSBreakout`
    - `from backend.src.models.trading_range import TradingRange`
    - `from backend.src.models.ohlcv import OHLCVBar`
    - `from backend.src.models.phase_classification import WyckoffPhase, PhaseClassification` (Story 4.4)
    - `import structlog`
  - [x] Create function: `def detect_sos_breakout(range: TradingRange, bars: List[OHLCVBar], volume_analysis: Dict, phase: PhaseClassification) -> Optional[SOSBreakout]:`
  - [x] Add comprehensive docstring:
    - Purpose: Detect SOS (Sign of Strength) breakout patterns
    - Parameters:
      - `range`: Active trading range with Ice level
      - `bars`: OHLCV bars (minimum 25 bars for volume averages)
      - `volume_analysis`: Pre-calculated volume_ratio from VolumeAnalyzer (Story 2.5)
      - `phase`: Current Wyckoff phase classification (must be Phase D per FR15)
    - Returns: `Optional[SOSBreakout]` - SOS if detected, None if not found or rejected
    - FR Requirements: FR6 (SOS detection), FR12 (volume validation), FR15 (Phase D)
  - [x] Return type: `Optional[SOSBreakout]`

- [x] **Task 3: Implement Phase D validation (FR15) - SIMPLIFIED** (AC: 6)
  - [x] Add phase check at function start:
    ```python
    current_phase = phase.phase
    phase_confidence = phase.confidence

    # FR15: SOS in Phase D (Story 6.1A - Phase C deferred to 6.1B)
    if current_phase != WyckoffPhase.D:
        logger.debug(
            "sos_wrong_phase",
            current_phase=current_phase.value,
            required_phase="D",
            message="SOS requires Phase D (FR15) - Phase C support deferred to Story 6.1B"
        )
        return None

    logger.debug(
        "sos_phase_validation",
        current_phase="D",
        phase_confidence=phase_confidence,
        message="SOS in Phase D (ideal - markup phase)"
    )
    ```
  - [x] Return None immediately if phase != D

- [x] **Task 4: Implement Ice level breakout detection** (AC: 2, 3)
  - [x] Extract Ice level from trading range:
    ```python
    ice_level = range.ice_level.price  # Decimal from Story 3.5
    ```
  - [x] Scan last 20 bars for breakout above Ice:
    ```python
    for bar in bars[-20:]:
        close_price = bar.close

        # AC 3: Close must be above Ice + 1% minimum
        # Breakout validation: close_price > ice_level * 1.01
        if close_price <= ice_level * Decimal("1.01"):
            continue  # Not a valid breakout

        # Calculate breakout percentage
        breakout_pct = (close_price - ice_level) / ice_level

        # Potential SOS candidate found
        logger.debug(
            "sos_candidate_found",
            symbol=bar.symbol,
            close_price=float(close_price),
            ice_level=float(ice_level),
            breakout_pct=float(breakout_pct),
            message=f"Potential SOS: close {breakout_pct:.2%} above Ice"
        )
    ```
  - [x] Store breakout candidate details: `breakout_bar`, `breakout_price`, `breakout_pct`

- [x] **Task 5: Implement CRITICAL volume expansion validation (FR12)** (AC: 4) **[PRIMARY QUALITY GATE]**
  - [x] **FIRST validation checkpoint - check volume BEFORE other validations**
  - [x] Extract volume ratio from volume_analysis:
    ```python
    volume_ratio = volume_analysis.get(bar.timestamp, {}).get("volume_ratio")

    if volume_ratio is None:
        logger.error(
            "volume_analysis_missing",
            bar_timestamp=bar.timestamp.isoformat(),
            message="Volume analysis not available for breakout bar"
        )
        continue  # Skip candidate
    ```
  - [x] **FR12 enforcement - NON-NEGOTIABLE volume expansion requirement (AC 4):**
    ```python
    # AC 4: Volume ratio must be >= 1.5x
    # FR12: Volume expansion confirms breakout legitimacy
    # Low-volume breakouts are false breakouts (absorption at resistance)

    if volume_ratio < Decimal("1.5"):
        logger.warning(
            "sos_invalid_low_volume",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            volume_ratio=float(volume_ratio),
            threshold=1.5,
            message="SOS INVALID: Volume {:.2f}x < 1.5x - insufficient confirmation (FR12 - LOW VOLUME = FALSE BREAKOUT)".format(volume_ratio)
        )
        continue  # REJECT immediately - no further processing
    ```
  - [x] Log rejection with specific FR12 reference
  - [x] **NO confidence degradation** - this is binary pass/fail
  - [x] Document ideal volume ranges in logs:
    - `1.5x - 2.0x`: Acceptable expansion
    - `2.0x - 2.5x`: Strong expansion (ideal)
    - `2.5x+`: Extremely strong (climactic volume)

- [x] **Task 6: Create SOSBreakout instance upon successful detection** (AC: 5)
  - [x] After all validations pass, create SOSBreakout object:
    ```python
    from datetime import timezone

    sos_breakout = SOSBreakout(
        bar=breakout_bar,
        breakout_pct=breakout_pct,
        volume_ratio=volume_ratio,
        ice_reference=ice_level,
        breakout_price=close_price,
        detection_timestamp=datetime.now(timezone.utc),
        trading_range_id=range.id
    )
    ```
  - [x] Log successful SOS detection:
    ```python
    logger.info(
        "sos_breakout_detected",
        symbol=breakout_bar.symbol,
        breakout_timestamp=breakout_bar.timestamp.isoformat(),
        breakout_pct=float(breakout_pct),
        volume_ratio=float(volume_ratio),
        ice_level=float(ice_level),
        phase=current_phase.value,
        message="SOS detected - Ice breakout with volume confirmation"
    )
    ```
  - [x] Return SOSBreakout instance

- [x] **Task 7: Handle no SOS detected case**
  - [x] If loop completes without finding valid SOS:
    ```python
    logger.debug(
        "no_sos_detected",
        symbol=range.symbol,
        phase=current_phase.value,
        bars_analyzed=len(bars),
        message="No valid SOS breakout found in analyzed bars"
    )
    return None
    ```

- [x] **Task 8: Write unit test for valid SOS detection** (AC: 7)
  - [x] Create test file: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py`
  - [x] Import pytest, SOSBreakout, detect_sos_breakout, WyckoffPhase
  - [x] Create test fixture: `synthetic_trading_range` with Ice level at $100.00
  - [x] Create test fixture: `synthetic_bars_with_sos_breakout`
    - 24 bars of normal trading within range ($95-$100)
    - Bar 25: SOS breakout bar with:
      - `close = $102.00` (2% above Ice)
      - `volume = 200,000` (volume_ratio = 2.0x per AC 7)
  - [x] Create volume_analysis dict:
    ```python
    volume_analysis = {
        bars[24].timestamp: {
            "volume_ratio": Decimal("2.0"),  # AC 7: 2.0x volume
        }
    }
    ```
  - [x] Create phase classification: Phase D
  - [x] **Test valid SOS detection (AC 7):**
    ```python
    def test_detect_sos_breakout_valid():
        # Arrange
        range = create_trading_range(ice_level=Decimal("100.00"))
        bars = create_synthetic_bars_with_sos()
        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),
            }
        }
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert
        assert sos is not None, "SOS should be detected"
        assert sos.breakout_pct >= Decimal("0.01"), "Breakout >= 1% above Ice"
        assert sos.volume_ratio == Decimal("2.0"), "2.0x volume ratio"
        assert sos.ice_reference == Decimal("100.00")
        assert sos.breakout_price == Decimal("102.00")
    ```

- [x] **Task 9: Write unit test for low-volume rejection** (AC: 4, 8)
  - [x] Create synthetic scenario with low volume (1.4x, below 1.5x threshold)
  - [x] **Test volume rejection (AC 4, 8, FR12):**
    ```python
    def test_detect_sos_low_volume_rejected():
        # Arrange: Same setup as valid SOS, but volume = 1.4x (below threshold)
        range = create_trading_range(ice_level=Decimal("100.00"))
        bars = create_synthetic_bars_with_sos()
        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("1.4"),  # LOW VOLUME (< 1.5x)
            }
        }
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert
        assert sos is None, "Low-volume breakout should be REJECTED (FR12)"

        # Verify rejection logged (check logs or use caplog)
        # Expected log: "SOS INVALID: Volume 1.40x < 1.5x - insufficient confirmation"
    ```
  - [x] Test boundary case: 1.49x rejects, 1.50x passes:
    ```python
    def test_volume_boundary():
        # 1.49x should reject
        volume_analysis_reject = {bars[24].timestamp: {"volume_ratio": Decimal("1.49")}}
        sos_reject = detect_sos_breakout(range, bars, volume_analysis_reject, phase)
        assert sos_reject is None, "1.49x volume should reject"

        # 1.50x should pass
        volume_analysis_pass = {bars[24].timestamp: {"volume_ratio": Decimal("1.50")}}
        sos_pass = detect_sos_breakout(range, bars, volume_analysis_pass, phase)
        assert sos_pass is not None, "1.50x volume should pass (FR12)"
    ```

- [x] **Task 10: Write unit test for breakout percentage validation** (AC: 3, 9)
  - [x] Test exact 1% breakout (minimum acceptable):
    ```python
    def test_breakout_1_percent_accepted():
        # Ice = $100, close = $101 → 1% breakout (minimum allowed)
        bars = create_bars_with_breakout(ice=100, close=101)
        volume_analysis = {bars[24].timestamp: {"volume_ratio": Decimal("2.0")}}
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is not None, "1% breakout should be accepted (AC 3)"
        assert sos.breakout_pct == Decimal("0.01")
    ```
  - [x] Test <1% breakout (rejected):
    ```python
    def test_breakout_below_1_percent_rejected():
        # Ice = $100, close = $100.50 → 0.5% breakout (too small)
        bars = create_bars_with_breakout(ice=100, close=100.50)
        volume_analysis = {bars[24].timestamp: {"volume_ratio": Decimal("2.0")}}
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is None, "< 1% breakout should be rejected (AC 3)"
    ```

- [x] **Task 11: Write unit test for Phase D validation** (AC: 6, 10, FR15)
  - [x] Test SOS in Phase D (valid):
    ```python
    def test_sos_in_phase_d_accepted():
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is not None, "SOS valid in Phase D (FR15)"
    ```
  - [x] Test SOS in other phases (rejected):
    ```python
    @pytest.mark.parametrize("phase_value", [
        WyckoffPhase.A,
        WyckoffPhase.B,
        WyckoffPhase.C,  # Phase C deferred to Story 6.1B
        WyckoffPhase.E
    ])
    def test_sos_wrong_phase_rejected(phase_value):
        phase = create_phase_classification(phase=phase_value, confidence=85)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is None, f"SOS should be rejected in Phase {phase_value.value} (FR15 - Story 6.1A only supports Phase D)"
    ```

- [x] **Task 12: Implement edge case handling**
  - [x] Handle insufficient bars (<25 bars):
    ```python
    if len(bars) < 25:
        logger.warning(
            "insufficient_bars_for_sos_detection",
            bars_available=len(bars),
            bars_required=25,
            message="Need at least 25 bars for volume average calculation"
        )
        return None
    ```
  - [x] Handle missing trading range:
    ```python
    if range is None:
        logger.error("trading_range_missing")
        raise ValueError("Trading range required for SOS detection")
    ```
  - [x] Handle Ice level = None or 0:
    ```python
    if range.ice_level is None or range.ice_level.price <= 0:
        logger.error("invalid_ice_level", ice=range.ice_level)
        raise ValueError("Valid Ice level required for SOS breakout detection")
    ```

- [x] **Task 13: Add type hints and mypy validation**
  - [x] Add comprehensive type hints to all functions
  - [x] Use strict typing: `from __future__ import annotations`
  - [x] Run mypy in strict mode: `mypy --strict sos_detector.py`
  - [x] Fix any type errors
  - [x] Ensure Optional, List, Dict types are properly annotated

- [x] **Task 14: Add comprehensive logging**
  - [x] Log SOS detection start with range and phase context
  - [x] Log each candidate found with breakout percentage
  - [x] Log all rejections with specific reasons (volume, breakout %, phase)
  - [x] Log final SOS detection with all metrics
  - [x] Use structlog with structured fields
  - [x] Follow [architecture/17-monitoring-and-observability.md](../../../docs/architecture/17-monitoring-and-observability.md)

## Dev Notes

### Story 6.1A vs 6.1B Split

**Story 6.1A (THIS STORY) - Core SOS Detection:**
- Focus: Get SOS detection working with PRIMARY quality gate (volume)
- Scope: Ice breakout (1%+) + Volume validation (1.5x+) + Phase D check
- Result: Binary detection (SOS detected or not)
- Deferred to 6.1B: Spread expansion, three-tier close position, late Phase C support

**Story 6.1B (FUTURE) - Quality Enhancements:**
- Focus: Add nuanced quality assessments
- Scope: Spread expansion (1.2x+), three-tier close position (PASS/MARGINAL/REJECT), late Phase C (85+ confidence)
- Result: Refined SOS quality for confidence scoring (Story 6.5)

### Previous Story Context

**Epic 5 Completion (Spring Pattern Detection):**
[Source: Epic 5 stories]
- Spring detector provides opposite pattern (penetration below Creek vs SOS break above Ice)
- Spring: low volume (<0.7x), SOS: high volume (>=1.5x) - opposite requirements
- Spring: Phase C, SOS: Phase D - different phases in Wyckoff cycle
- Similar validation approach: volume is non-negotiable (FR12 for both)
- **Story 6.1A integration:** SOS is the markup entry pattern after Spring accumulation entry

**Story 3.5 (Ice Level Calculation):**
[Source: docs/prd/epic-3-trading-range-level-detection.md]
- Ice level is volume-weighted resistance from pivot highs
- Minimum Ice strength: 60 (from Epic 3.5 AC 5)
- Ice level stored in TradingRange model
- **Story 6.1A integration:** SOS detects breakout above Ice level
- `ice_level = range.ice_level.price` (Decimal)

**Story 2.5 (VolumeAnalyzer Integration):**
[Source: Epic 2]
- VolumeAnalyzer calculates volume_ratio for each bar
- Formula: `volume_ratio = volume / 20-bar average volume`
- **Story 6.1A integration:**
  - Volume validation (FR12) uses pre-calculated volume_ratio
  - `volume_ratio >= 1.5x` required (opposite of Spring <0.7x)

**Story 4.4 (Phase Classification Logic):**
[Source: Epic 4]
- PhaseDetector provides PhaseClassification with phase and confidence
- WyckoffPhase enum: A, B, C, D, E
- **Story 6.1A integration:**
  - SOS in Phase D (Story 6.1A - simplified)
  - Phase C support deferred to Story 6.1B
  - `phase.phase == WyckoffPhase.D`

**Key Learnings:**
- SOS is inverse of Spring: high volume vs low volume, break up vs down
- Volume expansion (1.5x+) is CRITICAL for confirming legitimate breakout (FR12)
- Phase D is primary SOS phase (markup)
- Story 6.1A focuses on core detection, 6.1B adds quality refinements

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models: SOSBreakout, validation)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- New Model: `backend/src/models/sos_breakout.py` (create new)
- New Detector: `backend/src/pattern_engine/detectors/sos_detector.py` (create new)
- Unit Tests: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py` (create new)

**Dependencies:**
- `backend/src/models/trading_range.py`: TradingRange with ice_level (Epic 3)
- `backend/src/models/ohlcv.py`: OHLCVBar (Epic 1)
- `backend/src/models/phase_classification.py`: WyckoffPhase, PhaseClassification (Story 4.4)
- `backend/src/pattern_engine/volume_analyzer.py`: VolumeAnalyzer (Story 2.5)
- Pydantic BaseModel, Field, validator
- structlog for logging
- Decimal for precise financial calculations

### Data Models

**SOSBreakout Model (MVP - Simplified from Story 6.1):**

```python
from decimal import Decimal
from datetime import datetime, timezone
from uuid import UUID, uuid4
from pydantic import BaseModel, Field, validator
from backend.src.models.ohlcv import OHLCVBar

class SOSBreakout(BaseModel):
    """
    SOS (Sign of Strength) Breakout pattern (FR6 requirement) - MVP Model for Story 6.1A.

    Wyckoff interpretation:
    - SOS is decisive break above resistance (Ice level)
    - High volume confirms breakout legitimacy (not absorption)
    - FR12: Volume expansion (1.5x+) is NON-NEGOTIABLE
    - FR15: Occurs in Phase D (markup)

    SOS marks transition from accumulation to markup phase.

    Story 6.1A MVP: Core fields for detection (spread, close_position deferred to 6.1B)
    """
    id: UUID = Field(default_factory=uuid4, description="Unique identifier")
    bar: OHLCVBar = Field(..., description="The breakout bar")
    breakout_pct: Decimal = Field(..., ge=0.01, decimal_places=4, description="% above Ice (min 1%)")
    volume_ratio: Decimal = Field(..., ge=1.5, decimal_places=4, description="Volume vs 20-bar avg (min 1.5x)")
    ice_reference: Decimal = Field(..., decimal_places=8, max_digits=18, description="Ice level at detection")
    breakout_price: Decimal = Field(..., decimal_places=8, max_digits=18, description="Close price of breakout bar")
    detection_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    trading_range_id: UUID = Field(..., description="Associated trading range")

    @validator('volume_ratio')
    def validate_volume_expansion(cls, v):
        """
        CRITICAL: Volume expansion required (FR12).
        Volume >= 1.5x confirms breakout is legitimate, not absorption.
        """
        if v < Decimal("1.5"):
            raise ValueError("SOS volume ratio must be >= 1.5x (FR12)")
        return v

    @validator('breakout_pct')
    def validate_breakout_pct(cls, v):
        """Breakout must be >= 1% above Ice"""
        if v < Decimal("0.01"):
            raise ValueError("SOS breakout must be >= 1% above Ice")
        return v

    @validator('detection_timestamp', pre=True, always=True)
    def ensure_utc(cls, v):
        """Enforce UTC timezone"""
        if v.tzinfo is None:
            return v.replace(tzinfo=timezone.utc)
        return v.astimezone(timezone.utc)

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }
```

### Algorithm Details

**SOS Breakout Detection Algorithm (Story 6.1A - Simplified):**

```
Purpose: Identify SOS (Sign of Strength) breakout patterns - decisive breaks above Ice with high volume

Input:
- range: TradingRange (context with Ice level)
- bars: List[OHLCVBar] (price data)
- volume_analysis: Dict (volume_ratio from VolumeAnalyzer)
- phase: PhaseClassification (current phase from PhaseDetector)

Algorithm:

Step 1: Phase Validation (FR15) - SIMPLIFIED
- If phase == Phase D: proceed (markup phase)
- Else: return None (Phase C support deferred to Story 6.1B)

Step 2: Extract Ice Level from Range
- ice_level = range.ice_level.price  # Decimal from Epic 3
- Validate ice_level is valid (not None, > 0)

Step 3: Scan Last 20 Bars for Breakout Above Ice
- For each bar in bars[-20:]:
  - If bar.close <= ice_level * 1.01: skip (not a 1%+ breakout)
  - Calculate breakout_pct = (bar.close - ice_level) / ice_level
  - Found potential SOS candidate

Step 4: CRITICAL - Volume Expansion Validation (FR12) [PRIMARY QUALITY GATE]
- Extract volume_ratio from volume_analysis[bar.timestamp]
- If volume_ratio < 1.5:
  - Log: "SOS INVALID: Volume {ratio}x < 1.5x - insufficient confirmation (FR12)"
  - Skip candidate (REJECT immediately - NON-NEGOTIABLE)
- Ideal volume: 2.0x+ (strong), 2.5x+ (very strong)

Step 5: Create SOSBreakout Instance
- Assemble SOSBreakout with core fields
- Set detection_timestamp = now (UTC)
- Return SOSBreakout

Output:
- SOSBreakout if valid breakout found
- None if no breakout OR breakout rejected by validations
```

**SOS vs Spring Comparison:**

| Characteristic | Spring (Phase C) | SOS (Phase D) |
|----------------|------------------|---------------|
| Direction | Penetration below Creek | Break above Ice |
| Volume | Low (<0.7x) | High (>=1.5x) |
| Purpose | Final shakeout before markup | Entry into markup |
| Phase | Phase C (test) | Phase D (markup) |
| Entry Signal | After test confirmation | Immediate or wait for LPS |
| Stop | 2% below spring low | 5% below Ice (or 3% for LPS) |

### Wyckoff Context

**SOS (Sign of Strength) in Wyckoff Methodology:**

**Definition:**
> "SOS is a decisive upward movement through resistance (Ice level) on expanding volume. It marks the beginning of markup (Phase D) after accumulation is complete. The high volume confirms demand overwhelming supply - the breakout is legitimate, not absorption."

**Purpose of SOS:**
- **Confirm accumulation complete** - Composite Man has finished buying
- **Signal markup beginning** - Price ready to advance
- **Provide markup entry** - Traders can enter on breakout or pullback (LPS)
- **Validate range breakout** - Volume confirms breakout legitimacy

**Why High Volume is CRITICAL (FR12):**
> "High volume on SOS (1.5x+) proves DEMAND overwhelming SUPPLY. Low-volume breakouts are false - they represent absorption by Composite Man at resistance. The volume expansion is NON-NEGOTIABLE for confirming SOS legitimacy."

**Volume Interpretation:**
- **1.5x - 2.0x**: Acceptable expansion - breakout confirmed
- **2.0x - 2.5x**: Strong expansion - ideal SOS
- **2.5x+**: Very strong/climactic - extremely bullish
- **<1.5x**: **REJECTED** - false breakout, absorption at resistance (FR12)

**Phase D Requirement (FR15):**
> "SOS occurs in **Phase D (Markup)** after accumulation complete. Story 6.1A focuses on Phase D only - late Phase C support added in Story 6.1B."

**Phase Context:**
- **Phase C**: Final test (Spring) - too early for SOS
- **Phase D**: **SOS occurs here** - markup begins
- **Phase E**: Markup continuation - SOS already passed

**Breakout Size:**
> "SOS must close at least 1% above Ice (resistance). Smaller breaks (<1%) often fail. Larger breaks (3%+) show strong commitment."

**Breakout Size Ranges:**
- **1-2%**: Minimum acceptable
- **2-3%**: Normal breakout
- **3%+**: Strong breakout (decisive move)

**SOS vs False Breakout:**

| Characteristic | SOS (Valid) | False Breakout (Invalid) |
|----------------|-------------|--------------------------|
| Volume | **>=1.5x expansion** | <1.5x (absorption) |
| Phase | Phase D | Wrong phase |
| Breakout | >=1% above Ice | <1% above Ice |
| Interpretation | Markup beginning | Absorption at resistance |

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- Classes: PascalCase (`SOSBreakout`, `SOSDetector`)
- Functions: snake_case (`detect_sos_breakout`, `validate_volume`)
- Variables: snake_case (`breakout_pct`, `volume_ratio`)
- Constants: UPPER_SNAKE_CASE (`MIN_VOLUME_RATIO`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- ✅ Use Decimal for financial calculations: `breakout_pct: Decimal`
- ✅ Use type hints: `def detect_sos_breakout(...) -> Optional[SOSBreakout]:`
- ✅ Use Pydantic models for validation (SOSBreakout model)
- ❌ DON'T use float for prices or percentages

**Decimal Precision:**
[Source: [architecture/4-data-models.md](../../../docs/architecture/4-data-models.md)]
- Prices: `NUMERIC(18,8)` → `Decimal` with 8 decimal places
- Ratios: `NUMERIC(10,4)` → `Decimal` with 4 decimal places
- Always use `Decimal("1.5")` not `1.5` (float) for comparisons

### Performance Requirements

- Single SOS detection: <10ms (simple loop + validations)
- Batch processing (100 bars): <50ms
- O(n) where n = number of bars (typically 20)
- No complex algorithms, linear scan with early exit

### Integration Notes

**Epic 6 Workflow:**

```
Story 6.1A: Detect SOS Breakout (Core: Ice + Volume + Phase D) → Optional[SOSBreakout] ← THIS STORY
    ↓
Story 6.1B: SOS Quality Enhancements (Spread + Close Position + Phase C) → Enhanced SOSBreakout
    ↓
Story 6.3: Detect LPS (pullback to old resistance) → Optional[LPS]
    ↓
Story 6.4: SOS vs LPS Entry Preference → Determine best entry
    ↓
Story 6.5: Calculate SOS Confidence → int (0-100)
    ↓
Story 6.6: Generate SOS/LPS Signal → SOSSignal (entry/stop/target)
    ↓
Story 6.7: SOSDetector & LPSDetector Integration → Unified API
```

**Integration with Epic 3 (Trading Range & Ice Level):**

```python
# Epic 3 provides TradingRange model with Ice level
from backend.src.models.trading_range import TradingRange

# Ice level used for breakout detection
ice_level = range.ice_level.price  # Decimal from Story 3.5

# SOS = break above Ice + volume expansion
```

**Integration with Story 2.5 (VolumeAnalyzer):**

```python
# VolumeAnalyzer provides volume_ratio
volume_analysis = {
    bar.timestamp: {
        "volume_ratio": Decimal("2.0"),   # Used for FR12 validation
    }
}
```

**Integration with Story 4.4 (PhaseDetector):**

```python
# PhaseDetector provides current phase
from backend.src.models.phase_classification import WyckoffPhase, PhaseClassification

# SOS valid in Phase D (Story 6.1A)
phase = PhaseClassification(phase=WyckoffPhase.D, confidence=90)

sos = detect_sos_breakout(range, bars, volume_analysis, phase)
```

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py`

### Coverage Requirements
- Valid SOS detection (2.0x volume) - AC 7
- Low-volume rejection (<1.5x) - AC 4, 8, FR12
- Breakout percentage validation (1% minimum) - AC 3, 9
- Phase D validation - AC 6, 10, FR15
- Volume boundary cases (1.49x reject, 1.50x pass)

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../../docs/architecture/12-testing-strategy.md)]
- Unit tests with synthetic data
- Coverage >90% for sos_detector.py
- Validate FR12, FR15 enforcement
- Test all rejection scenarios

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-06 | 1.0 | Story 6.1 split into 6.1A (Core SOS Detection) - Simplified scope: Ice breakout + Volume (FR12) + Phase D only, Deferred to 6.1B: Spread expansion, three-tier close position, late Phase C, MVP SOSBreakout model with core fields, 14 tasks (reduced from 20) | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - No blocking issues encountered during development

### Completion Notes List
- **Model Created**: `backend/src/models/sos_breakout.py` - MVP SOSBreakout model with core fields (id, bar, breakout_pct, volume_ratio, ice_reference, breakout_price, detection_timestamp, trading_range_id)
- **Detector Implemented**: `backend/src/pattern_engine/detectors/sos_detector.py` - Core SOS detection with Phase D validation (FR15), Ice breakout detection (≥1%), and CRITICAL volume expansion validation (FR12 ≥1.5x)
- **Tests Created**: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py` - 14 comprehensive tests covering all ACs:
  - AC 7: Valid SOS detection (2% breakout, 2.0x volume) ✓
  - AC 8: Low-volume rejection (1.4x volume < 1.5x threshold) ✓
  - AC 9: Breakout percentage validation (<1% rejected, ≥1% accepted) ✓
  - AC 10: Phase D validation (other phases rejected) ✓
  - Edge cases: insufficient bars, missing range, invalid Ice, missing volume analysis ✓
  - Boundary cases: 1.49x rejects, 1.50x passes ✓
- **All Tests Pass**: 14/14 tests passing
- **Type Safety**: mypy --strict validation passed with 0 issues
- **Logging**: Comprehensive structlog integration with structured fields for detection start, candidates, rejections (volume/phase), and successful detection
- **FR12 Enforcement**: Volume expansion (≥1.5x) implemented as PRIMARY QUALITY GATE - binary pass/fail, no confidence degradation
- **FR15 Enforcement**: Phase D only for Story 6.1A (Phase C deferred to Story 6.1B)
- **Field Name Fix**: Corrected from `range.ice_level` to `range.ice` to match TradingRange model
- **Boundary Fix**: Corrected breakout validation from `>` to `>=` to allow exactly 1% breakout (AC 3 minimum)

### File List
**Source Files Created:**
- `backend/src/models/sos_breakout.py` - SOSBreakout data model (MVP)
- `backend/src/pattern_engine/detectors/sos_detector.py` - detect_sos_breakout function

**Test Files Created:**
- `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py` - Unit tests (14 tests)

**Files Modified:**
- None (all new files for Story 6.1A)

## QA Results
_Populated by QA agent after completion_
