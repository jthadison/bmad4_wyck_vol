# Story 6.4: SOS vs LPS Entry Preference Logic

## Status
Done
Done

## Story

**As a** SOS detector,
**I want** to prefer LPS entries over direct SOS entries when possible,
**so that** traders get better risk/reward (tighter stops at support).

## Acceptance Criteria

1. Entry preference hierarchy: LPS (best) > SOS direct (acceptable if very strong)
2. LPS advantages: tighter stop (3% below Ice vs 5% for SOS), better R-multiple, confirmation of support
3. SOS direct entry requirements: confidence 80+, volume 2.0x+ (higher bar than LPS)
4. Wait period: after SOS detected, wait 10 bars for potential LPS before signaling direct SOS entry
5. If LPS forms: signal LPS entry (overrides SOS direct)
6. If no LPS after 10 bars: signal SOS direct if meets higher confidence threshold
7. Signal annotation: indicates entry type (LPS_ENTRY vs SOS_DIRECT_ENTRY)
8. Unit test: LPS detected → SOS direct entry suppressed
9. Integration test: strong SOS without pullback generates direct entry
10. User notification: "LPS entry preferred - monitoring for pullback"

## Tasks / Subtasks

- [ ] **Task 1: Create EntryPreference data model** (AC: 1, 2, 7)
  - [ ] Create file: `backend/src/models/entry_preference.py`
  - [ ] Import required types: `Enum`, `Decimal`, `datetime`, `UUID`, `Optional`, `BaseModel`, `Field`
  - [ ] Import dependencies:
    - `from backend.src.models.sos_breakout import SOSBreakout`
    - `from backend.src.models.lps import LPS`
    - `from backend.src.models.trading_range import TradingRange`
  - [ ] Create EntryType enum:
    ```python
    from enum import Enum

    class EntryType(str, Enum):
        """
        Entry type classification for SOS/LPS patterns (AC 7).

        Wyckoff Context:
        - LPS_ENTRY: Lower-risk pullback entry with tighter stop (3% below Ice)
        - SOS_DIRECT_ENTRY: Breakout entry with wider stop (5% below Ice)
        - NO_ENTRY: Waiting for LPS or SOS doesn't meet direct entry threshold
        """
        LPS_ENTRY = "LPS_ENTRY"               # AC 5: LPS formed, use LPS entry (preferred)
        SOS_DIRECT_ENTRY = "SOS_DIRECT_ENTRY" # AC 6: No LPS, use SOS direct (if strong enough)
        NO_ENTRY = "NO_ENTRY"                  # Waiting or doesn't qualify
    ```
  - [ ] Create EntryPreference Pydantic model:
    ```python
    class EntryPreference(BaseModel):
        """
        Entry preference determination for SOS/LPS breakout patterns.

        Purpose:
        -------
        Determines optimal entry type based on pattern availability and quality.
        Prefers LPS entries (tighter stops, better R-multiple) over SOS direct entries.

        Entry Hierarchy (AC 1):
        -----------------------
        1. LPS Entry (BEST): Pullback to Ice support with tighter stop (3% below Ice)
        2. SOS Direct (ACCEPTABLE): Breakout entry if very strong (80+ confidence, 2.0x+ volume)
        3. No Entry (WAIT): Monitor for LPS or SOS not strong enough

        LPS Advantages (AC 2):
        ----------------------
        - Tighter stop: 3% below Ice vs 5% for SOS direct
        - Better R-multiple: Same target (Jump), tighter stop = better ratio
        - Confirmation: Support hold validates SOS breakout legitimacy
        - Lower risk: Entry closer to support, less downside exposure

        SOS Direct Entry Requirements (AC 3):
        --------------------------------------
        - Confidence >= 80 (higher bar than LPS minimum)
        - Volume >= 2.0x (very strong buying interest)
        - Phase D with high confidence OR late Phase C (85+)
        - No LPS formed after 10-bar wait period (AC 4)

        Wait Period Logic (AC 4):
        -------------------------
        - After SOS detected: wait up to 10 bars for potential LPS
        - If LPS forms within 10 bars: use LPS entry (AC 5)
        - If no LPS after 10 bars: evaluate SOS direct entry (AC 6)
        """
        id: UUID = Field(default_factory=uuid4)
        entry_type: EntryType = Field(..., description="Preferred entry type (AC 1, 7)")
        sos_breakout: SOSBreakout = Field(..., description="SOS breakout pattern (required)")
        lps_pattern: Optional[LPS] = Field(None, description="LPS pattern (if formed)")
        trading_range_id: UUID = Field(..., description="Associated trading range")

        # Stop levels (AC 2)
        entry_price: Decimal = Field(..., decimal_places=8, max_digits=18, description="Entry price")
        stop_loss: Decimal = Field(..., decimal_places=8, max_digits=18, description="Stop loss level")
        stop_distance_pct: Decimal = Field(..., decimal_places=4, description="Stop distance % (3% LPS, 5% SOS)")
        ice_level: Decimal = Field(..., decimal_places=8, max_digits=18, description="Ice level reference")

        # Decision metadata
        bars_after_sos: int = Field(..., ge=0, description="Bars since SOS detected")
        wait_period_complete: bool = Field(..., description="Whether 10-bar wait period completed (AC 4)")
        sos_confidence: Optional[int] = Field(None, ge=0, le=100, description="SOS confidence score (Story 6.5)")

        # Rationale
        preference_reason: str = Field(..., description="Why this entry type was selected")
        user_notification: str = Field(..., description="User-facing notification (AC 10)")

        decision_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

        @validator('decision_timestamp', pre=True, always=True)
        def ensure_utc(cls, v):
            """Enforce UTC timezone"""
            if v is None:
                return v
            if v.tzinfo is None:
                return v.replace(tzinfo=timezone.utc)
            return v.astimezone(timezone.utc)

        class Config:
            json_encoders = {
                Decimal: str,
                datetime: lambda v: v.isoformat()
            }

        def get_r_multiple_advantage(self) -> str:
            """
            Get qualitative R-multiple advantage description (AC 2).

            Returns:
                str: "EXCELLENT", "GOOD", "STANDARD"
            """
            if self.entry_type == EntryType.LPS_ENTRY:
                # LPS: 3% stop vs SOS 5% stop = 40% better R-multiple
                return "EXCELLENT"  # Tighter stop, better risk/reward
            elif self.entry_type == EntryType.SOS_DIRECT_ENTRY:
                return "GOOD"  # Wider stop, acceptable risk/reward
            else:
                return "STANDARD"
    ```

- [ ] **Task 2: Implement determine_entry_preference function** (AC: 1, 4)
  - [ ] Create file: `backend/src/pattern_engine/entry_preference.py`
  - [ ] Import dependencies:
    - `from typing import Optional, Tuple`
    - `from decimal import Decimal`
    - `from datetime import timezone`
    - `from backend.src.models.entry_preference import EntryPreference, EntryType`
    - `from backend.src.models.sos_breakout import SOSBreakout`
    - `from backend.src.models.lps import LPS`
    - `from backend.src.models.trading_range import TradingRange`
    - `import structlog`
  - [ ] Create function signature:
    ```python
    def determine_entry_preference(
        sos: SOSBreakout,
        lps: Optional[LPS],
        range: TradingRange,
        bars_after_sos: int,
        sos_confidence: Optional[int] = None
    ) -> EntryPreference:
        """
        Determine optimal entry type for SOS/LPS breakout pattern (AC 1).

        Entry Preference Hierarchy:
        ---------------------------
        1. LPS Entry (PREFERRED - AC 5): If LPS formed within 10 bars after SOS
        2. SOS Direct Entry (ACCEPTABLE - AC 6): If no LPS after 10 bars AND SOS strong enough
        3. No Entry (WAIT - AC 4): Waiting for LPS or SOS not strong enough

        Parameters:
        -----------
        sos : SOSBreakout
            SOS breakout pattern (required context)
        lps : Optional[LPS]
            LPS pattern if formed (None if not yet formed)
        range : TradingRange
            Trading range with Ice and Jump levels
        bars_after_sos : int
            Number of bars since SOS detected (for wait period logic - AC 4)
        sos_confidence : Optional[int]
            SOS confidence score from Story 6.5 (used for AC 3 threshold)

        Returns:
        --------
        EntryPreference
            Entry type, stop levels, and decision rationale

        Decision Logic:
        ---------------
        CASE 1: LPS Formed (AC 5):
          - entry_type = LPS_ENTRY
          - entry_price = near Ice level (~Ice + 0.5%)
          - stop_loss = Ice - 3% (tighter stop - AC 2)
          - preference_reason = "LPS entry preferred: tighter stop, confirmed support"

        CASE 2: No LPS, Wait Period Not Complete (AC 4):
          - bars_after_sos <= 10
          - entry_type = NO_ENTRY
          - preference_reason = "Monitoring for LPS pullback (wait up to 10 bars)"
          - user_notification = "LPS entry preferred - monitoring for pullback" (AC 10)

        CASE 3: No LPS, Wait Period Complete, Strong SOS (AC 6):
          - bars_after_sos > 10
          - sos_confidence >= 80 (AC 3)
          - sos.volume_ratio >= 2.0 (AC 3 - very strong volume)
          - entry_type = SOS_DIRECT_ENTRY
          - entry_price = SOS breakout price
          - stop_loss = Ice - 5% (wider stop)
          - preference_reason = "No LPS after 10 bars, SOS strong enough for direct entry"

        CASE 4: No LPS, Wait Period Complete, Weak SOS:
          - bars_after_sos > 10
          - sos_confidence < 80 OR volume < 2.0x
          - entry_type = NO_ENTRY
          - preference_reason = "SOS not strong enough for direct entry (confidence < 80 or volume < 2.0x)"

        Author: Story 6.4
        """
    ```
  - [ ] Initialize structlog logger
  - [ ] Extract Ice level from range:
    ```python
    logger = structlog.get_logger(__name__)

    ice_level = range.ice_level.price

    logger.debug(
        "entry_preference_determination_start",
        sos_timestamp=sos.bar.timestamp.isoformat(),
        lps_present=lps is not None,
        bars_after_sos=bars_after_sos,
        sos_confidence=sos_confidence,
        message="Determining optimal entry type (LPS vs SOS direct)"
    )
    ```

- [ ] **Task 3: Implement CASE 1 - LPS Entry (Preferred)** (AC: 5)
  - [ ] Check if LPS pattern exists:
    ```python
    # CASE 1: LPS Entry (PREFERRED - AC 5)
    if lps is not None:
        # LPS formed - use LPS entry with tighter stop (AC 2)

        # Entry price: slightly above Ice (conservative entry near support)
        entry_price = ice_level * Decimal("1.005")  # Ice + 0.5%

        # Stop loss: 3% below Ice (tighter than SOS 5% - AC 2)
        stop_loss = ice_level * Decimal("0.97")  # Ice - 3%
        stop_distance_pct = Decimal("3.0")

        preference_reason = (
            f"LPS entry preferred: tighter stop (3% vs 5% SOS), "
            f"confirmed support at Ice ${float(ice_level):.2f}, "
            f"better R-multiple (AC 2)"
        )

        user_notification = (
            f"LPS Entry Signal: Pullback to support confirmed. "
            f"Entry ${float(entry_price):.2f}, Stop ${float(stop_loss):.2f}"
        )

        logger.info(
            "lps_entry_preferred",
            entry_type="LPS_ENTRY",
            entry_price=float(entry_price),
            stop_loss=float(stop_loss),
            stop_distance_pct=float(stop_distance_pct),
            lps_timestamp=lps.bar.timestamp.isoformat(),
            sos_timestamp=sos.bar.timestamp.isoformat(),
            bars_after_sos=lps.bars_after_sos,
            advantage="Tighter stop (3% vs 5%), better R-multiple",
            message="LPS entry selected: pullback to support with tighter stop (AC 5)"
        )

        return EntryPreference(
            entry_type=EntryType.LPS_ENTRY,
            sos_breakout=sos,
            lps_pattern=lps,
            trading_range_id=range.id,
            entry_price=entry_price,
            stop_loss=stop_loss,
            stop_distance_pct=stop_distance_pct,
            ice_level=ice_level,
            bars_after_sos=lps.bars_after_sos,
            wait_period_complete=True,  # LPS formed (within 10 bars)
            sos_confidence=sos_confidence,
            preference_reason=preference_reason,
            user_notification=user_notification
        )
    ```

- [ ] **Task 4: Implement CASE 2 - Wait for LPS (No Entry Yet)** (AC: 4, 10)
  - [ ] Check if wait period is still active:
    ```python
    # CASE 2: Wait for LPS (AC 4, 10)
    WAIT_PERIOD_BARS = 10  # Wait up to 10 bars for LPS to form

    if bars_after_sos <= WAIT_PERIOD_BARS:
        # Still within wait period - monitor for LPS

        # Temporary entry/stop (not used yet - just for model completeness)
        entry_price = sos.breakout_price  # Placeholder
        stop_loss = ice_level * Decimal("0.95")  # 5% below Ice (SOS stop)
        stop_distance_pct = Decimal("5.0")

        preference_reason = (
            f"Monitoring for LPS pullback: {bars_after_sos}/{WAIT_PERIOD_BARS} bars after SOS. "
            f"LPS entry preferred (tighter stop 3% vs 5%) - waiting for pullback to Ice."
        )

        # AC 10: User notification
        user_notification = (
            f"LPS entry preferred - monitoring for pullback to ${float(ice_level):.2f} "
            f"(waiting {WAIT_PERIOD_BARS - bars_after_sos} more bars)"
        )

        logger.debug(
            "waiting_for_lps",
            entry_type="NO_ENTRY",
            bars_after_sos=bars_after_sos,
            wait_period_remaining=WAIT_PERIOD_BARS - bars_after_sos,
            ice_level=float(ice_level),
            message="Wait period active: monitoring for LPS pullback (AC 4, 10)"
        )

        return EntryPreference(
            entry_type=EntryType.NO_ENTRY,
            sos_breakout=sos,
            lps_pattern=None,
            trading_range_id=range.id,
            entry_price=entry_price,  # Placeholder
            stop_loss=stop_loss,      # Placeholder
            stop_distance_pct=stop_distance_pct,
            ice_level=ice_level,
            bars_after_sos=bars_after_sos,
            wait_period_complete=False,  # Still waiting
            sos_confidence=sos_confidence,
            preference_reason=preference_reason,
            user_notification=user_notification
        )
    ```

- [ ] **Task 5: Implement CASE 3 - SOS Direct Entry (Strong SOS)** (AC: 3, 6)
  - [ ] Validate SOS strength for direct entry:
    ```python
    # CASE 3: No LPS after 10 bars - evaluate SOS direct entry (AC 6)
    # Wait period complete, no LPS formed

    # AC 3: SOS direct entry requirements (higher bar than LPS)
    MIN_SOS_DIRECT_CONFIDENCE = 80  # Confidence >= 80
    MIN_SOS_DIRECT_VOLUME = Decimal("2.0")  # Volume >= 2.0x (very strong)

    # Check if SOS meets direct entry thresholds
    confidence_threshold_met = (
        sos_confidence is not None and sos_confidence >= MIN_SOS_DIRECT_CONFIDENCE
    )

    volume_threshold_met = sos.volume_ratio >= MIN_SOS_DIRECT_VOLUME

    sos_strong_enough = confidence_threshold_met and volume_threshold_met

    logger.debug(
        "sos_direct_entry_evaluation",
        sos_confidence=sos_confidence,
        min_confidence=MIN_SOS_DIRECT_CONFIDENCE,
        confidence_met=confidence_threshold_met,
        volume_ratio=float(sos.volume_ratio),
        min_volume=float(MIN_SOS_DIRECT_VOLUME),
        volume_met=volume_threshold_met,
        sos_strong_enough=sos_strong_enough,
        message="Evaluating SOS direct entry (AC 3, 6)"
    )

    if sos_strong_enough:
        # SOS strong enough for direct entry (AC 6)

        # Entry price: SOS breakout price
        entry_price = sos.breakout_price

        # Stop loss: 5% below Ice (wider than LPS 3% - AC 2)
        stop_loss = ice_level * Decimal("0.95")  # Ice - 5%
        stop_distance_pct = Decimal("5.0")

        preference_reason = (
            f"SOS direct entry: No LPS after 10 bars, "
            f"SOS very strong (confidence {sos_confidence}%, volume {float(sos.volume_ratio):.1f}x). "
            f"Wider stop (5% vs LPS 3%) but acceptable R-multiple (AC 3, 6)."
        )

        user_notification = (
            f"SOS Direct Entry: Strong breakout without pullback. "
            f"Entry ${float(entry_price):.2f}, Stop ${float(stop_loss):.2f} "
            f"(Note: LPS would provide tighter stop)"
        )

        logger.info(
            "sos_direct_entry_selected",
            entry_type="SOS_DIRECT_ENTRY",
            entry_price=float(entry_price),
            stop_loss=float(stop_loss),
            stop_distance_pct=float(stop_distance_pct),
            sos_confidence=sos_confidence,
            volume_ratio=float(sos.volume_ratio),
            bars_after_sos=bars_after_sos,
            message="SOS direct entry selected: no LPS, strong SOS (AC 6)"
        )

        return EntryPreference(
            entry_type=EntryType.SOS_DIRECT_ENTRY,
            sos_breakout=sos,
            lps_pattern=None,
            trading_range_id=range.id,
            entry_price=entry_price,
            stop_loss=stop_loss,
            stop_distance_pct=stop_distance_pct,
            ice_level=ice_level,
            bars_after_sos=bars_after_sos,
            wait_period_complete=True,  # 10 bars passed
            sos_confidence=sos_confidence,
            preference_reason=preference_reason,
            user_notification=user_notification
        )
    ```

- [ ] **Task 6: Implement CASE 4 - No Entry (Weak SOS)** (AC: 3)
  - [ ] Handle weak SOS that doesn't qualify for direct entry:
    ```python
    # CASE 4: No LPS, SOS not strong enough for direct entry
    # Wait period complete but SOS doesn't meet direct entry threshold (AC 3)

    entry_price = sos.breakout_price  # Placeholder
    stop_loss = ice_level * Decimal("0.95")
    stop_distance_pct = Decimal("5.0")

    # Determine specific failure reason
    failure_reasons = []
    if sos_confidence is None or sos_confidence < MIN_SOS_DIRECT_CONFIDENCE:
        failure_reasons.append(
            f"confidence {sos_confidence if sos_confidence else 'N/A'}% < {MIN_SOS_DIRECT_CONFIDENCE}%"
        )
    if sos.volume_ratio < MIN_SOS_DIRECT_VOLUME:
        failure_reasons.append(
            f"volume {float(sos.volume_ratio):.1f}x < {float(MIN_SOS_DIRECT_VOLUME):.1f}x"
        )

    failure_reason_str = " AND ".join(failure_reasons)

    preference_reason = (
        f"No entry: No LPS after 10 bars, SOS not strong enough for direct entry "
        f"({failure_reason_str}). Direct SOS entry requires confidence >= 80% AND volume >= 2.0x (AC 3)."
    )

    user_notification = (
        f"No Entry: Breakout not strong enough for direct entry. "
        f"Requirements: confidence >= 80%, volume >= 2.0x. "
        f"Current: confidence {sos_confidence if sos_confidence else 'N/A'}%, "
        f"volume {float(sos.volume_ratio):.1f}x"
    )

    logger.warning(
        "no_entry_weak_sos",
        entry_type="NO_ENTRY",
        sos_confidence=sos_confidence,
        min_confidence=MIN_SOS_DIRECT_CONFIDENCE,
        volume_ratio=float(sos.volume_ratio),
        min_volume=float(MIN_SOS_DIRECT_VOLUME),
        failure_reasons=failure_reasons,
        bars_after_sos=bars_after_sos,
        message="No entry: SOS not strong enough for direct entry (AC 3)"
    )

    return EntryPreference(
        entry_type=EntryType.NO_ENTRY,
        sos_breakout=sos,
        lps_pattern=None,
        trading_range_id=range.id,
        entry_price=entry_price,  # Placeholder
        stop_loss=stop_loss,      # Placeholder
        stop_distance_pct=stop_distance_pct,
        ice_level=ice_level,
        bars_after_sos=bars_after_sos,
        wait_period_complete=True,  # 10 bars passed
        sos_confidence=sos_confidence,
        preference_reason=preference_reason,
        user_notification=user_notification
    )
    ```

- [ ] **Task 7: Write unit test for LPS entry preference** (AC: 5, 8)
  - [ ] Create test file: `backend/tests/unit/pattern_engine/test_entry_preference.py`
  - [ ] Import pytest, Decimal, EntryPreference, EntryType, determine_entry_preference
  - [ ] Create pytest fixtures: `sos_breakout`, `lps_pattern`, `trading_range`
  - [ ] Test AC 5 & 8: LPS detected → SOS direct entry suppressed
    ```python
    def test_lps_entry_preferred_over_sos_direct():
        """AC 5, 8: LPS entry overrides SOS direct entry"""
        # Arrange
        sos = create_sos_breakout(
            volume_ratio=Decimal("2.5"),  # Very strong (qualifies for direct)
            breakout_price=Decimal("102.00")
        )
        lps = create_lps_pattern(
            pullback_low=Decimal("100.50"),
            bars_after_sos=5  # LPS formed 5 bars after SOS
        )
        range = create_trading_range(ice_level=Decimal("100.00"))
        sos_confidence = 90  # High confidence (qualifies for direct)

        # Act
        preference = determine_entry_preference(
            sos=sos,
            lps=lps,  # LPS present
            range=range,
            bars_after_sos=5,
            sos_confidence=sos_confidence
        )

        # Assert (AC 5, 8)
        assert preference.entry_type == EntryType.LPS_ENTRY, "LPS entry should be preferred"
        assert preference.lps_pattern is not None, "LPS pattern should be included"
        assert preference.stop_distance_pct == Decimal("3.0"), "LPS stop: 3% below Ice"
        assert preference.stop_loss == Decimal("97.00"), "Stop at Ice - 3%"

        # AC 2: Verify LPS advantages
        assert "tighter stop" in preference.preference_reason.lower()
        assert "better R-multiple" in preference.preference_reason.lower() or "better risk" in preference.preference_reason.lower()

        # Even though SOS qualifies for direct entry, LPS overrides
        assert preference.sos_confidence == 90
        assert sos.volume_ratio >= Decimal("2.0")  # SOS strong enough for direct
    ```

- [ ] **Task 8: Write unit test for wait period logic** (AC: 4, 10)
  - [ ] Test wait period monitoring (bars 1-10):
    ```python
    def test_wait_period_monitoring():
        """AC 4, 10: Wait up to 10 bars for LPS before SOS direct"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        # Test at bar 3 (within wait period)
        preference = determine_entry_preference(
            sos=sos,
            lps=None,  # No LPS yet
            range=range,
            bars_after_sos=3,  # 3 bars after SOS
            sos_confidence=90
        )

        # Assert (AC 4)
        assert preference.entry_type == EntryType.NO_ENTRY, "Should wait for LPS"
        assert preference.wait_period_complete is False, "Wait period not complete"
        assert preference.bars_after_sos == 3

        # AC 10: User notification
        assert "LPS entry preferred" in preference.user_notification
        assert "monitoring for pullback" in preference.user_notification.lower()
        assert "7 more bars" in preference.user_notification or "waiting" in preference.user_notification.lower()
    ```
  - [ ] Test wait period boundary (bar 10 vs 11):
    ```python
    def test_wait_period_boundary():
        """Wait period ends at bar 10"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        # Bar 10: still waiting
        pref_10 = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=10, sos_confidence=90
        )
        assert pref_10.entry_type == EntryType.NO_ENTRY, "Bar 10: still waiting"
        assert pref_10.wait_period_complete is False

        # Bar 11: wait complete, evaluate SOS direct
        pref_11 = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=11, sos_confidence=90
        )
        assert pref_11.entry_type == EntryType.SOS_DIRECT_ENTRY, "Bar 11: SOS direct if strong"
        assert pref_11.wait_period_complete is True
    ```

- [ ] **Task 9: Write unit test for SOS direct entry thresholds** (AC: 3, 6, 9)
  - [ ] Test strong SOS qualifies for direct entry:
    ```python
    def test_strong_sos_direct_entry():
        """AC 6, 9: Strong SOS without pullback generates direct entry"""
        # Arrange: Strong SOS (confidence 90%, volume 2.5x)
        sos = create_sos_breakout(
            volume_ratio=Decimal("2.5"),  # > 2.0x (AC 3)
            breakout_price=Decimal("102.00")
        )
        range = create_trading_range(ice_level=Decimal("100.00"))

        # Act: No LPS, wait period complete (11 bars)
        preference = determine_entry_preference(
            sos=sos,
            lps=None,  # No LPS
            range=range,
            bars_after_sos=11,  # Wait period complete
            sos_confidence=90  # >= 80 (AC 3)
        )

        # Assert (AC 6, 9)
        assert preference.entry_type == EntryType.SOS_DIRECT_ENTRY
        assert preference.lps_pattern is None, "No LPS present"
        assert preference.stop_distance_pct == Decimal("5.0"), "SOS stop: 5% below Ice"
        assert preference.stop_loss == Decimal("95.00"), "Stop at Ice - 5%"
        assert preference.entry_price == Decimal("102.00"), "Entry at SOS breakout price"
        assert preference.wait_period_complete is True

        # Verify direct entry requirements met (AC 3)
        assert preference.sos_confidence >= 80
        assert sos.volume_ratio >= Decimal("2.0")
    ```
  - [ ] Test confidence threshold (79% vs 80%):
    ```python
    def test_sos_confidence_threshold():
        """AC 3: Confidence >= 80 required for SOS direct"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))  # Volume OK
        range = create_trading_range(ice_level=Decimal("100.00"))

        # 79% confidence: NO ENTRY
        pref_79 = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=11, sos_confidence=79
        )
        assert pref_79.entry_type == EntryType.NO_ENTRY, "79% confidence < 80% threshold"

        # 80% confidence: SOS DIRECT
        pref_80 = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=11, sos_confidence=80
        )
        assert pref_80.entry_type == EntryType.SOS_DIRECT_ENTRY, "80% confidence >= 80% threshold"
    ```
  - [ ] Test volume threshold (1.9x vs 2.0x):
    ```python
    def test_sos_volume_threshold():
        """AC 3: Volume >= 2.0x required for SOS direct"""
        range = create_trading_range(ice_level=Decimal("100.00"))

        # 1.9x volume: NO ENTRY
        sos_19 = create_sos_breakout(volume_ratio=Decimal("1.9"))  # < 2.0x
        pref_19 = determine_entry_preference(
            sos=sos_19, lps=None, range=range, bars_after_sos=11, sos_confidence=90
        )
        assert pref_19.entry_type == EntryType.NO_ENTRY, "1.9x volume < 2.0x threshold"

        # 2.0x volume: SOS DIRECT
        sos_20 = create_sos_breakout(volume_ratio=Decimal("2.0"))  # >= 2.0x
        pref_20 = determine_entry_preference(
            sos=sos_20, lps=None, range=range, bars_after_sos=11, sos_confidence=90
        )
        assert pref_20.entry_type == EntryType.SOS_DIRECT_ENTRY, "2.0x volume >= 2.0x threshold"
    ```

- [ ] **Task 10: Write unit test for stop distance comparison** (AC: 2)
  - [ ] Test LPS vs SOS stop distances:
    ```python
    def test_lps_vs_sos_stop_distance():
        """AC 2: LPS 3% stop vs SOS 5% stop"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        # LPS Entry: 3% stop
        lps = create_lps_pattern(bars_after_sos=5)
        pref_lps = determine_entry_preference(
            sos=sos, lps=lps, range=range, bars_after_sos=5, sos_confidence=90
        )
        assert pref_lps.entry_type == EntryType.LPS_ENTRY
        assert pref_lps.stop_distance_pct == Decimal("3.0"), "LPS: 3% stop"
        assert pref_lps.stop_loss == Decimal("97.00"), "Stop at Ice ($100) - 3%"

        # SOS Direct Entry: 5% stop
        pref_sos = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=11, sos_confidence=90
        )
        assert pref_sos.entry_type == EntryType.SOS_DIRECT_ENTRY
        assert pref_sos.stop_distance_pct == Decimal("5.0"), "SOS: 5% stop"
        assert pref_sos.stop_loss == Decimal("95.00"), "Stop at Ice ($100) - 5%"

        # AC 2: LPS has tighter stop (better R-multiple)
        lps_stop_distance = pref_lps.stop_distance_pct
        sos_stop_distance = pref_sos.stop_distance_pct
        assert lps_stop_distance < sos_stop_distance, "LPS stop (3%) < SOS stop (5%)"

        # Verify R-multiple advantage
        assert pref_lps.get_r_multiple_advantage() == "EXCELLENT"
        assert pref_sos.get_r_multiple_advantage() == "GOOD"
    ```

- [ ] **Task 11: Write unit test for entry type annotation** (AC: 7)
  - [ ] Test entry type field in preference result:
    ```python
    def test_entry_type_annotation():
        """AC 7: Signal annotation indicates entry type"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        # LPS Entry
        lps = create_lps_pattern(bars_after_sos=5)
        pref_lps = determine_entry_preference(
            sos=sos, lps=lps, range=range, bars_after_sos=5, sos_confidence=90
        )
        assert pref_lps.entry_type == EntryType.LPS_ENTRY, "AC 7: LPS_ENTRY annotation"
        assert pref_lps.entry_type.value == "LPS_ENTRY"

        # SOS Direct Entry
        pref_sos = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=11, sos_confidence=90
        )
        assert pref_sos.entry_type == EntryType.SOS_DIRECT_ENTRY, "AC 7: SOS_DIRECT_ENTRY annotation"
        assert pref_sos.entry_type.value == "SOS_DIRECT_ENTRY"

        # No Entry
        pref_none = determine_entry_preference(
            sos=sos, lps=None, range=range, bars_after_sos=5, sos_confidence=90
        )
        assert pref_none.entry_type == EntryType.NO_ENTRY, "AC 7: NO_ENTRY annotation"
    ```

- [ ] **Task 12: Write integration test with realistic scenario** (AC: all)
  - [ ] Create test file: `backend/tests/integration/pattern_engine/test_entry_preference_integration.py`
  - [ ] Test full SOS → LPS → Entry flow:
    ```python
    def test_sos_lps_entry_preference_full_flow():
        """Integration test: Full SOS → LPS → Entry preference workflow"""
        # Scenario: Strong SOS at bar 25, LPS at bar 30

        # Step 1: SOS detected at bar 25
        sos = detect_sos_breakout(range, bars[:25], volume_analysis, phase)
        assert sos is not None, "SOS should be detected"

        # Step 2: Bars 26-30 - wait for LPS
        for bars_after in range(1, 6):
            preference = determine_entry_preference(
                sos=sos,
                lps=None,  # No LPS yet
                range=range,
                bars_after_sos=bars_after,
                sos_confidence=85
            )
            # Should wait for LPS
            assert preference.entry_type == EntryType.NO_ENTRY
            assert "monitoring for pullback" in preference.user_notification.lower()

        # Step 3: LPS detected at bar 30 (5 bars after SOS)
        lps = detect_lps(range, sos, bars[:30], volume_analysis)
        assert lps is not None, "LPS should be detected"
        assert lps.bars_after_sos == 5

        # Step 4: Entry preference with LPS present
        preference_with_lps = determine_entry_preference(
            sos=sos,
            lps=lps,  # LPS formed
            range=range,
            bars_after_sos=5,
            sos_confidence=85
        )

        # Verify LPS entry selected
        assert preference_with_lps.entry_type == EntryType.LPS_ENTRY
        assert preference_with_lps.stop_distance_pct == Decimal("3.0")
        assert "LPS entry" in preference_with_lps.user_notification
    ```
  - [ ] Test SOS without LPS (direct entry after 10 bars):
    ```python
    def test_sos_no_lps_direct_entry():
        """Strong SOS, no LPS forms, direct entry after 10 bars"""
        # Scenario: SOS at bar 25, no pullback, bars continue higher

        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        # Bars 1-10: Wait for LPS
        for bars_after in range(1, 11):
            pref = determine_entry_preference(
                sos=sos, lps=None, range=range,
                bars_after_sos=bars_after, sos_confidence=90
            )
            assert pref.entry_type == EntryType.NO_ENTRY, f"Bar {bars_after}: waiting"

        # Bar 11: Wait complete, no LPS, SOS strong enough
        pref_11 = determine_entry_preference(
            sos=sos, lps=None, range=range,
            bars_after_sos=11, sos_confidence=90
        )
        assert pref_11.entry_type == EntryType.SOS_DIRECT_ENTRY
        assert pref_11.stop_distance_pct == Decimal("5.0")
        assert "No LPS after 10 bars" in pref_11.preference_reason
    ```

- [ ] **Task 13: Write unit test for edge cases**
  - [ ] Test missing confidence (None):
    ```python
    def test_missing_confidence_no_direct_entry():
        """No SOS confidence provided → no direct entry"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        range = create_trading_range(ice_level=Decimal("100.00"))

        preference = determine_entry_preference(
            sos=sos,
            lps=None,
            range=range,
            bars_after_sos=11,
            sos_confidence=None  # Missing confidence
        )

        assert preference.entry_type == EntryType.NO_ENTRY
        assert "confidence" in preference.preference_reason.lower()
    ```
  - [ ] Test LPS formed exactly at bar 10:
    ```python
    def test_lps_at_bar_10_boundary():
        """LPS formed at bar 10 (boundary case)"""
        sos = create_sos_breakout(volume_ratio=Decimal("2.5"))
        lps = create_lps_pattern(bars_after_sos=10)  # Exactly at boundary
        range = create_trading_range(ice_level=Decimal("100.00"))

        preference = determine_entry_preference(
            sos=sos, lps=lps, range=range,
            bars_after_sos=10, sos_confidence=90
        )

        # LPS formed, so LPS entry (even at boundary)
        assert preference.entry_type == EntryType.LPS_ENTRY
        assert preference.stop_distance_pct == Decimal("3.0")
    ```

- [ ] **Task 14: Add comprehensive docstrings and examples**
  - [ ] Add module-level docstring to `entry_preference.py`:
    ```python
    """
    SOS vs LPS Entry Preference Logic Module

    Purpose:
    --------
    Determines optimal entry type for SOS/LPS breakout patterns.
    Prefers LPS entries (tighter stops, better R-multiple) over SOS direct entries.

    Entry Hierarchy (AC 1):
    -----------------------
    1. LPS Entry (BEST): Pullback to Ice support with tighter stop (3% below Ice)
    2. SOS Direct (ACCEPTABLE): Breakout entry if very strong (80+ confidence, 2.0x+ volume)
    3. No Entry (WAIT): Monitor for LPS or SOS not strong enough

    LPS Advantages (AC 2):
    ----------------------
    - Tighter stop: 3% below Ice vs 5% for SOS direct
    - Better R-multiple: Same target (Jump), tighter stop = better ratio (40% improvement)
    - Confirmation: Support hold validates SOS breakout legitimacy
    - Lower risk: Entry closer to support, less downside exposure

    SOS Direct Entry Requirements (AC 3):
    --------------------------------------
    - Confidence >= 80 (higher bar than LPS minimum 70)
    - Volume >= 2.0x (very strong buying interest, not just 1.5x)
    - Phase D with high confidence OR late Phase C (85+)
    - No LPS formed after 10-bar wait period (AC 4)

    Wait Period Logic (AC 4):
    -------------------------
    After SOS detected:
    - Wait up to 10 bars for potential LPS pullback to Ice
    - If LPS forms within 10 bars → use LPS entry (AC 5)
    - If no LPS after 10 bars → evaluate SOS direct entry (AC 6)
    - User notification: "LPS entry preferred - monitoring for pullback" (AC 10)

    Decision Tree:
    --------------
    1. Is LPS present?
       YES → LPS Entry (3% stop, best R-multiple)
       NO  → Continue to step 2

    2. Is bars_after_sos <= 10?
       YES → No Entry (wait for LPS)
       NO  → Continue to step 3

    3. Is SOS strong enough? (confidence >= 80 AND volume >= 2.0x)
       YES → SOS Direct Entry (5% stop, acceptable R-multiple)
       NO  → No Entry (SOS not strong enough for direct entry)

    Wyckoff Context:
    ----------------
    LPS (Last Point of Support):
    - Pullback to old resistance (Ice) which now acts as support
    - Tests whether SOS breakout is legitimate
    - Provides lower-risk entry with tighter stop
    - Classic Wyckoff Phase D entry pattern

    SOS Direct Entry:
    - Immediate entry on breakout (no pullback)
    - Higher risk due to wider stop (5% vs 3%)
    - Only used when very strong (80+ confidence, 2.0x+ volume)
    - Less desirable than LPS but acceptable if no pullback

    Risk/Reward Comparison:
    -----------------------
    Example: Ice at $100, Jump target at $115

    LPS Entry:
    - Entry: $100.50 (near Ice)
    - Stop: $97.00 (Ice - 3%)
    - Target: $115.00 (Jump)
    - Risk: $3.50
    - Reward: $14.50
    - R-multiple: 4.14R (EXCELLENT)

    SOS Direct Entry:
    - Entry: $102.00 (breakout price)
    - Stop: $95.00 (Ice - 5%)
    - Target: $115.00 (Jump)
    - Risk: $7.00
    - Reward: $13.00
    - R-multiple: 1.86R (ACCEPTABLE)

    → LPS provides 2.2x better R-multiple than SOS direct!

    Usage:
    ------
    >>> from backend.src.pattern_engine.entry_preference import determine_entry_preference
    >>>
    >>> # After SOS detected
    >>> sos = detect_sos_breakout(range, bars, volume_analysis, phase)
    >>>
    >>> # Monitor for LPS over 10 bars
    >>> for bars_after in range(1, 11):
    >>>     lps = detect_lps(range, sos, bars, volume_analysis)
    >>>     preference = determine_entry_preference(
    >>>         sos=sos,
    >>>         lps=lps,
    >>>         range=range,
    >>>         bars_after_sos=bars_after,
    >>>         sos_confidence=calculate_sos_confidence(sos, lps, range, phase)
    >>>     )
    >>>
    >>>     if preference.entry_type == EntryType.LPS_ENTRY:
    >>>         print(f"LPS Entry: {preference.user_notification}")
    >>>         break
    >>>     elif preference.entry_type == EntryType.NO_ENTRY:
    >>>         print(f"Waiting: {preference.user_notification}")
    >>>
    >>> # After 10 bars, evaluate SOS direct if no LPS
    >>> if preference.entry_type == EntryType.SOS_DIRECT_ENTRY:
    >>>     print(f"SOS Direct: {preference.user_notification}")
    >>> elif preference.entry_type == EntryType.NO_ENTRY:
    >>>     print(f"No entry: {preference.preference_reason}")

    Integration:
    ------------
    - Story 6.1: SOS breakout detection (required input)
    - Story 6.3: LPS detection (preferred but optional)
    - Story 6.5: SOS/LPS confidence scoring (used for AC 3 threshold)
    - Story 6.6: Signal generation (uses EntryPreference for entry/stop/target)

    Author: Story 6.4
    """
    ```

- [ ] **Task 15: Add type hints and mypy validation**
  - [ ] Add comprehensive type hints to all functions
  - [ ] Use strict typing: `from __future__ import annotations`
  - [ ] Run mypy in strict mode: `mypy --strict entry_preference.py`
  - [ ] Fix any type errors
  - [ ] Ensure Optional, Tuple, List types properly annotated

- [ ] **Task 16: Add comprehensive logging**
  - [ ] Log entry preference determination start
  - [ ] Log each decision case (LPS, wait, SOS direct, no entry)
  - [ ] Log threshold checks (confidence, volume)
  - [ ] Log final preference selection with rationale
  - [ ] Use structlog with structured fields
  - [ ] Follow [architecture/17-monitoring-and-observability.md](../../architecture/17-monitoring-and-observability.md)
  - [ ] Include correlation IDs for tracing

## Dev Notes

### Previous Story Context

**Story 6.1 (SOS Breakout Detection Logic):**
[Source: [epic-6/6.1.sos-breakout-detection-logic.md](6.1.sos-breakout-detection-logic.md)]
- SOS detector identifies decisive breaks above Ice with high volume (>=1.5x)
- SOSBreakout model includes: bar, breakout_pct, volume_ratio, spread_ratio, close_position
- Volume expansion (1.5x+) is NON-NEGOTIABLE (FR12)
- Phase validation: primarily Phase D, late Phase C acceptable (85+ confidence)
- **Story 6.4 integration:** SOS is required input for entry preference determination

**Story 6.3 (LPS Detection):**
[Source: [epic-6/6.3.lps-detection.md](6.3.lps-detection.md)]
- LPS detector identifies pullbacks to old resistance (Ice) after SOS breakout
- LPS requirements: pullback within 10 bars, holds above Ice - 2%, reduced volume, bounce confirmation
- LPS provides tighter stop (3% below Ice) vs SOS direct (5% below Ice)
- **Story 6.4 integration:** LPS is PREFERRED entry type when available (AC 1)

**Key Learnings from Story 6.1 and 6.3:**
- SOS marks beginning of markup (Phase D)
- LPS is the "second chance" entry after SOS with better risk/reward
- Volume requirements differ: SOS needs HIGH volume (>=1.5x), LPS needs LOW volume (<1.0x)
- Timing window: LPS must form within 10 bars after SOS
- Stop levels: LPS 3% below Ice, SOS direct 5% below Ice

**Epic 3 (Trading Range & Ice Level):**
[Source: docs/prd/epic-3-trading-range-level-detection.md]
- Ice level is volume-weighted resistance from pivot highs
- After SOS, Ice becomes support (old resistance = new support)
- **Story 6.4 integration:** Ice level used for stop loss calculations (Ice - 3% or Ice - 5%)

**Epic 4 (Phase Classification):**
[Source: Epic 4]
- PhaseDetector provides WyckoffPhase classification with confidence
- SOS primarily in Phase D, LPS follows SOS in Phase D
- **Story 6.4 integration:** Phase context validates SOS strength for direct entry

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../architecture/3-tech-stack.md)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models: EntryPreference, validation)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../architecture/10-unified-project-structure.md)]
- New Model: `backend/src/models/entry_preference.py` (create new)
- New Module: `backend/src/pattern_engine/entry_preference.py` (create new)
- Unit Tests: `backend/tests/unit/pattern_engine/test_entry_preference.py` (create new)
- Integration Tests: `backend/tests/integration/pattern_engine/test_entry_preference_integration.py` (create new)

**Dependencies:**
- `backend/src/models/sos_breakout.py`: SOSBreakout (Story 6.1)
- `backend/src/models/lps.py`: LPS (Story 6.3)
- `backend/src/models/trading_range.py`: TradingRange with ice_level (Epic 3)
- Pydantic BaseModel, Field, validator, Enum
- structlog for logging
- Decimal for precise financial calculations
- datetime.timezone for UTC timestamps

### Data Models

**EntryType Enum:**

```python
class EntryType(str, Enum):
    LPS_ENTRY = "LPS_ENTRY"               # Best: 3% stop, tighter risk
    SOS_DIRECT_ENTRY = "SOS_DIRECT_ENTRY" # Acceptable: 5% stop, wider risk
    NO_ENTRY = "NO_ENTRY"                  # Wait or doesn't qualify
```

**EntryPreference Model:**

See Task 1 for complete model definition. Key fields:
- `entry_type: EntryType` - Preferred entry (AC 1, 7)
- `sos_breakout: SOSBreakout` - SOS context (required)
- `lps_pattern: Optional[LPS]` - LPS if formed (preferred)
- `entry_price: Decimal` - Entry level
- `stop_loss: Decimal` - Stop level
- `stop_distance_pct: Decimal` - 3% (LPS) or 5% (SOS)
- `bars_after_sos: int` - For wait period logic (AC 4)
- `wait_period_complete: bool` - 10-bar wait complete
- `sos_confidence: int` - For AC 3 threshold
- `preference_reason: str` - Decision rationale
- `user_notification: str` - User-facing message (AC 10)

### Algorithm Details

**Entry Preference Determination Algorithm:**

```
Purpose: Determine optimal entry type (LPS vs SOS direct) for breakout patterns

Input:
- sos: SOSBreakout (required - breakout context)
- lps: Optional[LPS] (if formed within 10 bars)
- range: TradingRange (for Ice level)
- bars_after_sos: int (for wait period logic)
- sos_confidence: int (for AC 3 threshold)

Algorithm:

STEP 1: Check for LPS Entry (PREFERRED - AC 5)
  IF lps is not None:
    entry_type = LPS_ENTRY
    entry_price = Ice * 1.005 (Ice + 0.5%)
    stop_loss = Ice * 0.97 (Ice - 3%)
    stop_distance_pct = 3.0
    preference_reason = "LPS entry preferred: tighter stop, confirmed support"
    RETURN EntryPreference with LPS details

STEP 2: Check Wait Period (AC 4)
  IF bars_after_sos <= 10:
    entry_type = NO_ENTRY
    wait_period_complete = False
    preference_reason = "Monitoring for LPS pullback (wait up to 10 bars)"
    user_notification = "LPS entry preferred - monitoring for pullback" (AC 10)
    RETURN EntryPreference with wait status

STEP 3: Evaluate SOS Direct Entry (AC 6)
  # Wait period complete, no LPS formed
  wait_period_complete = True

  # Check SOS strength for direct entry (AC 3)
  confidence_ok = (sos_confidence >= 80)
  volume_ok = (sos.volume_ratio >= 2.0)
  sos_strong_enough = confidence_ok AND volume_ok

  IF sos_strong_enough:
    entry_type = SOS_DIRECT_ENTRY
    entry_price = sos.breakout_price
    stop_loss = Ice * 0.95 (Ice - 5%)
    stop_distance_pct = 5.0
    preference_reason = "No LPS after 10 bars, SOS very strong (confidence >=80%, volume >=2.0x)"
    RETURN EntryPreference with SOS direct details

  ELSE:
    # SOS not strong enough for direct entry
    entry_type = NO_ENTRY
    preference_reason = "SOS not strong enough for direct entry (confidence <80 or volume <2.0x)"
    RETURN EntryPreference with rejection details

Output:
- EntryPreference with entry_type, stop levels, and decision rationale
```

**Decision Tree:**

```
SOS Detected
    ↓
Is LPS present?
    ├─ YES → LPS_ENTRY (3% stop, best R-multiple)
    └─ NO  → Continue
              ↓
         bars_after_sos <= 10?
              ├─ YES → NO_ENTRY (wait for LPS)
              └─ NO  → Continue
                        ↓
                   SOS strong enough?
                   (confidence >= 80 AND volume >= 2.0x)
                        ├─ YES → SOS_DIRECT_ENTRY (5% stop)
                        └─ NO  → NO_ENTRY (too weak)
```

### Wyckoff Context

**LPS vs SOS Direct Entry - Wyckoff Perspective:**

**LPS Entry (PREFERRED - AC 1):**

> "LPS (Last Point of Support) is the OPTIMAL entry for Phase D markup. After SOS breaks above resistance (Ice), LPS is the pullback where price tests Ice as new support. The pullback provides a lower-risk entry with tighter stop placement (3% below Ice)."

**Advantages (AC 2):**
1. **Tighter Stop (3% vs 5%):** Entry near support allows tighter stop
2. **Better R-multiple:** Same target (Jump), tighter stop = better ratio (40% improvement)
3. **Confirmation:** Support hold validates SOS breakout legitimacy
4. **Lower Risk:** Entry closer to support, less downside exposure
5. **Classic Pattern:** Textbook Wyckoff Phase D entry

**SOS Direct Entry (ACCEPTABLE - AC 3, 6):**

> "SOS direct entry is acceptable ONLY when SOS is very strong (80+ confidence, 2.0x+ volume) AND no LPS forms after 10 bars. Direct entry requires higher conviction due to wider stop (5% below Ice)."

**Why Higher Requirements (AC 3):**
- Wider stop (5%) increases risk per trade
- No support confirmation (no pullback test)
- Higher breakeven point (must move further to profit)
- Requires very strong SOS to justify wider risk

**Direct Entry Thresholds:**
- Confidence >= 80% (vs 70% for LPS)
- Volume >= 2.0x (vs 1.5x for SOS detection)
- No LPS after 10-bar wait period

**Wait Period Logic (AC 4):**

> "After SOS detected, wait up to 10 bars for potential LPS. Most valid LPS pullbacks occur within 5-10 bars. If no LPS after 10 bars, price likely continuing higher without pullback - evaluate SOS direct entry."

**Timing Windows:**
- **Bars 1-10:** Wait for LPS (preferred entry)
- **Bar 11+:** Evaluate SOS direct if no LPS

**Stop Placement - Wyckoff Principles:**

**LPS Stop (3% below Ice):**
- Ice now acts as support (old resistance flipped)
- Stop below support with small cushion (3%)
- Breaking Ice - 3% invalidates breakout (support failed)
- Tighter stop improves R-multiple significantly

**SOS Direct Stop (5% below Ice):**
- Wider cushion needed (no pullback confirmation)
- Allows for normal volatility after breakout
- Breaking Ice - 5% indicates false breakout
- Wider stop reduces R-multiple but still acceptable

**R-Multiple Comparison Example:**

Ice: $100, Jump Target: $115

| Entry Type | Entry | Stop | Target | Risk | Reward | R-Multiple | Quality |
|------------|-------|------|--------|------|--------|------------|---------|
| **LPS** | $100.50 | $97.00 | $115.00 | $3.50 | $14.50 | **4.14R** | EXCELLENT |
| **SOS Direct** | $102.00 | $95.00 | $115.00 | $7.00 | $13.00 | **1.86R** | ACCEPTABLE |

→ LPS provides 2.2x better R-multiple than SOS direct!

**When to Use Each Entry:**

| Scenario | Entry Type | Rationale |
|----------|------------|-----------|
| LPS formed within 10 bars | **LPS_ENTRY** | Best risk/reward, confirmed support (AC 5) |
| Bars 1-10, no LPS yet | **NO_ENTRY** | Wait for potential LPS (AC 4, 10) |
| Bars 11+, no LPS, SOS 90% confidence, 2.5x volume | **SOS_DIRECT_ENTRY** | Very strong SOS justifies direct entry (AC 6) |
| Bars 11+, no LPS, SOS 75% confidence, 1.8x volume | **NO_ENTRY** | SOS not strong enough for direct (AC 3) |

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../architecture/15-coding-standards.md)]
- Classes: PascalCase (`EntryPreference`, `EntryType`)
- Functions: snake_case (`determine_entry_preference`, `get_r_multiple_advantage`)
- Variables: snake_case (`entry_price`, `stop_loss`, `bars_after_sos`)
- Constants: UPPER_SNAKE_CASE (`WAIT_PERIOD_BARS`, `MIN_SOS_DIRECT_CONFIDENCE`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../architecture/15-coding-standards.md)]
- ✅ Use Decimal for financial calculations: `stop_loss: Decimal`
- ✅ Use type hints: `def determine_entry_preference(...) -> EntryPreference:`
- ✅ Use Pydantic models for validation (EntryPreference model)
- ✅ Use Enums for entry types: `EntryType.LPS_ENTRY`
- ❌ DON'T use float for prices or percentages

**Decimal Precision:**
[Source: [architecture/4-data-models.md](../../architecture/4-data-models.md)]
- Prices: `NUMERIC(18,8)` → `Decimal` with 8 decimal places
- Percentages: `NUMERIC(10,4)` → `Decimal` with 4 decimal places
- Always use `Decimal("3.0")` not `3.0` (float) for stop distance

### Performance Requirements

- Single preference determination: <5ms (simple decision tree)
- Batch processing (10 SOS/LPS pairs): <50ms
- O(1) complexity (fixed number of checks)
- No loops, linear decision flow

### Integration Notes

**Epic 6 Workflow:**

```
Story 6.1: Detect SOS Breakout → SOSBreakout
    ↓
Story 6.3: Detect LPS (pullback to Ice) → Optional[LPS]
    ↓
Story 6.4: Determine Entry Preference → EntryPreference ← THIS STORY
    ↓
Story 6.5: Calculate SOS/LPS Confidence → int (0-100) [used for AC 3]
    ↓
Story 6.6: Generate SOS/LPS Signal → Signal (entry/stop/target)
```

**Integration with Story 6.1 (SOS Detection):**

```python
# Story 6.1 detects SOS first
sos = detect_sos_breakout(range, bars, volume_analysis, phase)

if sos is not None:
    # Story 6.4 determines entry preference
    # (after monitoring for LPS in Story 6.3)
```

**Integration with Story 6.3 (LPS Detection):**

```python
# Story 6.3 searches for LPS after SOS
lps = detect_lps(range, sos, bars, volume_analysis)

# Story 6.4 prefers LPS entry if LPS formed
preference = determine_entry_preference(
    sos=sos,
    lps=lps,  # May be None if not formed yet
    range=range,
    bars_after_sos=bars_after_sos,
    sos_confidence=sos_confidence
)
```

**Integration with Story 6.5 (Confidence Scoring):**

```python
# Story 6.5 provides confidence score for AC 3 threshold
sos_confidence = calculate_sos_confidence(sos, lps, range, phase)

# Story 6.4 uses confidence for SOS direct entry threshold (>= 80)
if sos_confidence >= 80 and sos.volume_ratio >= 2.0:
    # SOS strong enough for direct entry
```

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/test_entry_preference.py`
- Integration: `backend/tests/integration/pattern_engine/test_entry_preference_integration.py`

### Coverage Requirements
- LPS entry preference (overrides SOS direct) - AC 5, 8
- Wait period logic (10 bars) - AC 4, 10
- SOS direct entry thresholds (80% confidence, 2.0x volume) - AC 3, 6, 9
- Stop distance comparison (3% LPS vs 5% SOS) - AC 2
- Entry type annotation - AC 7
- Edge cases: missing confidence, boundary conditions
- Integration: full SOS → LPS → entry flow

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../architecture/12-testing-strategy.md)]
- Unit tests with synthetic SOS/LPS data
- Integration tests with realistic scenarios
- Coverage >90% for entry_preference.py
- Validate AC 1-10 enforcement
- Test all decision branches
- Parametrized tests for threshold boundaries

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story: SOS vs LPS entry preference logic with hierarchy (LPS > SOS direct), wait period (10 bars), direct entry thresholds (80% confidence, 2.0x volume), stop distance comparison (3% vs 5%), comprehensive Wyckoff context, R-multiple analysis | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
claude-sonnet-4-5-20250929 (Sonnet 4.5)

### Debug Log References
- Fixed TradingRange model field access: `range.ice.price` (not `range.ice_level.price`)
- Resolved test fixture imports: Used IceLevel, CreekLevel, JumpLevel, PriceCluster, Pivot models
- Created `create_simple_trading_range()` helper adapted from LPS detector tests
- Fixed test assertions for case-insensitive string matching

### Completion Notes List
1. **Data Model**: Created EntryPreference Pydantic model with 19 fields (ID, entry type, SOS/LPS patterns, stop levels, decision metadata)
2. **EntryType Enum**: Defined LPS_ENTRY (best), SOS_DIRECT_ENTRY (acceptable), NO_ENTRY (wait)
3. **Decision Logic**: Implemented 4-case logic (LPS present, wait period, strong SOS, weak SOS)
4. **Constants**: WAIT_PERIOD_BARS=10, MIN_SOS_DIRECT_CONFIDENCE=80, MIN_SOS_DIRECT_VOLUME=2.0
5. **Stop Distance**: LPS 3% below Ice, SOS 5% below Ice (40% better R-multiple for LPS)
6. **Unit Tests**: 16 test cases covering all 10 ACs (wait period, thresholds, entry hierarchy)
7. **Integration Tests**: 5 realistic scenarios (SOS→LPS flow, direct entry, weak SOS, edge cases)
8. **Type Safety**: mypy --strict validation - 0 issues
9. **Test Coverage**: 21/21 tests passing (100% pass rate)

### File List
- [backend/src/models/entry_preference.py](../../backend/src/models/entry_preference.py) - EntryPreference model, EntryType enum (238 lines)
- [backend/src/pattern_engine/entry_preference.py](../../backend/src/pattern_engine/entry_preference.py) - determine_entry_preference function (433 lines)
- [backend/tests/unit/pattern_engine/test_entry_preference.py](../../backend/tests/unit/pattern_engine/test_entry_preference.py) - 16 unit tests (700+ lines)
- [backend/tests/integration/pattern_engine/test_entry_preference_integration.py](../../backend/tests/integration/pattern_engine/test_entry_preference_integration.py) - 5 integration tests (500+ lines)

## QA Results
_Populated by QA agent after completion_
