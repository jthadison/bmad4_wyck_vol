# Story 6.1: SOS Breakout Detection Logic

**⚠️ STORY SPLIT NOTICE (2025-11-06):**

This story has been split into two focused stories for better implementation:

- **[Story 6.1A: SOS Breakout Detection - Core Logic](6.1A.sos-breakout-detection-core.md)** ← **IMPLEMENT THIS FIRST**
  - Scope: Ice breakout (1%+) + Volume validation (1.5x+) + Phase D check
  - Focus: Get SOS detection working with PRIMARY quality gate (volume)
  - Status: **Draft** (Ready for implementation)

- **[Story 6.1B: SOS Breakout Detection - Quality Enhancements](6.1B.sos-breakout-quality-enhancements.md)** ← Implement after 6.1A
  - Scope: Spread expansion (1.2x+), three-tier close position, late Phase C support
  - Focus: Add nuanced quality assessments for confidence scoring (Story 6.5)
  - Status: **Backlog** (Depends on 6.1A)

**Reason for Split:** Original Story 6.1 was too large (20 tasks, ~1,150 lines). Splitting allows:
1. Faster validation of core detection logic (6.1A)
2. Clearer dev handoff with focused scope
3. Stories 6.2-6.4 can depend on 6.1A core detection
4. Quality enhancements (6.1B) can be refined based on 6.1A learnings

---

## Status
Done
**SUPERSEDED** - See Story 6.1A and 6.1B above

## Story

**As a** SOS detector,
**I want** to identify SOS breakout patterns (decisive break above Ice with high volume),
**so that** Phase D markup entries can be signaled.

## Acceptance Criteria

1. Function: `detect_sos_breakout(range, bars, volume_analysis, phase) -> Optional[SOSBreakout]`
2. SOS requirements (FR6): close above Ice (1%+ penetration), volume expansion (1.5x+), wide spread (1.2x+), strong close (upper 30%)
3. Breakout validation: close_price > ice_level * 1.01 (minimum 1% above)
4. Volume validation (FR12): if volume_ratio < 1.5x, REJECT (insufficient confirmation)
5. Spread expansion: spread_ratio >= 1.2x (wide bar shows conviction)
6. **Close position three-tier handling**: (close - low) / (high - low): **>= 0.7 PASS** (strong close - buyers in control), **0.5-0.69 MARGINAL** (confidence penalty in Story 6.5), **< 0.5 REJECT** (weak close - sellers dominating)
7. SOSBreakout dataclass: bar, breakout_pct, volume_ratio, spread_ratio, close_position
8. Phase validation (FR15): primarily Phase D, late Phase C acceptable if very strong (confidence 85+)
9. Unit test: synthetic breakout with 2.0x volume and strong close detected
10. **Unit test: close position tiers**: >= 0.7 PASS, 0.5-0.69 MARGINAL (SOS detected with penalty), < 0.5 REJECT (no SOS detection)

## Tasks / Subtasks

- [ ] **Task 1: Create SOSBreakout data model** (AC: 1, 7)
  - [ ] Create file: `backend/src/models/sos_breakout.py`
  - [ ] Import required types: `Decimal`, `datetime`, `UUID`, `Optional`
  - [ ] Import from Epic 3: `TradingRange` from `backend/src/models/trading_range.py`
  - [ ] Import from Epic 1: `OHLCVBar` from `backend/src/models/ohlcv.py`
  - [ ] Create Pydantic model: `class SOSBreakout(BaseModel):`
  - [ ] **Required attributes:**
    - `id: UUID = Field(default_factory=uuid4)` - Unique identifier
    - `bar: OHLCVBar` - The breakout bar
    - `breakout_pct: Decimal = Field(ge=0.01, decimal_places=4)` - % above Ice (minimum 1% per AC 3)
    - `volume_ratio: Decimal = Field(ge=1.5, decimal_places=4)` - Must be >=1.5x (AC 4, FR12)
    - `spread_ratio: Decimal = Field(ge=1.2, decimal_places=4)` - Must be >=1.2x (AC 5)
    - `close_position: Decimal = Field(ge=0.0, le=1.0, decimal_places=4)` - Where close sits in bar range (AC 6)
    - `ice_reference: Decimal = Field(decimal_places=8, max_digits=18)` - Ice level at detection time
    - `breakout_price: Decimal = Field(decimal_places=8, max_digits=18)` - Close price of breakout bar
    - `spread: Decimal = Field(decimal_places=8, max_digits=18)` - high - low of breakout bar
    - `detection_timestamp: datetime` - When SOS was detected (UTC)
    - `trading_range_id: UUID` - Associated trading range
  - [ ] Add Pydantic validators:
    - `@validator('detection_timestamp')`: Ensure UTC timezone
    - `@validator('breakout_pct')`: Ensure >= 0.01 (1% minimum per AC 3)
    - `@validator('volume_ratio')`: Ensure >= 1.5 (AC 4, FR12 enforcement)
    - `@validator('spread_ratio')`: Ensure >= 1.2 (AC 5)
    - `@validator('close_position')`: Ensure 0.0 <= close_position <= 1.0
  - [ ] Add docstring explaining SOS (Sign of Strength) breakout requirements per AC 2
  - [ ] Configure JSON serialization for Decimal and datetime types

- [ ] **Task 2: Implement detect_sos_breakout function signature** (AC: 1)
  - [ ] Create file: `backend/src/pattern_engine/detectors/sos_detector.py`
  - [ ] Import dependencies:
    - `from typing import Optional, List, Dict`
    - `from decimal import Decimal`
    - `from backend.src.models.sos_breakout import SOSBreakout`
    - `from backend.src.models/trading_range import TradingRange`
    - `from backend.src.models.ohlcv import OHLCVBar`
    - `from backend.src.models.phase_classification import WyckoffPhase, PhaseClassification` (Story 4.4)
    - `import structlog`
  - [ ] Create function: `def detect_sos_breakout(range: TradingRange, bars: List[OHLCVBar], volume_analysis: Dict, phase: PhaseClassification) -> Optional[SOSBreakout]:`
  - [ ] Add comprehensive docstring:
    - Purpose: Detect SOS (Sign of Strength) breakout patterns
    - Parameters:
      - `range`: Active trading range with Ice level
      - `bars`: OHLCV bars (minimum 25 bars for volume/spread averages)
      - `volume_analysis`: Pre-calculated volume_ratio and spread_ratio from VolumeAnalyzer (Story 2.5)
      - `phase`: Current Wyckoff phase classification (should be Phase D per FR15)
    - Returns: `Optional[SOSBreakout]` - SOS if detected, None if not found or rejected
    - FR Requirements: FR6 (SOS detection), FR12 (volume validation), FR15 (Phase D)
  - [ ] Return type: `Optional[SOSBreakout]`

- [ ] **Task 3: Implement Phase D/C validation (FR15)** (AC: 8)
  - [ ] Add phase check at function start:
    ```python
    current_phase = phase.phase
    phase_confidence = phase.confidence

    # FR15: SOS primarily in Phase D, late Phase C acceptable if very strong
    if current_phase == WyckoffPhase.D:
        # Ideal phase for SOS - markup phase
        logger.debug(
            "sos_phase_validation",
            current_phase="D",
            phase_confidence=phase_confidence,
            message="SOS in Phase D (ideal - markup phase)"
        )
    elif current_phase == WyckoffPhase.C and phase_confidence >= 85:
        # Late Phase C acceptable if high confidence
        logger.debug(
            "sos_phase_validation",
            current_phase="C",
            phase_confidence=phase_confidence,
            message="SOS in late Phase C acceptable (high confidence >= 85)"
        )
    else:
        logger.debug(
            "sos_wrong_phase",
            current_phase=current_phase.value,
            phase_confidence=phase_confidence,
            required_phase="D or late C (85+ confidence)",
            message="SOS requires Phase D or late Phase C with high confidence (FR15)"
        )
        return None
    ```
  - [ ] Log rejection reason if phase not valid
  - [ ] Return None immediately if phase criteria not met

- [ ] **Task 4: Implement Ice level breakout detection** (AC: 2, 3)
  - [ ] Extract Ice level from trading range:
    ```python
    ice_level = range.ice_level.price  # Decimal from Story 3.5
    ```
  - [ ] Scan last 20 bars for breakout above Ice:
    ```python
    for bar in bars[-20:]:
        close_price = bar.close

        # AC 3: Close must be above Ice + 1% minimum
        # Breakout validation: close_price > ice_level * 1.01
        if close_price <= ice_level * Decimal("1.01"):
            continue  # Not a valid breakout

        # Calculate breakout percentage
        breakout_pct = (close_price - ice_level) / ice_level

        # Potential SOS candidate found
        logger.debug(
            "sos_candidate_found",
            symbol=bar.symbol,
            close_price=float(close_price),
            ice_level=float(ice_level),
            breakout_pct=float(breakout_pct),
            message=f"Potential SOS: close {breakout_pct:.2%} above Ice"
        )
    ```
  - [ ] Store breakout candidate details: `breakout_bar`, `breakout_price`, `breakout_pct`

- [ ] **Task 5: Implement CRITICAL volume expansion validation (FR12)** (AC: 4)
  - [ ] **FIRST validation checkpoint - check volume BEFORE other validations**
  - [ ] Extract volume ratio from volume_analysis:
    ```python
    volume_ratio = volume_analysis.get(bar.timestamp, {}).get("volume_ratio")

    if volume_ratio is None:
        logger.error(
            "volume_analysis_missing",
            bar_timestamp=bar.timestamp.isoformat(),
            message="Volume analysis not available for breakout bar"
        )
        continue  # Skip candidate
    ```
  - [ ] **FR12 enforcement - NON-NEGOTIABLE volume expansion requirement (AC 4):**
    ```python
    # AC 4: Volume ratio must be >= 1.5x
    # FR12: Volume expansion confirms breakout legitimacy
    # Low-volume breakouts are false breakouts (absorption at resistance)

    if volume_ratio < Decimal("1.5"):
        logger.warning(
            "sos_invalid_low_volume",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            volume_ratio=float(volume_ratio),
            threshold=1.5,
            message="SOS INVALID: Volume {:.2f}x < 1.5x - insufficient confirmation (FR12 - LOW VOLUME = FALSE BREAKOUT)".format(volume_ratio)
        )
        continue  # REJECT immediately - no further processing
    ```
  - [ ] Log rejection with specific FR12 reference
  - [ ] **NO confidence degradation** - this is binary pass/fail like Spring volume validation
  - [ ] Document ideal volume ranges in logs:
    - `1.5x - 2.0x`: Acceptable expansion
    - `2.0x - 2.5x`: Strong expansion (ideal)
    - `2.5x+`: Extremely strong (climactic volume)

- [ ] **Task 6: Implement spread expansion validation** (AC: 5)
  - [ ] Extract spread ratio from bar or volume_analysis:
    ```python
    # Use bar.spread_ratio if available (from OHLCVBar model, Epic 2)
    spread_ratio = bar.spread_ratio  # Ratio to 20-bar average spread

    # Calculate spread for reference
    spread = bar.high - bar.low
    ```
  - [ ] Validate spread expansion (AC 5):
    ```python
    # AC 5: Spread ratio must be >= 1.2x
    # Wide spread shows price expansion and conviction
    # Narrow spread on breakout = absorption at resistance (not true breakout)

    if spread_ratio < Decimal("1.2"):
        logger.warning(
            "sos_narrow_spread",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            spread_ratio=float(spread_ratio),
            threshold=1.2,
            message="SOS suspect: Spread {:.2f}x < 1.2x - narrow spread may indicate absorption".format(spread_ratio)
        )
        continue  # Skip this candidate
    ```
  - [ ] Log spread validation details

- [ ] **Task 7: Implement three-tier close position validation** (AC: 6, 10) **[UPDATED - Team Review]**
  - [ ] Calculate close position in bar range:
    ```python
    # AC 6: Close position = (close - low) / (high - low)
    # THREE-TIER HANDLING (Wyckoff Team Review 2025-11-06):
    # >= 0.7: PASS (strong close - buyers in control)
    # 0.5-0.69: MARGINAL (confidence penalty in Story 6.5)
    # < 0.5: REJECT (weak close - sellers dominating)

    high = bar.high
    low = bar.low
    close = bar.close

    # Calculate where close sits in bar range (0.0 = at low, 1.0 = at high)
    bar_range = high - low

    if bar_range == 0:
        # Edge case: bar with no range (high == low)
        logger.warning(
            "sos_zero_range_bar",
            bar_timestamp=bar.timestamp.isoformat(),
            message="Bar has no range (high == low) - cannot calculate close position"
        )
        continue

    close_position = (close - low) / bar_range
    ```
  - [ ] **Validate close position with three-tier approach (AC 6):**
    ```python
    # THREE-TIER CLOSE POSITION HANDLING:

    if close_position < Decimal("0.5"):
        # TIER 3: REJECT - Weak close, sellers dominating
        logger.warning(
            "sos_rejected_weak_close",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            close_position=float(close_position),
            threshold=0.5,
            message="SOS REJECTED: Close position {:.1%} < 50% - sellers dominating, not strength".format(close_position)
        )
        continue  # REJECT immediately - no SOS detection

    elif close_position < Decimal("0.7"):
        # TIER 2: MARGINAL - Detect SOS but apply confidence penalty (Story 6.5)
        logger.info(
            "sos_marginal_close",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            close_position=float(close_position),
            message="SOS MARGINAL close: {:.1%} close position (50-70% range) - confidence penalty will apply in Story 6.5".format(close_position)
        )
        # Continue to detection - penalty handled in confidence scoring (Story 6.5)

    else:
        # TIER 1: PASS - Strong close, buyers in control
        logger.debug(
            "sos_strong_close",
            symbol=bar.symbol,
            bar_timestamp=bar.timestamp.isoformat(),
            close_position=float(close_position),
            message="SOS strong close: {:.1%} close position >= 70% - buyers in control".format(close_position)
        )
    ```
  - [ ] Log close position tier with detailed reasoning

- [ ] **Task 8: Create SOSBreakout instance upon successful detection** (AC: 7)
  - [ ] After all validations pass, create SOSBreakout object:
    ```python
    from datetime import timezone

    sos_breakout = SOSBreakout(
        bar=breakout_bar,
        breakout_pct=breakout_pct,
        volume_ratio=volume_ratio,
        spread_ratio=spread_ratio,
        close_position=close_position,
        ice_reference=ice_level,
        breakout_price=close_price,
        spread=spread,
        detection_timestamp=datetime.now(timezone.utc),
        trading_range_id=range.id
    )
    ```
  - [ ] Log successful SOS detection:
    ```python
    logger.info(
        "sos_breakout_detected",
        symbol=breakout_bar.symbol,
        breakout_timestamp=breakout_bar.timestamp.isoformat(),
        breakout_pct=float(breakout_pct),
        volume_ratio=float(volume_ratio),
        spread_ratio=float(spread_ratio),
        close_position=float(close_position),
        ice_level=float(ice_level),
        phase=current_phase.value
    )
    ```
  - [ ] Return SOSBreakout instance

- [ ] **Task 9: Handle no SOS detected case**
  - [ ] If loop completes without finding valid SOS:
    ```python
    logger.debug(
        "no_sos_detected",
        symbol=range.symbol,
        phase=current_phase.value,
        bars_analyzed=len(bars),
        message="No valid SOS breakout found in analyzed bars"
    )
    return None
    ```

- [ ] **Task 10: Write unit test for valid SOS detection** (AC: 9)
  - [ ] Create test file: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py`
  - [ ] Import pytest, SOSBreakout, detect_sos_breakout, WyckoffPhase
  - [ ] Create test fixture: `synthetic_trading_range` with Ice level at $100.00
  - [ ] Create test fixture: `synthetic_bars_with_sos_breakout`
    - 24 bars of normal trading within range ($95-$100)
    - Bar 25: SOS breakout bar with:
      - `low = $100.50`
      - `high = $103.00`
      - `close = $102.50` (in upper 30% of bar: (102.50-100.50)/(103-100.50) = 0.80)
      - `volume = 200,000` (volume_ratio = 2.0x per AC 9)
      - `spread = $2.50` (spread_ratio = 1.5x, wide spread)
  - [ ] Create volume_analysis dict:
    ```python
    volume_analysis = {
        bars[24].timestamp: {
            "volume_ratio": Decimal("2.0"),  # AC 9: 2.0x volume
            "spread_ratio": Decimal("1.5")    # Wide spread
        }
    }
    ```
  - [ ] Create phase classification: Phase D
  - [ ] **Test valid SOS detection (AC 9):**
    ```python
    def test_detect_sos_breakout_valid():
        # Arrange
        range = create_trading_range(ice_level=Decimal("100.00"))
        bars = create_synthetic_bars_with_sos()
        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),
                "spread_ratio": Decimal("1.5")
            }
        }
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert
        assert sos is not None, "SOS should be detected"
        assert sos.breakout_pct >= Decimal("0.01"), "Breakout >= 1% above Ice"
        assert sos.volume_ratio == Decimal("2.0"), "2.0x volume ratio"
        assert sos.spread_ratio == Decimal("1.5"), "1.5x spread ratio"
        assert sos.close_position >= Decimal("0.7"), "Strong close position"
        assert sos.ice_reference == Decimal("100.00")
        assert sos.breakout_price == Decimal("102.50")
    ```

- [ ] **Task 11: Write unit test for low-volume rejection** (AC: 4)
  - [ ] Create synthetic scenario with low volume (1.4x, below 1.5x threshold)
  - [ ] **Test volume rejection (AC 4, FR12):**
    ```python
    def test_detect_sos_low_volume_rejected():
        # Arrange: Same setup as valid SOS, but volume = 1.4x (below threshold)
        range = create_trading_range(ice_level=Decimal("100.00"))
        bars = create_synthetic_bars_with_sos()
        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("1.4"),  # LOW VOLUME (< 1.5x)
                "spread_ratio": Decimal("1.5")
            }
        }
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert
        assert sos is None, "Low-volume breakout should be REJECTED (FR12)"

        # Verify rejection logged (check logs or use caplog)
        # Expected log: "SOS INVALID: Volume 1.40x < 1.5x - insufficient confirmation"
    ```
  - [ ] Test boundary case: 1.49x rejects, 1.50x passes:
    ```python
    def test_volume_boundary():
        # 1.49x should reject
        volume_analysis_reject = {bars[24].timestamp: {"volume_ratio": Decimal("1.49"), "spread_ratio": Decimal("1.5")}}
        sos_reject = detect_sos_breakout(range, bars, volume_analysis_reject, phase)
        assert sos_reject is None, "1.49x volume should reject"

        # 1.50x should pass
        volume_analysis_pass = {bars[24].timestamp: {"volume_ratio": Decimal("1.50"), "spread_ratio": Decimal("1.5")}}
        sos_pass = detect_sos_breakout(range, bars, volume_analysis_pass, phase)
        assert sos_pass is not None, "1.50x volume should pass (FR12)"
    ```

- [ ] **Task 12: Write unit tests for three-tier close position handling** (AC: 10) **[UPDATED - Team Review]**
  - [ ] **Test TIER 1: Strong close (>= 0.7) - PASS:**
    ```python
    def test_detect_sos_strong_close_pass():
        # Arrange: SOS with strong close position (0.8 = upper 20% of bar)
        # low = $100.50, high = $103.50, close = $102.90
        # close_position = (102.90 - 100.50) / (103.50 - 100.50) = 0.80

        bars = create_bars_with_close_position(
            low=Decimal("100.50"),
            high=Decimal("103.50"),
            close=Decimal("102.90")  # Strong close (80%)
        )

        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),   # Good volume
                "spread_ratio": Decimal("1.5")    # Good spread
            }
        }

        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert (AC 10 - TIER 1)
        assert sos is not None, "Strong close (>=0.7) should PASS and detect SOS"
        assert sos.close_position == Decimal("0.80"), "Close position should be 0.80"
        # Verify logged as "SOS strong close" with no penalty
    ```

  - [ ] **Test TIER 2: Marginal close (0.5-0.69) - MARGINAL (detect with penalty):**
    ```python
    def test_detect_sos_marginal_close_penalty():
        # Arrange: SOS with marginal close position (0.6 = 60%)
        # low = $100.50, high = $103.50, close = $102.30
        # close_position = (102.30 - 100.50) / (103.50 - 100.50) = 0.60

        bars = create_bars_with_close_position(
            low=Decimal("100.50"),
            high=Decimal("103.50"),
            close=Decimal("102.30")  # Marginal close (60%)
        )

        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),   # Good volume
                "spread_ratio": Decimal("1.5")    # Good spread
            }
        }

        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert (AC 10 - TIER 2)
        assert sos is not None, "Marginal close (0.5-0.69) should DETECT SOS (with penalty in Story 6.5)"
        assert sos.close_position == Decimal("0.60"), "Close position should be 0.60"
        # Verify logged as "SOS MARGINAL close" - confidence penalty applies in Story 6.5
    ```

  - [ ] **Test TIER 2 boundary (0.69 and 0.70):**
    ```python
    def test_close_position_tier_boundaries():
        # Test 0.69 (MARGINAL - upper boundary)
        bars_marginal = create_bars_with_close_position(close=Decimal("102.57"))  # 0.69
        sos_marginal = detect_sos_breakout(range, bars_marginal, volume_analysis, phase)
        assert sos_marginal is not None, "0.69 should be MARGINAL (detected with penalty)"
        assert sos_marginal.close_position == Decimal("0.69")

        # Test 0.70 (PASS - lower boundary)
        bars_pass = create_bars_with_close_position(close=Decimal("102.60"))  # 0.70
        sos_pass = detect_sos_breakout(range, bars_pass, volume_analysis, phase)
        assert sos_pass is not None, "0.70 should be PASS (strong close)"
        assert sos_pass.close_position == Decimal("0.70")
    ```

  - [ ] **Test TIER 3: Weak close (< 0.5) - REJECT:**
    ```python
    def test_detect_sos_weak_close_rejected():
        # Arrange: SOS with weak close position (0.4 = 40%, sellers dominating)
        # low = $100.50, high = $103.50, close = $101.70
        # close_position = (101.70 - 100.50) / (103.50 - 100.50) = 0.40

        bars = create_bars_with_close_position(
            low=Decimal("100.50"),
            high=Decimal("103.50"),
            close=Decimal("101.70")  # Weak close (40%)
        )

        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),   # Good volume
                "spread_ratio": Decimal("1.5")    # Good spread
            }
        }

        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert (AC 10 - TIER 3)
        assert sos is None, "Weak close (<0.5) should REJECT - sellers dominating, not strength"
        # Verify logged as "SOS REJECTED: Close position < 50% - sellers dominating"
    ```

  - [ ] **Test TIER 3 boundary (0.49 and 0.50):**
    ```python
    def test_weak_close_boundary():
        # Test 0.49 (REJECT - below threshold)
        bars_reject = create_bars_with_close_position(close=Decimal("101.97"))  # 0.49
        sos_reject = detect_sos_breakout(range, bars_reject, volume_analysis, phase)
        assert sos_reject is None, "0.49 should REJECT (sellers dominating)"

        # Test 0.50 (MARGINAL - at threshold, detects with penalty)
        bars_marginal = create_bars_with_close_position(close=Decimal("102.00"))  # 0.50
        sos_marginal = detect_sos_breakout(range, bars_marginal, volume_analysis, phase)
        assert sos_marginal is not None, "0.50 should be MARGINAL (detected with penalty)"
        assert sos_marginal.close_position == Decimal("0.50")
    ```

- [ ] **Task 13: Write unit test for breakout percentage validation** (AC: 3)
  - [ ] Test exact 1% breakout (minimum acceptable):
    ```python
    def test_breakout_1_percent_accepted():
        # Ice = $100, close = $101 → 1% breakout (minimum allowed)
        bars = create_bars_with_breakout(ice=100, close=101)
        volume_analysis = {bars[24].timestamp: {"volume_ratio": Decimal("2.0"), "spread_ratio": Decimal("1.5")}}
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is not None, "1% breakout should be accepted (AC 3)"
        assert sos.breakout_pct == Decimal("0.01")
    ```
  - [ ] Test <1% breakout (rejected):
    ```python
    def test_breakout_below_1_percent_rejected():
        # Ice = $100, close = $100.50 → 0.5% breakout (too small)
        bars = create_bars_with_breakout(ice=100, close=100.50)
        volume_analysis = {bars[24].timestamp: {"volume_ratio": Decimal("2.0"), "spread_ratio": Decimal("1.5")}}
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is None, "< 1% breakout should be rejected (AC 3)"
    ```

- [ ] **Task 14: Write unit test for spread expansion validation** (AC: 5)
  - [ ] Test narrow spread (0.9x, below 1.2x threshold):
    ```python
    def test_narrow_spread_rejected():
        # Arrange: SOS with narrow spread (absorption at resistance)
        bars = create_synthetic_bars_with_sos()
        volume_analysis = {
            bars[24].timestamp: {
                "volume_ratio": Decimal("2.0"),   # Good volume
                "spread_ratio": Decimal("0.9")    # NARROW spread (< 1.2x)
            }
        }
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)

        # Act
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)

        # Assert
        assert sos is None, "Narrow spread breakout should be rejected (AC 5)"
        # Verify warning logged about narrow spread
    ```
  - [ ] Test boundary: 1.19x rejects, 1.20x passes

- [ ] **Task 15: Write unit test for Phase D/C validation** (AC: 8, FR15)
  - [ ] Test SOS in Phase D (valid):
    ```python
    def test_sos_in_phase_d_accepted():
        phase = create_phase_classification(phase=WyckoffPhase.D, confidence=85)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is not None, "SOS valid in Phase D (FR15)"
    ```
  - [ ] Test SOS in late Phase C with high confidence (valid):
    ```python
    def test_sos_in_late_phase_c_high_confidence_accepted():
        # AC 8: Late Phase C acceptable if confidence >= 85
        phase = create_phase_classification(phase=WyckoffPhase.C, confidence=85)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is not None, "SOS valid in late Phase C with 85+ confidence (AC 8)"
    ```
  - [ ] Test SOS in Phase C with low confidence (rejected):
    ```python
    def test_sos_in_phase_c_low_confidence_rejected():
        # Phase C with confidence < 85 should reject
        phase = create_phase_classification(phase=WyckoffPhase.C, confidence=70)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is None, "SOS in Phase C with <85 confidence should reject (AC 8)"
    ```
  - [ ] Test SOS in other phases (rejected):
    ```python
    @pytest.mark.parametrize("phase_value", [
        WyckoffPhase.A,
        WyckoffPhase.B,
        WyckoffPhase.E
    ])
    def test_sos_wrong_phase_rejected(phase_value):
        phase = create_phase_classification(phase=phase_value, confidence=85)
        sos = detect_sos_breakout(range, bars, volume_analysis, phase)
        assert sos is None, f"SOS should be rejected in Phase {phase_value.value} (FR15)"
    ```

- [ ] **Task 16: Write integration test with realistic OHLCV data**
  - [ ] Create test: `backend/tests/integration/pattern_engine/detectors/test_sos_detector_integration.py`
  - [ ] Load or create realistic bar sequence (100+ bars) with known SOS breakout
  - [ ] Include range formation, consolidation, then decisive breakout
  - [ ] Verify SOS detection with actual volume analysis from VolumeAnalyzer (Story 2.5)
  - [ ] Assert SOS detected with correct attributes
  - [ ] Performance check: detection completes in <50ms for 100-bar sequence

- [ ] **Task 17: Add comprehensive docstrings and examples**
  - [ ] Add module-level docstring to `sos_detector.py`
  - [ ] Explain SOS (Sign of Strength) in Wyckoff methodology
  - [ ] Document FR6, FR12, FR15 requirements
  - [ ] Provide usage example code
  - [ ] Document integration with Epic 3 (Ice level) and Story 2.5 (Volume analysis)

- [ ] **Task 18: Implement edge case handling**
  - [ ] Handle insufficient bars (<25 bars):
    ```python
    if len(bars) < 25:
        logger.warning(
            "insufficient_bars_for_sos_detection",
            bars_available=len(bars),
            bars_required=25,
            message="Need at least 25 bars for volume/spread average calculation"
        )
        return None
    ```
  - [ ] Handle missing trading range:
    ```python
    if range is None:
        logger.error("trading_range_missing")
        raise ValueError("Trading range required for SOS detection")
    ```
  - [ ] Handle Ice level = None or 0:
    ```python
    if range.ice_level is None or range.ice_level.price <= 0:
        logger.error("invalid_ice_level", ice=range.ice_level)
        raise ValueError("Valid Ice level required for SOS breakout detection")
    ```

- [ ] **Task 19: Add type hints and mypy validation**
  - [ ] Add comprehensive type hints to all functions
  - [ ] Use strict typing: `from __future__ import annotations`
  - [ ] Run mypy in strict mode: `mypy --strict sos_detector.py`
  - [ ] Fix any type errors
  - [ ] Ensure Optional, List, Dict types are properly annotated

- [ ] **Task 20: Add comprehensive logging**
  - [ ] Log SOS detection start with range and phase context
  - [ ] Log each candidate found with breakout percentage
  - [ ] Log all rejections with specific reasons (volume, spread, close, phase)
  - [ ] Log final SOS detection with all metrics
  - [ ] Use structlog with structured fields
  - [ ] Follow [architecture/17-monitoring-and-observability.md](../../../docs/architecture/17-monitoring-and-observability.md)

## Dev Notes

### Previous Story Context

**Epic 5 Completion (Spring Pattern Detection):**
[Source: Epic 5 stories]
- Spring detector provides opposite pattern (penetration below Creek vs SOS break above Ice)
- Spring: low volume (<0.7x), SOS: high volume (>=1.5x) - opposite requirements
- Spring: Phase C, SOS: Phase D - different phases in Wyckoff cycle
- Similar validation approach: volume is non-negotiable (FR12 for both)
- **Story 6.1 integration:** SOS is the markup entry pattern after Spring accumulation entry

**Story 3.5 (Ice Level Calculation):**
[Source: docs/prd/epic-3-trading-range-level-detection.md]
- Ice level is volume-weighted resistance from pivot highs
- Minimum Ice strength: 60 (from Epic 3.5 AC 5)
- Ice level stored in TradingRange model
- **Story 6.1 integration:** SOS detects breakout above Ice level
- `ice_level = range.ice_level.price` (Decimal)

**Story 2.5 (VolumeAnalyzer Integration):**
[Source: Epic 2]
- VolumeAnalyzer calculates volume_ratio for each bar
- Formula: `volume_ratio = volume / 20-bar average volume`
- Also calculates spread_ratio: `spread_ratio = spread / 20-bar average spread`
- **Story 6.1 integration:**
  - Volume validation (FR12) uses pre-calculated volume_ratio
  - Spread validation uses spread_ratio
  - `volume_ratio >= 1.5x` required (opposite of Spring <0.7x)

**Story 4.4 (Phase Classification Logic):**
[Source: Epic 4]
- PhaseDetector provides PhaseClassification with phase and confidence
- WyckoffPhase enum: A, B, C, D, E
- **Story 6.1 integration:**
  - SOS primarily in Phase D (markup phase)
  - Late Phase C acceptable if confidence >= 85
  - `phase.phase == WyckoffPhase.D` or `(phase.phase == WyckoffPhase.C and phase.confidence >= 85)`

**Key Learnings:**
- SOS is inverse of Spring: high volume vs low volume, break up vs down
- Volume expansion (1.5x+) is CRITICAL for confirming legitimate breakout (FR12)
- Spread expansion (1.2x+) shows price conviction
- Close position (>= 0.7) shows buyers in control
- Phase D is primary SOS phase (markup), late Phase C acceptable if very strong

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models: SOSBreakout, validation)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- New Model: `backend/src/models/sos_breakout.py` (create new)
- New Detector: `backend/src/pattern_engine/detectors/sos_detector.py` (create new)
- Unit Tests: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py` (create new)
- Integration Tests: `backend/tests/integration/pattern_engine/detectors/test_sos_detector_integration.py` (create new)

**Dependencies:**
- `backend/src/models/trading_range.py`: TradingRange with ice_level (Epic 3)
- `backend/src/models/ohlcv.py`: OHLCVBar (Epic 1)
- `backend/src/models/phase_classification.py`: WyckoffPhase, PhaseClassification (Story 4.4)
- `backend/src/pattern_engine/volume_analyzer.py`: VolumeAnalyzer (Story 2.5)
- Pydantic BaseModel, Field, validator
- structlog for logging
- Decimal for precise financial calculations

### Data Models

**SOSBreakout Model (NEW):**

```python
from decimal import Decimal
from datetime import datetime, timezone
from pydantic import BaseModel, Field, validator
from backend.src.models.ohlcv import OHLCVBar

class SOSBreakout(BaseModel):
    """
    SOS (Sign of Strength) Breakout pattern (FR6 requirement).

    Wyckoff interpretation:
    - SOS is decisive break above resistance (Ice level)
    - High volume confirms breakout legitimacy (not absorption)
    - Wide spread shows price expansion and conviction
    - Strong close (upper 30%) shows buyers in control
    - FR12: Volume expansion (1.5x+) is NON-NEGOTIABLE
    - FR15: Occurs in Phase D (markup) or late Phase C (85+ confidence)

    SOS marks transition from accumulation to markup phase.
    """
    bar: OHLCVBar = Field(..., description="The breakout bar")
    breakout_pct: Decimal = Field(..., ge=0.01, decimal_places=4, description="% above Ice (min 1%)")
    volume_ratio: Decimal = Field(..., ge=1.5, decimal_places=4, description="Volume vs 20-bar avg (min 1.5x)")
    spread_ratio: Decimal = Field(..., ge=1.2, decimal_places=4, description="Spread vs 20-bar avg (min 1.2x)")
    close_position: Decimal = Field(..., ge=0.0, le=1.0, decimal_places=4, description="Where close sits in bar (0.0-1.0)")
    ice_reference: Decimal = Field(..., decimal_places=8, max_digits=18, description="Ice level at detection")
    breakout_price: Decimal = Field(..., decimal_places=8, max_digits=18, description="Close price of breakout bar")
    spread: Decimal = Field(..., decimal_places=8, max_digits=18, description="high - low")
    detection_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    trading_range_id: UUID = Field(..., description="Associated trading range")

    @validator('volume_ratio')
    def validate_volume_expansion(cls, v):
        """
        CRITICAL: Volume expansion required (FR12).
        Volume >= 1.5x confirms breakout is legitimate, not absorption.
        """
        if v < Decimal("1.5"):
            raise ValueError("SOS volume ratio must be >= 1.5x (FR12)")
        return v

    @validator('spread_ratio')
    def validate_spread_expansion(cls, v):
        """
        Spread expansion >= 1.2x shows price conviction.
        Narrow spread on breakout suggests absorption at resistance.
        """
        if v < Decimal("1.2"):
            raise ValueError("SOS spread ratio must be >= 1.2x")
        return v

    @validator('detection_timestamp', pre=True, always=True)
    def ensure_utc(cls, v):
        """Enforce UTC timezone"""
        if v.tzinfo is None:
            return v.replace(tzinfo=timezone.utc)
        return v.astimezone(timezone.utc)

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }

    def get_quality_assessment(self) -> str:
        """
        Get qualitative assessment of SOS quality.

        Returns:
            str: "EXCELLENT", "STRONG", "ACCEPTABLE"
        """
        # Excellent: high volume (2.5x+), wide spread (1.5x+), strong close (0.8+)
        if self.volume_ratio >= Decimal("2.5") and self.spread_ratio >= Decimal("1.5") and self.close_position >= Decimal("0.8"):
            return "EXCELLENT"
        # Strong: good volume (2.0x+), good spread (1.3x+), good close (0.75+)
        elif self.volume_ratio >= Decimal("2.0") and self.spread_ratio >= Decimal("1.3") and self.close_position >= Decimal("0.75"):
            return "STRONG"
        # Acceptable: meets minimum thresholds
        else:
            return "ACCEPTABLE"
```

### Algorithm Details

**SOS Breakout Detection Algorithm:**

```
Purpose: Identify SOS (Sign of Strength) breakout patterns - decisive breaks above Ice with high volume

Input:
- range: TradingRange (context with Ice level)
- bars: List[OHLCVBar] (price data)
- volume_analysis: Dict (volume_ratio and spread_ratio from VolumeAnalyzer)
- phase: PhaseClassification (current phase from PhaseDetector)

Algorithm:

Step 1: Phase Validation (FR15)
- If phase == Phase D: proceed (ideal - markup phase)
- If phase == Phase C AND confidence >= 85: proceed (late Phase C acceptable)
- Else: return None (wrong phase for SOS)

Step 2: Extract Ice Level from Range
- ice_level = range.ice_level.price  # Decimal from Epic 3
- Validate ice_level is valid (not None, > 0)

Step 3: Scan Last 20 Bars for Breakout Above Ice
- For each bar in bars[-20:]:
  - If bar.close <= ice_level * 1.01: skip (not a 1%+ breakout)
  - Calculate breakout_pct = (bar.close - ice_level) / ice_level
  - Found potential SOS candidate

Step 4: CRITICAL - Volume Expansion Validation (FR12)
- Extract volume_ratio from volume_analysis[bar.timestamp]
- If volume_ratio < 1.5:
  - Log: "SOS INVALID: Volume {ratio}x < 1.5x - insufficient confirmation (FR12)"
  - Skip candidate (REJECT immediately - NON-NEGOTIABLE)
- Ideal volume: 2.0x+ (strong), 2.5x+ (very strong)

Step 5: Spread Expansion Validation
- Extract spread_ratio from volume_analysis or bar.spread_ratio
- If spread_ratio < 1.2:
  - Log: "SOS suspect: Spread {ratio}x < 1.2x - narrow spread may indicate absorption"
  - Skip candidate (narrow spread = absorption at resistance, not breakout)

Step 6: Close Position Validation
- Calculate: close_position = (close - low) / (high - low)
- If close_position < 0.7:
  - Log: "SOS weak close: {position:.1%} < 70% - sellers present"
  - Reduces confidence (Story 6.5), but may not reject entirely

Step 7: Create SOSBreakout Instance
- Assemble SOSBreakout with all fields
- Set detection_timestamp = now (UTC)
- Return SOSBreakout

Output:
- SOSBreakout if valid breakout found
- None if no breakout OR breakout rejected by validations
```

**SOS vs Spring Comparison:**

| Characteristic | Spring (Phase C) | SOS (Phase D) |
|----------------|------------------|---------------|
| Direction | Penetration below Creek | Break above Ice |
| Volume | Low (<0.7x) | High (>=1.5x) |
| Purpose | Final shakeout before markup | Entry into markup |
| Phase | Phase C (test) | Phase D (markup) |
| Spread | Narrow preferred | Wide required (>=1.2x) |
| Entry Signal | After test confirmation | Immediate or wait for LPS |
| Stop | 2% below spring low | 5% below Ice (or 3% for LPS) |

### Wyckoff Context

**SOS (Sign of Strength) in Wyckoff Methodology:**

**Definition:**
> "SOS is a decisive upward movement through resistance (Ice level) on expanding volume. It marks the beginning of markup (Phase D) after accumulation is complete. The high volume confirms demand overwhelming supply - the breakout is legitimate, not absorption."

**Purpose of SOS:**
- **Confirm accumulation complete** - Composite Man has finished buying
- **Signal markup beginning** - Price ready to advance
- **Provide markup entry** - Traders can enter on breakout or pullback (LPS)
- **Validate range breakout** - Volume confirms breakout legitimacy

**Why High Volume is CRITICAL (FR12):**
> "High volume on SOS (1.5x+) proves DEMAND overwhelming SUPPLY. Low-volume breakouts are false - they represent absorption by Composite Man at resistance. The volume expansion is NON-NEGOTIABLE for confirming SOS legitimacy."

**Volume Interpretation:**
- **1.5x - 2.0x**: Acceptable expansion - breakout confirmed
- **2.0x - 2.5x**: Strong expansion - ideal SOS
- **2.5x+**: Very strong/climactic - extremely bullish
- **<1.5x**: **REJECTED** - false breakout, absorption at resistance (FR12)

**Volume Quality Tiers** (Wyckoff Team Review 2025-11-06):
> Document for Story 6.5 confidence scoring - Volume quality has gradations beyond binary pass/fail

**Tier Structure:**
- **1.5-2.0x**: ACCEPTABLE - Meets FR12 minimum, shows demand overwhelming supply
  - Confidence impact: Neutral (no penalty or bonus)
  - Interpretation: Valid breakout, adequate demand confirmation

- **2.0-2.5x**: IDEAL - Strong volume expansion, professional money participating
  - Confidence impact: Small bonus (+5-10 points in Story 6.5)
  - Interpretation: High-quality SOS, strong demand conviction

- **2.5x+**: CLIMACTIC - Exceptional volume, likely exhaustion gap or major institutional buying
  - Confidence impact: Medium bonus (+10-15 points in Story 6.5)
  - Interpretation: Very strong SOS, potential climactic buying (watch for follow-through)

**Reference**: These tiers inform Story 6.5 confidence scoring algorithm. Breaking strong Ice (85+ strength) with 2.0x+ volume = higher confidence bonus.

**Ice Strength Consideration** (Future - Story 6.5):
> Note for Story 6.5 SOS confidence scoring implementation

Breaking through **strong Ice** (strength 85+) with high volume is more significant than breaking weak Ice (60-70 strength):
- **Strong Ice (85+) + 2.0x+ volume**: Higher confidence bonus (+10-15 points)
  - Interpretation: Overcoming significant resistance shows very strong demand
  - Example: Well-tested resistance level with multiple touches, finally broken decisively

- **Weak Ice (60-75) + 2.0x+ volume**: Standard confidence (no bonus)
  - Interpretation: Less resistance to overcome, breakout less significant
  - Example: Lightly-tested resistance, easier to break

**Implementation Note**: Ice strength is available from `range.ice_level.strength` (Story 3.5). Story 6.5 will incorporate this into confidence algorithm. Not needed for Story 6.1 detection logic (binary pass/fail).

**Why Wide Spread Matters:**
> "Wide spread (1.2x+) on SOS shows PRICE EXPANSION. Buyers are aggressive, willing to pay higher prices. Narrow spread suggests sellers absorbing demand at resistance - not a true breakout."

**Spread Ranges:**
- **1.5x+**: Very wide - strong conviction
- **1.2x - 1.5x**: Wide - adequate expansion
- **<1.2x**: Narrow - suspect breakout (absorption likely)

**Why Strong Close Matters:**
> "Strong close (upper 30% of bar, position >= 0.7) shows BUYERS IN CONTROL. Weak close suggests sellers still present, fighting the breakout. Strong close confirms demand dominance."

**Close Position:**
- **0.8 - 1.0**: Very strong - closes near high (buyers dominant)
- **0.7 - 0.8**: Strong - closes in upper 30% (buyers in control)
- **<0.7**: Weak - sellers present, reduces confidence

**Phase D Requirement (FR15):**
> "SOS occurs in **Phase D (Markup)** after accumulation complete. Late Phase C is acceptable if phase confidence is very high (85+), indicating imminent transition to markup."

**Phase Context:**
- **Phase C**: Final test (Spring) - too early for SOS
- **Phase D**: **SOS occurs here** - markup begins
- Late **Phase C** (85+ confidence): Acceptable - transition imminent
- **Phase E**: Markup continuation - SOS already passed

**Breakout Size:**
> "SOS must close at least 1% above Ice (resistance). Smaller breaks (<1%) often fail. Larger breaks (3%+) show strong commitment."

**Breakout Size Ranges** (Enhanced - Wyckoff Team Review 2025-11-06):

**1-2% Penetration: MINIMUM** - Acceptable but watch for failure
- Confidence impact: Neutral (meets AC 3 minimum)
- Interpretation: Tentative breakout, requires strong volume/spread confirmation
- Risk: Higher failure rate, watch for pullback below Ice (becomes resistance)
- Example: Ice at $100 → Close at $101-102 (1-2% above)

**2-3% Penetration: NORMAL** - Good breakout size, typical SOS
- Confidence impact: Small bonus (+5 points in Story 6.5)
- Interpretation: Solid breakout, shows commitment beyond minimum
- Risk: Moderate - still needs volume/close confirmation
- Example: Ice at $100 → Close at $102-103 (2-3% above)

**3%+ Penetration: STRONG** - Excellent breakout, decisive move
- Confidence impact: Medium bonus (+10 points in Story 6.5)
- Interpretation: Very strong breakout, major supply/demand imbalance
- Risk: Lower failure rate, shows powerful demand
- Example: Ice at $100 → Close at $103+ (3%+ above)
- Note: Gap breakouts (4%+) may indicate climactic action

**Reference**: Breakout size gradations inform Story 6.5 confidence scoring. Combine with volume quality tiers for complete quality assessment.

**SOS vs False Breakout:**

| Characteristic | SOS (Valid) | False Breakout (Invalid) |
|----------------|-------------|--------------------------|
| Volume | **>=1.5x expansion** | <1.5x (absorption) |
| Spread | >=1.2x (wide) | <1.2x (narrow) |
| Close | >=0.7 (strong) | <0.7 (weak) |
| Phase | Phase D (or late C 85+) | Wrong phase |
| Breakout | >=1% above Ice | <1% above Ice |
| Interpretation | Markup beginning | Absorption at resistance |

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- Classes: PascalCase (`SOSBreakout`, `SOSDetector`)
- Functions: snake_case (`detect_sos_breakout`, `validate_volume`)
- Variables: snake_case (`breakout_pct`, `volume_ratio`, `close_position`)
- Constants: UPPER_SNAKE_CASE (`MIN_VOLUME_RATIO`, `MIN_SPREAD_RATIO`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- ✅ Use Decimal for financial calculations: `breakout_pct: Decimal`
- ✅ Use type hints: `def detect_sos_breakout(...) -> Optional[SOSBreakout]:`
- ✅ Use Pydantic models for validation (SOSBreakout model)
- ❌ DON'T use float for prices or percentages

**Decimal Precision:**
[Source: [architecture/4-data-models.md](../../../docs/architecture/4-data-models.md)]
- Prices: `NUMERIC(18,8)` → `Decimal` with 8 decimal places
- Ratios: `NUMERIC(10,4)` → `Decimal` with 4 decimal places
- Always use `Decimal("1.5")` not `1.5` (float) for comparisons

### Performance Requirements

- Single SOS detection: <10ms (simple loop + validations)
- Batch processing (100 bars): <50ms
- O(n) where n = number of bars (typically 20)
- No complex algorithms, linear scan with early exit

### Integration Notes

**Epic 6 Workflow:**

```
Story 6.1: Detect SOS Breakout → Optional[SOSBreakout] ← THIS STORY
    ↓
Story 6.2: Validate SOS Volume/Spread → Binary pass/fail (integrated in 6.1)
    ↓
Story 6.3: Detect LPS (pullback to old resistance) → Optional[LPS]
    ↓
Story 6.4: SOS vs LPS Entry Preference → Determine best entry
    ↓
Story 6.5: Calculate SOS Confidence → int (0-100)
    ↓
Story 6.6: Generate SOS/LPS Signal → SOSSignal (entry/stop/target)
    ↓
Story 6.7: SOSDetector & LPSDetector Integration → Unified API
```

**Integration with Epic 3 (Trading Range & Ice Level):**

```python
# Epic 3 provides TradingRange model with Ice level
from backend.src.models.trading_range import TradingRange

# Ice level used for breakout detection
ice_level = range.ice_level.price  # Decimal from Story 3.5

# SOS = break above Ice + volume expansion
```

**Integration with Story 2.5 (VolumeAnalyzer):**

```python
# VolumeAnalyzer provides volume_ratio and spread_ratio
volume_analysis = {
    bar.timestamp: {
        "volume_ratio": Decimal("2.0"),   # Used for FR12 validation
        "spread_ratio": Decimal("1.5")    # Used for spread expansion validation
    }
}
```

**Integration with Story 4.4 (PhaseDetector):**

```python
# PhaseDetector provides current phase
from backend.src.models.phase_classification import WyckoffPhase, PhaseClassification

# SOS valid in Phase D or late Phase C (85+ confidence)
phase = PhaseClassification(phase=WyckoffPhase.D, confidence=90)

sos = detect_sos_breakout(range, bars, volume_analysis, phase)
```

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/detectors/test_sos_detector.py`
- Integration: `backend/tests/integration/pattern_engine/detectors/test_sos_detector_integration.py`

### Coverage Requirements
- Valid SOS detection (2.0x volume, strong close) - AC 9
- Low-volume rejection (<1.5x) - AC 4, FR12
- Weak close position (0.5) reduces confidence - AC 10
- Breakout percentage validation (1% minimum) - AC 3
- Spread expansion validation (1.2x minimum) - AC 5
- Phase D/C validation - AC 8, FR15
- Volume/spread boundary cases
- Integration with realistic data

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../../docs/architecture/12-testing-strategy.md)]
- Unit tests with synthetic data
- Integration tests with realistic bar sequences
- Coverage >90% for sos_detector.py
- Validate FR12, FR15 enforcement
- Test all rejection scenarios

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-06 | 1.1 | **Wyckoff Team Review Applied** - Updated AC 6/10 with three-tier close position handling (>=0.7 PASS, 0.5-0.69 MARGINAL, <0.5 REJECT), Updated Task 7 with three-tier implementation logic, Updated Task 12 with comprehensive tier tests (PASS/MARGINAL/REJECT boundaries), Enhanced Dev Notes: Volume Quality Tiers (1.5-2.0x ACCEPTABLE, 2.0-2.5x IDEAL, 2.5x+ CLIMACTIC), Enhanced Breakout Size ranges (1-2% MINIMUM, 2-3% NORMAL, 3%+ STRONG), Added Ice Strength note for Story 6.5 future implementation | Scrum Master (Bob) |
| 2025-10-18 | 1.0 | Initial story: SOS Breakout Detection with volume expansion validation (1.5x+), spread expansion (1.2x+), strong close (0.7+), breakout size (1%+), Phase D/C validation, comprehensive Wyckoff context | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_Populated by dev agent during implementation_

### Debug Log References
_Populated by dev agent during implementation_

### Completion Notes List
_Populated by dev agent during implementation_

### File List
_Populated by dev agent during implementation_

## QA Results
_Populated by QA agent after completion_
