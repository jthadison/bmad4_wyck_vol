# Story 4.6: Phase Progression Validation

## Status

Ready for Review

## Story

**As a** phase detector,
**I want** to validate that phases progress logically (no skipping or reverting),
**so that** invalid phase sequences are detected and rejected.

## Acceptance Criteria

1. Valid progressions: Aâ†’Bâ†’Câ†’Dâ†’E (accumulation), Aâ†’Bâ†’C (distribution without markup)
2. Invalid: Bâ†’A (can't revert to stopping action), Câ†’B (can't un-spring), Dâ†’C (can't un-break out)
3. Function: `validate_phase_progression(current_phase, new_phase) -> bool`
4. State machine enforcement: transitions validated before phase update
5. Exception: new range can start new Phase A (reset progression)
6. Logging: warning log for invalid progression attempts
7. Unit test: valid progressions accepted, invalid rejected
8. Integration test: full Aâ†’Bâ†’Câ†’Dâ†’E sequence validates
9. Edge case: range failure (breakdown) can transition to new range Phase A
10. Phase history tracking: store progression for debugging

## Tasks / Subtasks

- [ ] **Task 1: Create phase progression state machine model** (AC: 1, 2, 3, 4)
  - [ ] Create file: `backend/src/pattern_engine/phase_progression_validator.py`
  - [ ] Import WyckoffPhase enum from Story 4.4
  - [ ] Define valid phase transitions as state machine
  - [ ] Create PhaseTransition dataclass: `class PhaseTransition(BaseModel):`
    - `from_phase: WyckoffPhase | None` - Previous phase (None if first phase)
    - `to_phase: WyckoffPhase` - New phase to transition to
    - `timestamp: datetime` - When transition occurred (UTC)
    - `bar_index: int` - Bar index where transition occurred
    - `reason: str` - Why transition occurred (e.g., "SC + AR detected")
    - `is_valid: bool` - Whether transition is valid
    - `rejection_reason: str | None` - If invalid, why
  - [ ] Add validators:
    - timestamp must be UTC
    - bar_index >= 0
    - reason must be non-empty
  - [ ] Configure JSON serialization

- [ ] **Task 2: Define valid phase progression rules** (AC: 1, 2, 5)
  - [ ] Create VALID_TRANSITIONS constant as state machine map
  - [ ] **Valid Accumulation Progressions (AC 1):**
    - None â†’ A: Starting new accumulation (SC + AR detected)
    - A â†’ B: First ST detected (beginning of cause building)
    - B â†’ C: Spring detected (final test, adequate Phase B duration)
    - C â†’ D: SOS breakout detected (markup beginning)
    - D â†’ E: Sustained above Ice (markup continuation)
  - [ ] **Valid Distribution Progressions (AC 1):**
    - A â†’ B â†’ C: Distribution can end after Phase C (no markup)
    - C â†’ None: Range failure (breakdown below Creek)
  - [ ] **Valid Resets (AC 5):**
    - Any phase â†’ A: New range detected (reset progression)
    - E â†’ A: Trend ended, new accumulation beginning
  - [ ] **Implementation:**
    ```python
    VALID_TRANSITIONS: Dict[WyckoffPhase | None, List[WyckoffPhase | None]] = {
        None: [WyckoffPhase.A],  # Can only start with Phase A
        WyckoffPhase.A: [WyckoffPhase.B, WyckoffPhase.A],  # Aâ†’B normal, Aâ†’A new range
        WyckoffPhase.B: [WyckoffPhase.C, WyckoffPhase.A],  # Bâ†’C normal, Bâ†’A new range
        WyckoffPhase.C: [WyckoffPhase.D, None, WyckoffPhase.A],  # Câ†’D normal, Câ†’None failure, Câ†’A new range
        WyckoffPhase.D: [WyckoffPhase.E, WyckoffPhase.A],  # Dâ†’E normal, Dâ†’A new range
        WyckoffPhase.E: [WyckoffPhase.A],  # Eâ†’A new accumulation
    }
    ```

- [ ] **Task 3: Implement validate_phase_progression function** (AC: 3, 4)
  - [ ] Create function signature:
    ```python
    def validate_phase_progression(
        current_phase: WyckoffPhase | None,
        new_phase: WyckoffPhase | None,
        context: Dict[str, Any] | None = None
    ) -> Tuple[bool, str | None]:
    ```
  - [ ] Add comprehensive docstring:
    - Purpose: Validate phase transition using state machine rules
    - Parameters:
      - current_phase: Current Wyckoff phase (None if no phase yet)
      - new_phase: Proposed new phase (None if range failure)
      - context: Optional context (new_range_detected, reason, etc.)
    - Returns: (is_valid: bool, rejection_reason: str | None)
    - Algorithm: Check VALID_TRANSITIONS state machine
  - [ ] **Validation Logic (AC 4):**
    ```python
    def validate_phase_progression(current_phase, new_phase, context=None):
        # Handle None states
        if current_phase is None and new_phase is None:
            return False, "Cannot transition from None to None"

        # Check if transition is in valid list
        valid_next_phases = VALID_TRANSITIONS.get(current_phase, [])

        if new_phase not in valid_next_phases:
            # Check if this is a new range reset (exception case AC 5)
            if context and context.get("new_range_detected"):
                if new_phase == WyckoffPhase.A:
                    return True, None  # Allow reset to Phase A for new range

            # Invalid transition
            reason = f"Invalid phase progression: {current_phase} â†’ {new_phase}. " \
                     f"Valid transitions from {current_phase}: {valid_next_phases}"
            return False, reason

        # Valid transition
        return True, None
    ```
  - [ ] Return tuple (is_valid, rejection_reason)

- [ ] **Task 4: Define invalid progression rules and rejection reasons** (AC: 2, 6)
  - [ ] Create INVALID_TRANSITIONS_REASONS constant
  - [ ] **Invalid Reversions (AC 2):**
    - B â†’ A: "Cannot revert to stopping action (Phase A) once cause building (Phase B) has begun"
    - C â†’ B: "Cannot revert to building cause (Phase B) after test (Phase C) has occurred"
    - C â†’ A: "Cannot revert to stopping action (Phase A) after test (Phase C)"
    - D â†’ C: "Cannot revert to test (Phase C) after breakout (Phase D) has occurred"
    - D â†’ B: "Cannot revert to building cause (Phase B) after breakout (Phase D)"
    - D â†’ A: "Cannot revert to stopping action (Phase A) after breakout (Phase D) (unless new range)"
    - E â†’ D: "Cannot revert to breakout (Phase D) after markup (Phase E) has begun"
    - E â†’ C/B: "Cannot revert to earlier phases after markup (Phase E)"
  - [ ] **Invalid Skips:**
    - A â†’ C: "Cannot skip building cause (Phase B) - must have secondary tests"
    - A â†’ D: "Cannot skip to breakout (Phase D) without test (Phase C)"
    - A â†’ E: "Cannot skip to markup (Phase E) directly"
    - B â†’ D: "Cannot skip test (Phase C) - must have Spring before SOS"
    - B â†’ E: "Cannot skip to markup (Phase E) without test and breakout"
    - C â†’ E: "Cannot skip breakout (Phase D) - must have SOS before markup"
  - [ ] Use these reasons in validation function

- [ ] **Task 5: Implement phase history tracking** (AC: 10)
  - [ ] Create PhaseHistory dataclass: `class PhaseHistory(BaseModel):`
    - `transitions: List[PhaseTransition]` - Ordered list of all phase transitions
    - `current_phase: WyckoffPhase | None` - Current phase
    - `range_id: UUID` - Associated trading range ID
    - `started_at: datetime` - When phase tracking began (UTC)
    - `updated_at: datetime` - Last update timestamp (UTC)
  - [ ] Create function: `def add_phase_transition(history: PhaseHistory, transition: PhaseTransition) -> PhaseHistory:`
    - Validate transition using validate_phase_progression
    - If valid: append to history.transitions, update current_phase
    - If invalid: log warning, do NOT update history
    - Update history.updated_at
    - Return updated history
  - [ ] Create function: `def get_phase_duration(history: PhaseHistory, phase: WyckoffPhase) -> int:`
    - Find all transitions for given phase
    - Calculate total bars spent in that phase
    - Return duration in bars
  - [ ] Create function: `def get_transition_summary(history: PhaseHistory) -> str:`
    - Format: "A (3 bars) â†’ B (15 bars) â†’ C (2 bars) â†’ D (5 bars)"
    - Return human-readable progression summary

- [ ] **Task 6: Implement exception handling for new range resets** (AC: 5, 9)
  - [ ] Create function: `def can_reset_to_phase_a(current_phase: WyckoffPhase, context: Dict[str, Any]) -> bool:`
  - [ ] Add docstring:
    - Purpose: Determine if reset to Phase A is allowed (AC 5, 9)
    - Valid resets:
      - New trading range detected (context["new_range_detected"] = True)
      - Range failure/breakdown (context["range_breakdown"] = True)
      - Trend ended, new accumulation (context["trend_ended"] = True)
  - [ ] **Implementation:**
    ```python
    def can_reset_to_phase_a(current_phase, context):
        if context is None:
            return False

        # AC 5: New range can start new Phase A
        if context.get("new_range_detected"):
            return True

        # AC 9: Range failure can transition to new Phase A
        if context.get("range_breakdown"):
            return True

        # Trend ended, new accumulation beginning
        if context.get("trend_ended"):
            return True

        return False
    ```
  - [ ] Integrate into validate_phase_progression function
  - [ ] Log reset events: "Phase A reset triggered: {reason}"

- [ ] **Task 7: Implement logging for progression validation** (AC: 6)
  - [ ] Import structlog for structured logging
  - [ ] **Log valid transitions (info level):**
    ```python
    logger.info(
        "phase_transition_valid",
        current_phase=current_phase.value if current_phase else None,
        new_phase=new_phase.value if new_phase else None,
        bar_index=context.get("bar_index"),
        reason=context.get("reason")
    )
    ```
  - [ ] **Log invalid transitions (warning level) (AC 6):**
    ```python
    logger.warning(
        "phase_transition_invalid",
        current_phase=current_phase.value if current_phase else None,
        new_phase=new_phase.value if new_phase else None,
        rejection_reason=rejection_reason,
        bar_index=context.get("bar_index"),
        attempted_reason=context.get("reason")
    )
    ```
  - [ ] **Log reset events (info level):**
    ```python
    logger.info(
        "phase_progression_reset",
        previous_phase=current_phase.value,
        new_phase="A",
        reset_reason=context.get("reset_reason")
    )
    ```
  - [ ] Use correlation IDs for tracking progression across bars

- [ ] **Task 8: Create phase progression enforcement wrapper** (AC: 4)
  - [ ] Create function: `def enforce_phase_progression(history: PhaseHistory, new_classification: PhaseClassification, context: Dict[str, Any]) -> Tuple[bool, PhaseHistory, str | None]:`
  - [ ] Add docstring:
    - Purpose: Wrapper that validates and enforces phase progression before updating
    - Called by PhaseDetector before accepting new phase classification
    - Returns: (accepted: bool, updated_history: PhaseHistory, rejection_reason: str | None)
  - [ ] **Implementation (AC 4):**
    ```python
    def enforce_phase_progression(history, new_classification, context):
        current_phase = history.current_phase
        new_phase = new_classification.phase

        # Validate transition
        is_valid, rejection_reason = validate_phase_progression(
            current_phase, new_phase, context
        )

        if not is_valid:
            # Log warning
            logger.warning(
                "phase_progression_rejected",
                current_phase=current_phase,
                new_phase=new_phase,
                rejection_reason=rejection_reason
            )
            return False, history, rejection_reason

        # Create transition record
        transition = PhaseTransition(
            from_phase=current_phase,
            to_phase=new_phase,
            timestamp=datetime.now(timezone.utc),
            bar_index=context.get("bar_index", 0),
            reason=context.get("reason", "Unknown"),
            is_valid=True,
            rejection_reason=None
        )

        # Update history
        updated_history = add_phase_transition(history, transition)

        # Log success
        logger.info(
            "phase_progression_accepted",
            from_phase=current_phase,
            to_phase=new_phase,
            bar_index=transition.bar_index
        )

        return True, updated_history, None
    ```

- [ ] **Task 9: Write unit test for valid progressions** (AC: 7)
  - [ ] Create test file: `backend/tests/unit/pattern_engine/test_phase_progression_validator.py`
  - [ ] Import pytest, WyckoffPhase, validate_phase_progression
  - [ ] **Test valid accumulation progression (AC 1):**
    ```python
    def test_valid_accumulation_progression():
        # None â†’ A
        is_valid, reason = validate_phase_progression(None, WyckoffPhase.A)
        assert is_valid is True
        assert reason is None

        # A â†’ B
        is_valid, reason = validate_phase_progression(WyckoffPhase.A, WyckoffPhase.B)
        assert is_valid is True

        # B â†’ C
        is_valid, reason = validate_phase_progression(WyckoffPhase.B, WyckoffPhase.C)
        assert is_valid is True

        # C â†’ D
        is_valid, reason = validate_phase_progression(WyckoffPhase.C, WyckoffPhase.D)
        assert is_valid is True

        # D â†’ E
        is_valid, reason = validate_phase_progression(WyckoffPhase.D, WyckoffPhase.E)
        assert is_valid is True
    ```
  - [ ] **Test valid distribution progression (AC 1):**
    ```python
    def test_valid_distribution_progression():
        # A â†’ B â†’ C â†’ None (range failure)
        is_valid, _ = validate_phase_progression(WyckoffPhase.A, WyckoffPhase.B)
        assert is_valid is True

        is_valid, _ = validate_phase_progression(WyckoffPhase.B, WyckoffPhase.C)
        assert is_valid is True

        is_valid, _ = validate_phase_progression(WyckoffPhase.C, None)
        assert is_valid is True  # Range failure allowed
    ```

- [ ] **Task 10: Write unit test for invalid progressions** (AC: 2, 7)
  - [ ] **Test invalid reversions (AC 2):**
    ```python
    def test_invalid_reversions():
        # B â†’ A (cannot revert to stopping action)
        is_valid, reason = validate_phase_progression(WyckoffPhase.B, WyckoffPhase.A)
        assert is_valid is False
        assert "revert" in reason.lower()
        assert "stopping action" in reason.lower()

        # C â†’ B (cannot un-spring)
        is_valid, reason = validate_phase_progression(WyckoffPhase.C, WyckoffPhase.B)
        assert is_valid is False
        assert "revert" in reason.lower()

        # D â†’ C (cannot un-break out)
        is_valid, reason = validate_phase_progression(WyckoffPhase.D, WyckoffPhase.C)
        assert is_valid is False
        assert "revert" in reason.lower()
        assert "breakout" in reason.lower()

        # E â†’ D
        is_valid, reason = validate_phase_progression(WyckoffPhase.E, WyckoffPhase.D)
        assert is_valid is False
    ```
  - [ ] **Test invalid skips:**
    ```python
    def test_invalid_skips():
        # A â†’ C (cannot skip Phase B)
        is_valid, reason = validate_phase_progression(WyckoffPhase.A, WyckoffPhase.C)
        assert is_valid is False
        assert "Phase B" in reason or "building cause" in reason.lower()

        # A â†’ D
        is_valid, reason = validate_phase_progression(WyckoffPhase.A, WyckoffPhase.D)
        assert is_valid is False

        # B â†’ D (cannot skip Phase C)
        is_valid, reason = validate_phase_progression(WyckoffPhase.B, WyckoffPhase.D)
        assert is_valid is False
        assert "Phase C" in reason or "test" in reason.lower()
    ```

- [ ] **Task 11: Write unit test for new range resets** (AC: 5)
  - [ ] **Test reset to Phase A with new range context (AC 5):**
    ```python
    def test_new_range_reset():
        # Any phase â†’ A with new_range_detected context
        context = {"new_range_detected": True, "reason": "New trading range detected"}

        # B â†’ A (normally invalid, but allowed with new range)
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.B, WyckoffPhase.A, context
        )
        assert is_valid is True
        assert reason is None

        # D â†’ A (normally invalid, but allowed with new range)
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.D, WyckoffPhase.A, context
        )
        assert is_valid is True

        # E â†’ A (trend ended, new accumulation)
        context = {"trend_ended": True}
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.E, WyckoffPhase.A, context
        )
        assert is_valid is True
    ```

- [ ] **Task 12: Write unit test for range failure edge case** (AC: 9)
  - [ ] **Test range breakdown to None (AC 9):**
    ```python
    def test_range_breakdown():
        # C â†’ None (range failure, breakdown below Creek)
        context = {"range_breakdown": True, "reason": "Breakdown below Creek"}
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.C, None, context
        )
        assert is_valid is True  # Allowed per AC 9

        # After breakdown, can start new Phase A
        is_valid, reason = validate_phase_progression(None, WyckoffPhase.A)
        assert is_valid is True
    ```

- [ ] **Task 13: Write unit test for phase history tracking** (AC: 10)
  - [ ] **Test PhaseHistory creation and updates:**
    ```python
    def test_phase_history_tracking():
        # Create initial history
        history = PhaseHistory(
            transitions=[],
            current_phase=None,
            range_id=uuid.uuid4(),
            started_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )

        # Add Phase A transition
        transition_a = PhaseTransition(
            from_phase=None,
            to_phase=WyckoffPhase.A,
            timestamp=datetime.now(timezone.utc),
            bar_index=10,
            reason="SC + AR detected",
            is_valid=True,
            rejection_reason=None
        )
        history = add_phase_transition(history, transition_a)

        assert history.current_phase == WyckoffPhase.A
        assert len(history.transitions) == 1

        # Add Phase B transition
        transition_b = PhaseTransition(
            from_phase=WyckoffPhase.A,
            to_phase=WyckoffPhase.B,
            timestamp=datetime.now(timezone.utc),
            bar_index=15,
            reason="First ST detected",
            is_valid=True,
            rejection_reason=None
        )
        history = add_phase_transition(history, transition_b)

        assert history.current_phase == WyckoffPhase.B
        assert len(history.transitions) == 2

        # Get progression summary
        summary = get_transition_summary(history)
        assert "A" in summary
        assert "B" in summary
    ```
  - [ ] **Test invalid transition rejection:**
    ```python
    def test_invalid_transition_rejected():
        history = PhaseHistory(
            transitions=[],
            current_phase=WyckoffPhase.B,
            range_id=uuid.uuid4(),
            started_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )

        # Attempt invalid B â†’ A transition
        invalid_transition = PhaseTransition(
            from_phase=WyckoffPhase.B,
            to_phase=WyckoffPhase.A,
            timestamp=datetime.now(timezone.utc),
            bar_index=20,
            reason="Attempted invalid reversion",
            is_valid=False,  # Marked as invalid
            rejection_reason="Cannot revert to stopping action"
        )

        # Should NOT update history
        original_phase = history.current_phase
        history_updated = add_phase_transition(history, invalid_transition)

        assert history_updated.current_phase == original_phase  # No change
        # Invalid transitions should be logged but not added to history
    ```

- [ ] **Task 14: Write integration test for full Aâ†’Bâ†’Câ†’Dâ†’E sequence** (AC: 8)
  - [ ] Create test file: `backend/tests/integration/pattern_engine/test_phase_progression_integration.py`
  - [ ] **Test complete accumulation progression (AC 8):**
    ```python
    def test_full_accumulation_progression():
        # Initialize history
        history = PhaseHistory(
            transitions=[],
            current_phase=None,
            range_id=uuid.uuid4(),
            started_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )

        # Progression: None â†’ A â†’ B â†’ C â†’ D â†’ E
        phases = [
            (None, WyckoffPhase.A, 10, "SC + AR detected"),
            (WyckoffPhase.A, WyckoffPhase.B, 15, "First ST detected"),
            (WyckoffPhase.B, WyckoffPhase.C, 30, "Spring detected"),
            (WyckoffPhase.C, WyckoffPhase.D, 35, "SOS breakout"),
            (WyckoffPhase.D, WyckoffPhase.E, 45, "Sustained above Ice")
        ]

        for from_phase, to_phase, bar_index, reason in phases:
            # Create phase classification (from Story 4.4)
            classification = PhaseClassification(
                phase=to_phase,
                confidence=85,
                duration=0,
                events_detected=PhaseEvents(...),  # Mock events
                trading_allowed=True,
                rejection_reason=None,
                phase_start_index=bar_index,
                phase_start_timestamp=datetime.now(timezone.utc),
                last_updated=datetime.now(timezone.utc)
            )

            # Enforce progression
            context = {"bar_index": bar_index, "reason": reason}
            accepted, history, rejection_reason = enforce_phase_progression(
                history, classification, context
            )

            assert accepted is True, f"Transition {from_phase} â†’ {to_phase} rejected: {rejection_reason}"
            assert rejection_reason is None
            assert history.current_phase == to_phase

        # Verify final state
        assert history.current_phase == WyckoffPhase.E
        assert len(history.transitions) == 5

        # Verify progression summary
        summary = get_transition_summary(history)
        assert "A" in summary and "B" in summary and "C" in summary
        assert "D" in summary and "E" in summary
    ```

- [ ] **Task 15: Write integration test with invalid attempts** (AC: all)
  - [ ] **Test progression with invalid transition attempts:**
    ```python
    def test_progression_with_invalid_attempts():
        # Start with Phase B
        history = PhaseHistory(
            transitions=[],
            current_phase=WyckoffPhase.B,
            range_id=uuid.uuid4(),
            started_at=datetime.now(timezone.utc),
            updated_at=datetime.now(timezone.utc)
        )

        # Attempt invalid B â†’ A transition
        invalid_classification = PhaseClassification(
            phase=WyckoffPhase.A,
            confidence=70,
            duration=5,
            events_detected=PhaseEvents(...),
            trading_allowed=False,
            rejection_reason=None,
            phase_start_index=20,
            phase_start_timestamp=datetime.now(timezone.utc),
            last_updated=datetime.now(timezone.utc)
        )

        context = {"bar_index": 20, "reason": "Attempted invalid reversion"}
        accepted, history_after_invalid, rejection_reason = enforce_phase_progression(
            history, invalid_classification, context
        )

        # Should be rejected
        assert accepted is False
        assert rejection_reason is not None
        assert "revert" in rejection_reason.lower()
        assert history_after_invalid.current_phase == WyckoffPhase.B  # No change

        # Valid B â†’ C transition should work
        valid_classification = PhaseClassification(
            phase=WyckoffPhase.C,
            confidence=85,
            duration=2,
            events_detected=PhaseEvents(...),
            trading_allowed=True,
            rejection_reason=None,
            phase_start_index=25,
            phase_start_timestamp=datetime.now(timezone.utc),
            last_updated=datetime.now(timezone.utc)
        )

        context = {"bar_index": 25, "reason": "Spring detected"}
        accepted, history_final, rejection_reason = enforce_phase_progression(
            history_after_invalid, valid_classification, context
        )

        assert accepted is True
        assert history_final.current_phase == WyckoffPhase.C
    ```

- [ ] **Task 16: Add comprehensive docstrings and usage examples** (AC: all)
  - [ ] Add module-level docstring to phase_progression_validator.py:
    ```python
    """
    Phase Progression Validator Module

    Purpose:
    --------
    Validates Wyckoff phase transitions using a state machine to ensure logical
    progression through accumulation phases (Aâ†’Bâ†’Câ†’Dâ†’E). Prevents invalid reversions
    (Bâ†’A, Câ†’B, Dâ†’C) and phase skipping (Aâ†’C, Bâ†’D).

    Key Components:
    ---------------
    - validate_phase_progression(): Core validation function
    - PhaseTransition: Records each phase transition with metadata
    - PhaseHistory: Tracks complete progression history for debugging
    - enforce_phase_progression(): Wrapper for PhaseDetector integration

    Valid Progressions:
    -------------------
    Accumulation: A â†’ B â†’ C â†’ D â†’ E
    Distribution: A â†’ B â†’ C (no markup)
    Reset: Any phase â†’ A (new range detected)

    Invalid Progressions:
    ---------------------
    Reversions: Bâ†’A, Câ†’B, Dâ†’C, Eâ†’D (cannot go backward)
    Skips: Aâ†’C, Bâ†’D, Câ†’E (must progress sequentially)

    Usage:
    ------
    See examples in function docstrings below.

    Integration:
    ------------
    - Story 4.4: PhaseClassification provides phase classifications
    - Story 4.6: This module validates transitions between classifications
    - Story 4.7: PhaseDetector uses enforce_phase_progression() before updates

    Author: Generated for Story 4.6
    """
    ```
  - [ ] Add function-level docstrings with examples
  - [ ] **Usage example in docstring:**
    ```python
    # Example 1: Validate individual transition
    from backend.src.pattern_engine.phase_progression_validator import (
        validate_phase_progression
    )
    from backend.src.models.phase_classification import WyckoffPhase

    # Valid transition: A â†’ B
    is_valid, reason = validate_phase_progression(WyckoffPhase.A, WyckoffPhase.B)
    print(f"Valid: {is_valid}")  # True

    # Invalid transition: B â†’ A
    is_valid, reason = validate_phase_progression(WyckoffPhase.B, WyckoffPhase.A)
    print(f"Valid: {is_valid}")  # False
    print(f"Reason: {reason}")  # "Cannot revert to stopping action..."

    # Example 2: Track phase history
    from backend.src.pattern_engine.phase_progression_validator import (
        PhaseHistory, PhaseTransition, add_phase_transition
    )

    # Initialize history
    history = PhaseHistory(
        transitions=[],
        current_phase=None,
        range_id=range_id,
        started_at=datetime.now(timezone.utc),
        updated_at=datetime.now(timezone.utc)
    )

    # Add transitions as phases are detected
    transition = PhaseTransition(
        from_phase=None,
        to_phase=WyckoffPhase.A,
        timestamp=datetime.now(timezone.utc),
        bar_index=10,
        reason="SC + AR detected",
        is_valid=True,
        rejection_reason=None
    )
    history = add_phase_transition(history, transition)

    # Get progression summary
    summary = get_transition_summary(history)
    print(summary)  # "A (5 bars) â†’ B (15 bars) â†’ C (2 bars)"

    # Example 3: Enforce progression in PhaseDetector (Story 4.7)
    from backend.src.pattern_engine.phase_progression_validator import (
        enforce_phase_progression
    )

    # PhaseDetector has new classification from Story 4.4
    new_classification = classify_phase(events, trading_range)

    # Validate and enforce progression before updating
    context = {
        "bar_index": current_bar_index,
        "reason": "Spring detected",
        "new_range_detected": False
    }

    accepted, updated_history, rejection_reason = enforce_phase_progression(
        phase_history, new_classification, context
    )

    if accepted:
        # Update phase detector state
        current_phase = new_classification.phase
        phase_history = updated_history
    else:
        # Log rejection, keep current phase
        logger.warning("phase_rejected", reason=rejection_reason)
    ```

- [ ] **Task 17: Document integration with Story 4.4 and Story 4.7** (AC: all)
  - [ ] **Story 4.4 Integration (Phase Classification):**
    - Story 4.4 provides PhaseClassification with detected phase
    - Story 4.6 validates transitions between classifications
    - PhaseClassification.phase is the "new_phase" parameter
    - Current phase from PhaseHistory.current_phase
  - [ ] **Story 4.7 Integration (PhaseDetector Module):**
    - PhaseDetector maintains PhaseHistory instance
    - Before updating phase, calls enforce_phase_progression()
    - If rejected: log warning, keep current phase
    - If accepted: update phase, append to history
  - [ ] **Epic 5 Dependencies (Pattern Detection):**
    - Spring detection triggers B â†’ C transition
    - SOS detection triggers C â†’ D transition
    - Sustained markup triggers D â†’ E transition
  - [ ] Document in module docstring and function comments

- [ ] **Task 18: Add logging correlation IDs for debugging** (AC: 6, 10)
  - [ ] Generate correlation_id for each phase progression check
  - [ ] Include correlation_id in all log messages
  - [ ] **Structured logging example:**
    ```python
    import structlog

    logger = structlog.get_logger(__name__)

    def validate_phase_progression(current_phase, new_phase, context=None):
        correlation_id = context.get("correlation_id", str(uuid.uuid4()))

        logger.bind(correlation_id=correlation_id)

        logger.info(
            "phase_progression_validation_start",
            current_phase=current_phase.value if current_phase else None,
            new_phase=new_phase.value if new_phase else None
        )

        # ... validation logic ...

        if not is_valid:
            logger.warning(
                "phase_progression_invalid",
                current_phase=current_phase.value if current_phase else None,
                new_phase=new_phase.value if new_phase else None,
                rejection_reason=rejection_reason
            )
        else:
            logger.info(
                "phase_progression_valid",
                current_phase=current_phase.value if current_phase else None,
                new_phase=new_phase.value if new_phase else None
            )

        return is_valid, rejection_reason
    ```
  - [ ] Log phase history state after each transition
  - [ ] Enable tracing of full progression through correlation IDs

- [ ] **Task 19: Create phase progression visualization helper** (AC: 10)
  - [ ] Create function: `def visualize_phase_progression(history: PhaseHistory) -> str:`
  - [ ] Generate ASCII visualization of phase progression
  - [ ] **Example output:**
    ```
    Phase Progression for Range abc123:
    ====================================
    Bar 10: None â†’ A (SC + AR detected)
            [Duration: 5 bars]
    Bar 15: A â†’ B (First ST detected)
            [Duration: 15 bars]
    Bar 30: B â†’ C (Spring detected)
            [Duration: 5 bars]
    Bar 35: C â†’ D (SOS breakout)
            [Duration: 10 bars]
    Bar 45: D â†’ E (Sustained above Ice)
            [Duration: ongoing]

    Total transitions: 5
    Current phase: E
    ```
  - [ ] Useful for debugging and manual verification
  - [ ] Include in debug logs when progression fails

- [ ] **Task 20: Write test for edge cases** (AC: all)
  - [ ] Test same phase transition (A â†’ A with new range):
    ```python
    def test_same_phase_transition():
        # A â†’ A is only valid with new_range_detected context
        context = {"new_range_detected": True}
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.A, WyckoffPhase.A, context
        )
        assert is_valid is True

        # A â†’ A without context should be invalid
        is_valid, reason = validate_phase_progression(
            WyckoffPhase.A, WyckoffPhase.A
        )
        assert is_valid is True  # Actually allowed per VALID_TRANSITIONS
    ```
  - [ ] Test None transitions:
    ```python
    def test_none_transitions():
        # None â†’ None should be invalid
        is_valid, reason = validate_phase_progression(None, None)
        assert is_valid is False

        # None â†’ A should be valid (starting new accumulation)
        is_valid, reason = validate_phase_progression(None, WyckoffPhase.A)
        assert is_valid is True

        # None â†’ B should be invalid (must start with A)
        is_valid, reason = validate_phase_progression(None, WyckoffPhase.B)
        assert is_valid is False
    ```
  - [ ] Test rapid transitions (multiple in short time):
    ```python
    def test_rapid_transitions():
        # Simulate rapid progression A â†’ B â†’ C within 10 bars
        # This is technically valid but unusual
        history = PhaseHistory(...)

        # A â†’ B at bar 10
        # B â†’ C at bar 15 (only 5 bars in Phase B)
        # Should be valid (no minimum duration check in validator)
        # Note: Story 4.4 handles duration checks, not this module
    ```

- [ ] **Task 21: Document performance considerations** (AC: all)
  - [ ] Phase progression validation is O(1) lookup in VALID_TRANSITIONS dict
  - [ ] PhaseHistory tracking is O(1) append to list
  - [ ] get_transition_summary is O(n) where n = number of transitions
  - [ ] Performance targets:
    - Single validation: <1ms
    - History update: <2ms
    - Transition summary: <5ms for 100 transitions
  - [ ] No caching needed (operations are fast enough)

- [ ] **Task 22: Add type hints and mypy validation** (AC: all)
  - [ ] Add comprehensive type hints to all functions
  - [ ] Use strict typing: `from __future__ import annotations`
  - [ ] Run mypy in strict mode: `mypy --strict phase_progression_validator.py`
  - [ ] Fix any type errors
  - [ ] Add py.typed marker for type checking

## Dev Notes

### Previous Story Context

**Story 4.1 Completion (Selling Climax Detection):**
[Source: Story 4.1]
- `detect_selling_climax(bars, volume_analysis)` returns Optional[SellingClimax]
- SellingClimax marks Phase A beginning
- **Story 4.6 integration:** SC detection triggers None â†’ A transition

**Story 4.2 Completion (Automatic Rally Detection):**
[Source: Story 4.2]
- `detect_automatic_rally(bars, sc)` returns Optional[AutomaticRally]
- SC + AR confirms Phase A
- **Story 4.6 integration:** AR confirms Phase A, no transition yet

**Story 4.3 Completion (Secondary Test Detection):**
[Source: Story 4.3]
- `detect_secondary_test(bars, sc, ar, volume_analysis)` returns Optional[SecondaryTest]
- First ST triggers Phase A â†’ Phase B transition
- **Story 4.6 integration:** First ST is critical transition point

**Story 4.4 Completion (Phase Classification Logic):**
[Source: Story 4.4]
- `classify_phase(events, trading_range)` returns PhaseClassification
- PhaseClassification contains: phase, confidence, duration, events, trading_allowed
- **Story 4.6 integration:**
  - Story 4.4 determines WHAT phase we're in
  - Story 4.6 validates transitions BETWEEN phases
  - PhaseClassification.phase is input to validate_phase_progression()

**Epic 3 Completion (Trading Range Detection):**
[Source: Epic 3]
- TradingRange model: creek_level, ice_level, jump_level
- **Story 4.6 integration:** New range detection triggers reset to Phase A

**Key Learnings from Previous Stories:**
- Phase progression follows Wyckoff methodology: A â†’ B â†’ C â†’ D â†’ E
- Cannot skip phases (need sequential event detection)
- Cannot revert phases (events are irreversible)
- Exception: new range can reset to Phase A
- **Story 4.6 enforces these rules using state machine validation**

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md#31-technology-stack-table)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models: PhaseTransition, PhaseHistory)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging with correlation IDs)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- New Module: `backend/src/pattern_engine/phase_progression_validator.py` (create new)
- Model Integration: Import WyckoffPhase from `backend/src/models/phase_classification.py` (Story 4.4)
- Unit Tests: `backend/tests/unit/pattern_engine/test_phase_progression_validator.py` (create new)
- Integration Tests: `backend/tests/integration/pattern_engine/test_phase_progression_integration.py` (create new)

**Dependencies on Existing Code:**
- `backend/src/models/phase_classification.py`: WyckoffPhase enum, PhaseClassification (Story 4.4)
- Pydantic BaseModel, Field, validator
- structlog for logging
- datetime, timezone for timestamps
- uuid for correlation IDs and range IDs
- typing for type hints (Dict, List, Tuple, Any)

### Algorithm Details

**Phase Progression State Machine:**
[Source: Epic 4 AC and Wyckoff methodology]

**Purpose:** Validate phase transitions using state machine to prevent invalid progressions. Wyckoff phases must progress sequentially (Aâ†’Bâ†’Câ†’Dâ†’E) with no backward movement or skipping.

**State Machine Design:**

```
Valid Transitions Map:
======================
None â†’ [A]                    # Can only start with Phase A
A â†’ [B, A]                    # Aâ†’B normal, Aâ†’A new range
B â†’ [C, A]                    # Bâ†’C normal, Bâ†’A new range
C â†’ [D, None, A]              # Câ†’D normal, Câ†’None failure, Câ†’A new range
D â†’ [E, A]                    # Dâ†’E normal, Dâ†’A new range
E â†’ [A]                       # Eâ†’A new accumulation
```

**Validation Algorithm:**

```python
def validate_phase_progression(current_phase, new_phase, context=None):
    # Step 1: Handle None states
    if current_phase is None and new_phase is None:
        return False, "Cannot transition from None to None"

    # Step 2: Lookup valid transitions from state machine
    valid_next_phases = VALID_TRANSITIONS.get(current_phase, [])

    # Step 3: Check if new_phase is in valid list
    if new_phase in valid_next_phases:
        return True, None  # Valid transition

    # Step 4: Check exception cases (AC 5, 9)
    if context:
        # Exception: New range detected
        if context.get("new_range_detected") and new_phase == WyckoffPhase.A:
            return True, None

        # Exception: Range breakdown
        if context.get("range_breakdown") and new_phase is None:
            return True, None

    # Step 5: Invalid transition
    reason = f"Invalid phase progression: {current_phase} â†’ {new_phase}"
    return False, reason
```

**Invalid Progression Detection:**

**Reversions (AC 2):**
- B â†’ A: Cannot revert to stopping action after cause building started
- C â†’ B: Cannot un-spring (Spring is irreversible event)
- D â†’ C: Cannot un-breakout (SOS breakout is irreversible)
- E â†’ D/C/B/A: Cannot revert after markup begins (except new range)

**Skips:**
- A â†’ C/D/E: Must progress through B (need secondary tests)
- B â†’ D/E: Must progress through C (need Spring test)
- C â†’ E: Must progress through D (need SOS breakout)

**Exceptions (AC 5, 9):**
- Any phase â†’ A: Allowed if new range detected
- C â†’ None: Allowed if range breakdown (failed accumulation)
- E â†’ A: Allowed when trend ends, new accumulation begins

**Phase History Tracking (AC 10):**

PhaseHistory stores complete progression:
```python
PhaseHistory {
    transitions: [
        PhaseTransition(None â†’ A, bar 10, "SC + AR detected"),
        PhaseTransition(A â†’ B, bar 15, "First ST detected"),
        PhaseTransition(B â†’ C, bar 30, "Spring detected"),
        ...
    ],
    current_phase: WyckoffPhase.C,
    range_id: "abc-123",
    started_at: "2024-03-01T00:00:00Z",
    updated_at: "2024-03-15T14:30:00Z"
}
```

**Benefits:**
- Debugging: Trace full progression history
- Validation: Verify transitions follow rules
- Analytics: Calculate time spent in each phase
- Visualization: Show progression timeline

### Wyckoff Context

**Phase Progression Principles:**
[Source: Wyckoff methodology and Epic 4 overview]

**Sequential Progression Requirement:**

Wyckoff methodology requires phases to progress sequentially because each phase represents specific market conditions and participant behavior:

**Phase A (Stopping Action):**
> "Selling Climax (SC) and Automatic Rally (AR) mark the preliminary end of the downtrend. This stopping action is the FIRST step in accumulation."

- **Why can't revert FROM Phase B:** Once secondary tests begin (Phase B), stopping action is complete. Cannot go back to stopping action without new range.
- **Why can't skip TO Phase C:** Phase B (cause building) is required. Spring tests in Phase C require accumulated cause from Phase B.

**Phase B (Building Cause):**
> "Secondary Tests build cause by oscillating between support (Creek) and resistance (Ice). The amount of cause built determines markup potential (Jump target)."

- **Why can't revert FROM Phase C:** Spring in Phase C is irreversible test. Once Spring occurs, cannot go back to building more cause.
- **Why can't skip TO Phase D:** Phase C (Spring test) is required to confirm accumulation complete before breakout.

**Phase C (Test):**
> "Spring penetrates below Creek to test supply. This final shakeout is the LAST test before markup. It's a one-time event."

- **Why can't revert FROM Phase D:** SOS breakout (Phase D) confirms markup has begun. Cannot go back to testing phase.
- **Why Phase C â†’ None is allowed:** Spring can fail if supply overwhelms demand (range breakdown, distribution pattern).

**Phase D (Sign of Strength):**
> "SOS breakout above Ice on high volume confirms demand is overwhelming supply. Markup has begun."

- **Why can't revert FROM Phase E:** Markup has begun, trend is underway. Cannot go back to testing or cause building without new range.

**Phase E (Markup):**
> "Sustained trend above Ice. LPS (Last Point of Support) pullbacks provide additional entries."

- **Why can transition TO Phase A:** Trend eventually ends, new accumulation can begin (new range, new Phase A).

**Exception Cases (AC 5, 9):**

**New Range Reset (AC 5):**
> "When a new trading range is detected, previous phase progression is invalidated. New range starts fresh accumulation cycle at Phase A."

**Range Breakdown (AC 9):**
> "If Spring fails and price breaks down below Creek decisively, accumulation has failed. This is a distribution pattern (transition to None or new range)."

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md#152-naming-conventions)]
- Python Classes: PascalCase (e.g., `PhaseTransition`, `PhaseHistory`)
- Python Functions: snake_case (e.g., `validate_phase_progression`, `add_phase_transition`, `get_transition_summary`)
- Python Variables: snake_case (e.g., `current_phase`, `new_phase`, `is_valid`, `rejection_reason`)
- Constants: UPPER_SNAKE_CASE (e.g., `VALID_TRANSITIONS`, `INVALID_TRANSITIONS_REASONS`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md#151-critical-fullstack-rules)]
- âœ… Use type hints: `def validate_phase_progression(current_phase: WyckoffPhase | None, new_phase: WyckoffPhase | None, context: Dict[str, Any] | None = None) -> Tuple[bool, str | None]:`
- âœ… Use Pydantic models (PhaseTransition, PhaseHistory)
- âœ… Use Enum for WyckoffPhase (from Story 4.4)
- âœ… Validate inputs with Pydantic validators

### Error Handling & Logging

**Error Handling Strategy:**
[Source: [architecture/16-error-handling-strategy.md](../../../docs/architecture/16-error-handling-strategy.md)]

**Input Validation:**
```python
def validate_phase_progression(current_phase, new_phase, context=None):
    # Validate inputs
    if current_phase is not None and not isinstance(current_phase, WyckoffPhase):
        raise ValueError(f"current_phase must be WyckoffPhase or None, got {type(current_phase)}")

    if new_phase is not None and not isinstance(new_phase, WyckoffPhase):
        raise ValueError(f"new_phase must be WyckoffPhase or None, got {type(new_phase)}")

    # ... validation logic
```

**Logging Strategy (AC 6):**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md) - structlog]

```python
import structlog

logger = structlog.get_logger(__name__)

# Valid transition (info level)
logger.info(
    "phase_transition_valid",
    current_phase=current_phase.value if current_phase else None,
    new_phase=new_phase.value if new_phase else None,
    bar_index=context.get("bar_index"),
    reason=context.get("reason")
)

# Invalid transition (warning level) - AC 6
logger.warning(
    "phase_transition_invalid",
    current_phase=current_phase.value if current_phase else None,
    new_phase=new_phase.value if new_phase else None,
    rejection_reason=rejection_reason,
    attempted_reason=context.get("reason")
)

# Reset event (info level)
logger.info(
    "phase_progression_reset",
    previous_phase=current_phase.value,
    new_phase="A",
    reset_reason=context.get("reset_reason")
)
```

**Correlation IDs:**
- Include correlation_id in context dict
- Bind correlation_id to logger for request tracing
- Enables tracking full phase progression across multiple bars

### Performance Requirements

**Performance Targets:**
- Single validation: <1ms (O(1) dict lookup)
- History update: <2ms (O(1) list append)
- Transition summary: <5ms for 100 transitions (O(n) iteration)
- No caching needed (operations already very fast)

**Complexity Analysis:**
- validate_phase_progression: O(1) - single dict lookup
- add_phase_transition: O(1) - list append
- get_transition_summary: O(n) - iterate transitions
- get_phase_duration: O(n) - iterate transitions for specific phase

### Integration Notes

**Story 4.4 Dependencies (Phase Classification Logic):**
[Source: Story 4.4]
- Story 4.4 provides `classify_phase()` that returns PhaseClassification
- Story 4.6 validates transitions between PhaseClassification results
- Integration flow:
  1. Story 4.4: Classify current phase based on events
  2. Story 4.6: Validate new phase against current phase
  3. If valid: Update phase, append to history
  4. If invalid: Reject, log warning, keep current phase

**Story 4.7 Dependencies (PhaseDetector Module Integration):**
[Source: Epic 4.7 AC]
- Story 4.7 will create unified PhaseDetector class
- PhaseDetector maintains PhaseHistory instance
- Before updating phase, PhaseDetector calls `enforce_phase_progression()`
- Example integration:
  ```python
  class PhaseDetector:
      def __init__(self):
          self.phase_history = PhaseHistory(...)

      def detect_phase(self, bars, events, trading_range):
          # Classify phase (Story 4.4)
          new_classification = classify_phase(events, trading_range)

          # Validate progression (Story 4.6)
          context = {
              "bar_index": len(bars),
              "reason": f"Events: {events}",
              "correlation_id": str(uuid.uuid4())
          }

          accepted, updated_history, rejection_reason = enforce_phase_progression(
              self.phase_history, new_classification, context
          )

          if accepted:
              self.phase_history = updated_history
              return new_classification
          else:
              logger.warning("phase_rejected", reason=rejection_reason)
              # Return current phase (no update)
              return self._get_current_classification()
  ```

**Epic 5 Dependencies (Pattern Detection):**
[Source: Epic 5 overview]
- Spring detection (Epic 5) triggers B â†’ C transition
- SOS detection (Epic 5) triggers C â†’ D transition
- LPS detection (Epic 5) signals Phase D/E
- Phase progression validation ensures patterns occur in correct sequence

**Epic 4 Workflow:**
```
Story 4.1: Detect SC â†’ SellingClimax âœ…
    â†“
Story 4.2: Detect AR â†’ AutomaticRally âœ…
    â†“
Story 4.3: Detect ST â†’ SecondaryTest âœ…
    â†“
Story 4.4: Classify Phase â†’ PhaseClassification âœ…
    â†“
Story 4.5: Phase Confidence â†’ Enhanced scoring (next)
    â†“
Story 4.6: Phase Progression â†’ Validation ðŸ“ THIS STORY
    â†“
Story 4.7: PhaseDetector â†’ Unified API (integrates Stories 4.1-4.6)
```

## Testing

### Test File Locations
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- Unit Tests: `backend/tests/unit/pattern_engine/test_phase_progression_validator.py` (create new)
- Integration Tests: `backend/tests/integration/pattern_engine/test_phase_progression_integration.py` (create new)

### Testing Framework
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- pytest 8.0+ for all Python testing
- pytest.mark.parametrize for testing multiple phase transitions
- pytest fixtures for PhaseHistory and PhaseTransition test data
- factory-boy for generating test events (if needed)

### Test Coverage Requirements
- Unit tests for all valid progressions (AC 1, 7)
- Unit tests for all invalid progressions (AC 2, 7)
- Unit tests for exception cases (AC 5, 9)
- Unit tests for phase history tracking (AC 10)
- Integration test for full Aâ†’Bâ†’Câ†’Dâ†’E sequence (AC 8)
- Integration test with invalid attempts mixed in
- Edge case tests (None transitions, same phase, rapid transitions)
- Coverage goal: >90% for phase_progression_validator.py

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../../docs/architecture/12-testing-strategy.md)]
- Unit tests: Test validation logic with synthetic phases
- Integration tests: Test full progression with PhaseClassification from Story 4.4
- Parametrized tests: Use pytest.mark.parametrize for testing all transitions
- Assertion messages: Clear failure messages explaining which transition failed
- Logging verification: Verify warning logs for invalid transitions (AC 6)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Initial story creation with comprehensive phase progression validation state machine, history tracking, and logging | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
- Model: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)
- Agent: James (Full Stack Developer)
- Date: 2025-10-31

### Debug Log References
No debugging required - implementation proceeded smoothly with all tests passing on first run after state machine fix.

### Completion Notes List
1. **State Machine Implementation**: Created VALID_TRANSITIONS map with proper forward-only progression (Aâ†’Bâ†’Câ†’Dâ†’E)
2. **Exception Handling**: Backward transitions (Bâ†’A, Câ†’A, Dâ†’A) only allowed with explicit context flags (new_range_detected, range_breakdown, trend_ended)
3. **Data Models**: Implemented PhaseTransition and PhaseHistory with full Pydantic validation
4. **Core Functions**:
   - validate_phase_progression: Core O(1) validation using state machine lookup
   - enforce_phase_progression: Wrapper for PhaseDetector integration
   - can_reset_to_phase_a: Exception handler for new range resets
5. **History Tracking**: Complete phase progression history with duration calculation and visualization
6. **Structured Logging**: All transitions logged with correlation IDs for debugging
7. **Testing**: 28 tests (20 unit + 8 integration) all passing
   - Valid progressions (Aâ†’Bâ†’Câ†’Dâ†’E)
   - Invalid reversions (Bâ†’A, Câ†’B, Dâ†’C)
   - Invalid skips (Aâ†’C, Bâ†’D, Câ†’E)
   - New range resets
   - Range breakdown scenarios
   - Full accumulation cycles
8. **Code Quality**: Passes mypy --strict and flake8 with 0 issues

### File List
**New Files Created:**
- [backend/src/pattern_engine/phase_progression_validator.py](../../../backend/src/pattern_engine/phase_progression_validator.py) - Core validator module with state machine
- [backend/tests/unit/pattern_engine/test_phase_progression_validator.py](../../../backend/tests/unit/pattern_engine/test_phase_progression_validator.py) - Unit tests (20 tests)
- [backend/tests/integration/pattern_engine/test_phase_progression_integration.py](../../../backend/tests/integration/pattern_engine/test_phase_progression_integration.py) - Integration tests (8 tests)

**Dependencies:**
- Uses WyckoffPhase and PhaseClassification from [backend/src/models/phase_classification.py](../../../backend/src/models/phase_classification.py) (Story 4.4)

## QA Results
_This section will be populated by the QA agent after story completion_
