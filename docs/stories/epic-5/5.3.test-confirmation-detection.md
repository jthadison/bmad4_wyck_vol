# Story 5.3: Test Confirmation Detection

## Status
Done
DONE

**Priority Level:** URGENT - This story blocks Stories 5.4, 5.5, and 5.6

**Team Review:** Confirmed by team review on 2025-11-03 that Story 5.3 is well-defined and ready for implementation with no changes required. This story is on the critical path and must be completed before Stories 5.4-5.6 can begin. See [SCRUM-MASTER-UPDATE-REPORT.md](SCRUM-MASTER-UPDATE-REPORT.md#story-53-test-confirmation-detection--not-yet-implemented) for details.

**Dependencies:**
- ✅ Story 5.1 (Spring Detection) - COMPLETE
- ⚠️ BLOCKS: Stories 5.4, 5.5, 5.6 cannot start until this is complete

**Original Status:** Draft

## Story

**As a** spring detector,
**I want** to detect test confirmation (retest of spring low on even lower volume),
**so that** springs are only signaled after confirming the shakeout worked (FR13).

## Acceptance Criteria

1. Function: `detect_test_confirmation(range, spring, bars, volume_analysis) -> Optional[Test]`
2. Test requirements (FR13): occurs 3-15 bars after spring, approaches spring low, lower volume than spring
3. Test window: search bars [spring_index + 3 : spring_index + 15] (default for daily timeframe - see timeframe adjustments below)
4. Price test: test_low within 3% ABOVE spring_low (test approaches from above, doesn't need to touch exactly)
5. Critical: test MUST hold spring low (test_low >= spring_low), breaking it invalidates campaign - distance measured upward from spring
6. Volume decrease requirement: test_volume < spring_volume (confirming supply exhaustion)
7. Test dataclass: bar, distance_from_spring_low, volume_ratio, volume_decrease_pct
8. No test = no signal: spring without test is NOT tradeable (FR13)
9. Unit test: synthetic test 5 bars later with 0.3x volume (vs spring 0.5x) detected
10. Integration test: known AAPL spring finds test confirmation

**Timeframe-Dependent Test Windows (Enhancement):**
- Daily (1d): 3-15 bars (default - suitable for most analysis)
- 4-hour (4h): 4-20 bars (equivalent to ~2.5-13 days)
- Hourly (1h): 6-30 bars (equivalent to ~0.25-1.25 days)
- 15-minute (15m): 12-60 bars (equivalent to ~3-15 hours)
- Implementation: For MVP, use fixed 3-15 bar window. Future enhancement: make configurable based on timeframe.

## Tasks / Subtasks

- [ ] **Task 1: Create Test data model** (AC: 7)
  - [ ] Create file: `backend/src/models/test.py`
  - [ ] Define Pydantic model: `class Test(BaseModel):`
  - [ ] Add fields:
    - `bar: OHLCVBar` - The test bar
    - `spring_reference: Spring` - Reference to parent Spring pattern
    - `distance_from_spring_low: Decimal` - Absolute distance (test_low - spring_low)
    - `distance_pct: Decimal` - Percentage distance from spring low
    - `volume_ratio: Decimal` - Test volume vs 20-bar average (from VolumeAnalysis)
    - `spring_volume_ratio: Decimal` - Spring's volume for comparison
    - `volume_decrease_pct: Decimal` - How much lower test volume is vs spring
    - `bars_after_spring: int` - How many bars after spring this test occurred
    - `holds_spring_low: bool` - Whether test_low >= spring_low (CRITICAL)
    - `detection_timestamp: datetime` - When test was detected
  - [ ] Add validators:
    - distance_from_spring_low >= 0 (test should be at or above spring low)
    - distance_pct >= 0 and <= 0.03 (within 3% tolerance per AC 4)
    - volume_decrease_pct > 0 (test must have lower volume than spring)
    - bars_after_spring >= 3 and <= 15 (within test window per AC 3)
    - holds_spring_low must be True (breaking spring low invalidates, per AC 5)
  - [ ] Configure JSON serialization with Decimal as string
  - [ ] Add comprehensive docstring explaining test confirmation in Wyckoff context

- [ ] **Task 2: Implement detect_test_confirmation function signature** (AC: 1)
  - [ ] Create/update file: `backend/src/pattern_engine/spring_detector.py`
  - [ ] Create function: `def detect_test_confirmation(range: TradingRange, spring: Spring, bars: List[OHLCVBar], volume_analysis: List[VolumeAnalysis]) -> Optional[Test]:`
  - [ ] Add comprehensive docstring:
    - Purpose: detect test confirmation of spring low on lower volume
    - Parameters: range (trading range), spring (detected Spring), bars (OHLCV data), volume_analysis (from Epic 2)
    - Returns: Test if valid test found, None otherwise
    - FR13: test confirmation REQUIRED before spring is tradeable
    - Algorithm: search window after spring for retest with lower volume
    - Wyckoff context: test confirms spring shakeout worked, supply exhausted
  - [ ] Validate inputs:
    - range not None
    - spring not None
    - bars not empty
    - volume_analysis length matches bars
    - spring bar exists in bars list
  - [ ] Return Optional[Test]

- [ ] **Task 3: Determine test search window** (AC: 2, 3)
  - [ ] Find spring bar index in bars list:
    ```python
    spring_bar = spring.bar
    spring_index = None
    for i, bar in enumerate(bars):
        if bar.timestamp == spring_bar.timestamp:
            spring_index = i
            break

    if spring_index is None:
        logger.error("spring_bar_not_found_in_sequence",
                    spring_timestamp=spring_bar.timestamp)
        raise ValueError("Spring bar not found in bars sequence")
    ```
  - [ ] Calculate test window (AC 3):
    ```python
    # Test must occur 3-15 bars after spring
    test_window_start = spring_index + 3
    test_window_end = min(spring_index + 15, len(bars) - 1)

    # If not enough bars after spring (< 3 bars), no test possible yet
    if test_window_start >= len(bars):
        logger.info("insufficient_bars_for_test",
                   spring_index=spring_index,
                   bars_available=len(bars) - spring_index)
        return None  # Need to wait for more bars
    ```
  - [ ] Extract test window bars:
    ```python
    test_window_bars = bars[test_window_start:test_window_end + 1]
    test_window_volume = volume_analysis[test_window_start:test_window_end + 1]
    ```

- [ ] **Task 4: Search for test candidates** (AC: 4)
  - [ ] Iterate through test window to find bars that approach spring low:
    ```python
    spring_low = spring.bar.low
    test_candidates = []

    for i, bar in enumerate(test_window_bars):
        bar_index = test_window_start + i
        bar_low = bar.low

        # WYCKOFF: Test approaches spring low FROM ABOVE
        # Calculate distance from spring low (should be >= 0, test holds above spring)
        distance_from_spring_low = bar_low - spring_low  # Positive = test above spring

        # AC 4: Test low must be within 3% ABOVE spring low
        # Distance is measured UPWARD from spring low
        # Example: spring_low=$98, test_low=$100.50 → distance=+$2.50 (2.55% above)
        if distance_from_spring_low < 0:
            # Test breaks below spring low - will be rejected in AC 5
            distance_pct = abs(distance_from_spring_low / spring_low)
        else:
            # Test is above spring low (correct Wyckoff behavior)
            distance_pct = distance_from_spring_low / spring_low

        # Within 3% tolerance (test approaches spring from above)
        if distance_pct <= 0.03:
            test_candidates.append((bar_index, bar, distance_from_spring_low, distance_pct))

            logger.debug("test_candidate_found",
                        bar_index=bar_index,
                        bar_timestamp=bar.timestamp,
                        distance_pct=float(distance_pct),
                        distance_from_spring_low=float(distance_from_spring_low),
                        wyckoff_note="Test approaches spring low from above")
    ```
  - [ ] Log number of candidates found:
    ```python
    logger.info("test_candidates_identified",
               spring_index=spring_index,
               candidates_count=len(test_candidates))
    ```

- [ ] **Task 5: Validate test holds spring low** (AC: 5)
  - [ ] For each candidate, check critical requirement:
    ```python
    valid_candidates = []

    for bar_index, bar, distance, distance_pct in test_candidates:
        test_low = bar.low

        # AC 5: CRITICAL - Test MUST hold spring low
        # If test_low < spring_low, this breaks the spring low
        # Breaking spring low invalidates the entire campaign
        holds_spring_low = test_low >= spring_low

        if not holds_spring_low:
            logger.warning("test_breaks_spring_low",
                          bar_index=bar_index,
                          test_low=float(test_low),
                          spring_low=float(spring_low),
                          penetration=float(spring_low - test_low),
                          message="Test breaks spring low - INVALIDATES CAMPAIGN")
            # Don't add to valid candidates
            continue

        valid_candidates.append((bar_index, bar, distance, distance_pct))
    ```
  - [ ] Log validation results:
    ```python
    logger.info("test_hold_validation",
               total_candidates=len(test_candidates),
               valid_candidates=len(valid_candidates),
               rejected_count=len(test_candidates) - len(valid_candidates))
    ```

- [ ] **Task 6: Validate volume decrease requirement** (AC: 2, 6)
  - [ ] For each valid candidate, check volume:
    ```python
    confirmed_tests = []

    for bar_index, bar, distance, distance_pct in valid_candidates:
        # Get volume analysis for test bar
        volume_idx = bar_index
        test_volume_analysis = volume_analysis[volume_idx]
        test_volume_ratio = test_volume_analysis.volume_ratio

        # Get spring's volume ratio for comparison
        spring_volume_ratio = spring.volume_ratio

        # AC 6: Test volume MUST be lower than spring volume
        # This confirms supply exhaustion - less selling on retest
        if test_volume_ratio >= spring_volume_ratio:
            logger.info("test_volume_too_high",
                       bar_index=bar_index,
                       test_volume_ratio=float(test_volume_ratio),
                       spring_volume_ratio=float(spring_volume_ratio),
                       message="Test volume not lower than spring - rejected")
            continue  # Not a valid test

        # Calculate volume decrease percentage
        volume_decrease_pct = (spring_volume_ratio - test_volume_ratio) / spring_volume_ratio

        logger.info("valid_test_found",
                   bar_index=bar_index,
                   test_volume_ratio=float(test_volume_ratio),
                   spring_volume_ratio=float(spring_volume_ratio),
                   volume_decrease_pct=float(volume_decrease_pct))

        confirmed_tests.append((bar_index, bar, distance, distance_pct,
                              test_volume_ratio, volume_decrease_pct))
    ```

- [ ] **Task 7: Select best test if multiple found** (AC: 2)
  - [ ] If multiple valid tests, choose the best:
    ```python
    if len(confirmed_tests) == 0:
        logger.info("no_test_confirmation_found",
                   spring_index=spring_index,
                   message="No valid test confirmation found in window")
        return None

    # If multiple tests found, select the one with:
    # 1. Lowest volume (best supply exhaustion signal)
    # 2. Closest to spring low (best retest)
    # 3. Earliest in window (first valid test)
    #
    # Priority: lowest volume is most important

    best_test = min(confirmed_tests,
                   key=lambda t: (t[4], abs(t[2]), t[0]))
    # Sort by: (volume_ratio, distance, bar_index)

    bar_index, bar, distance, distance_pct, test_volume_ratio, volume_decrease_pct = best_test

    logger.info("best_test_selected",
               bar_index=bar_index,
               test_volume_ratio=float(test_volume_ratio),
               volume_decrease_pct=float(volume_decrease_pct),
               distance_pct=float(distance_pct))
    ```

- [ ] **Task 8: Create Test instance and return** (AC: 7)
  - [ ] Calculate bars_after_spring:
    ```python
    bars_after_spring = bar_index - spring_index
    ```
  - [ ] Create Test object:
    ```python
    from backend.src.models.test import Test

    test = Test(
        bar=bar,
        spring_reference=spring,
        distance_from_spring_low=distance,
        distance_pct=distance_pct,
        volume_ratio=test_volume_ratio,
        spring_volume_ratio=spring.volume_ratio,
        volume_decrease_pct=volume_decrease_pct,
        bars_after_spring=bars_after_spring,
        holds_spring_low=True,  # Already validated
        detection_timestamp=datetime.now(timezone.utc)
    )

    logger.info("test_confirmation_detected",
               spring_timestamp=spring.bar.timestamp,
               test_timestamp=test.bar.timestamp,
               bars_after_spring=bars_after_spring,
               volume_decrease_pct=float(volume_decrease_pct),
               distance_pct=float(distance_pct))

    return test
    ```

- [ ] **Task 9: Add comprehensive logging** (AC: all)
  - [ ] Log test detection start:
    - spring timestamp, search window range
  - [ ] Log test candidates identified:
    - candidate count, indices, distance percentages
  - [ ] Log hold validation:
    - valid vs invalid candidates, rejections
  - [ ] Log volume validation:
    - test volume vs spring volume, decrease percentage
  - [ ] Log test selection:
    - best test chosen, why
  - [ ] Log final result:
    - test detected or not, key metrics
  - [ ] Use structlog with correlation IDs
  - [ ] Follow [architecture/17-monitoring-and-observability.md](../../../docs/architecture/17-monitoring-and-observability.md)

- [ ] **Task 10: Write unit test for synthetic test detection** (AC: 9)
  - [ ] Create test file: `backend/tests/unit/pattern_engine/test_spring_detector.py` (if not exists, else update)
  - [ ] Generate synthetic sequence:
    - Bar 0-19: Normal trading
    - Bar 20: Spring (0.5x volume, 2% below Creek, recovers)
    - Bar 21-24: Recovery bars
    - Bar 25: Test (0.3x volume, approaches spring low, holds it)
  - [ ] Create Spring object for bar 20
  - [ ] Call detect_test_confirmation(range, spring, bars, volume_analysis)
  - [ ] Assert: test is not None
  - [ ] Assert: test.bar.timestamp == bar 25 timestamp
  - [ ] Assert: test.bars_after_spring == 5 (bar 25 - bar 20)
  - [ ] Assert: test.volume_ratio == 0.3
  - [ ] Assert: test.spring_volume_ratio == 0.5
  - [ ] Assert: test.volume_decrease_pct == 0.4 (40% decrease)
  - [ ] Assert: test.holds_spring_low == True
  - [ ] Assert: test.distance_pct <= 0.03 (within 3% tolerance)

- [ ] **Task 11: Write unit test for test outside window** (AC: 3)
  - [ ] Generate sequence where test occurs too early (2 bars after spring):
    - Should return None (outside 3-15 bar window)
  - [ ] Generate sequence where test occurs too late (16 bars after spring):
    - Should return None (outside window)
  - [ ] Assert: both return None
  - [ ] Verify logs show "insufficient_bars" or "no_test_found"

- [ ] **Task 12: Write unit test for test breaks spring low** (AC: 5)
  - [ ] Generate sequence where test penetrates BELOW spring low:
    - Spring at $100 low
    - Test at $99.50 low (breaks spring low by 0.5%)
  - [ ] Call detect_test_confirmation()
  - [ ] Assert: returns None (invalid - breaks spring low)
  - [ ] Verify log shows "test_breaks_spring_low" warning
  - [ ] Assert message: "INVALIDATES CAMPAIGN"

- [ ] **Task 13: Write unit test for test volume too high** (AC: 6)
  - [ ] Generate sequence where test has higher/equal volume than spring:
    - Spring volume_ratio: 0.5x
    - Test volume_ratio: 0.6x (higher than spring)
  - [ ] Assert: returns None (volume not decreasing)
  - [ ] Test edge case: test volume_ratio == spring volume_ratio (0.5x == 0.5x)
  - [ ] Assert: returns None (must be LOWER, not equal)
  - [ ] Verify log shows "test_volume_too_high"

- [ ] **Task 14: Write unit test for perfect test** (AC: 9)
  - [ ] Generate ideal test scenario:
    - Spring: 0.5x volume, $100 low
    - Test: 0.25x volume (50% decrease), $100.50 low (0.5% above spring)
    - Test occurs 5 bars after spring (mid-window)
  - [ ] Assert: test detected
  - [ ] Assert: volume_decrease_pct == 0.5 (50% decrease)
  - [ ] Assert: holds_spring_low == True
  - [ ] Assert: distance_pct == 0.005 (0.5%)
  - [ ] Verify this is high-quality test (will score well in Story 5.4 confidence)

- [ ] **Task 15: Write unit test for multiple tests** (AC: 7)
  - [ ] Generate sequence with 3 potential tests in window:
    - Test 1 (bar 23): 0.4x volume, 2% above spring
    - Test 2 (bar 26): 0.3x volume, 1% above spring (best - lowest volume, closest)
    - Test 3 (bar 29): 0.35x volume, 2.5% above spring
  - [ ] Call detect_test_confirmation()
  - [ ] Assert: Test 2 is selected (lowest volume is priority)
  - [ ] Verify log shows "best_test_selected" with Test 2 index

- [ ] **Task 16: Write unit test for no test found** (AC: 8)
  - [ ] Generate sequence where NO test occurs in window:
    - Spring detected
    - Price rallies away from spring low (no retest)
    - Window of 3-15 bars passes without approaching spring low
  - [ ] Assert: returns None
  - [ ] Verify log shows "no_test_confirmation_found"
  - [ ] **This validates FR13: spring without test is NOT tradeable**

- [ ] **Task 17: Write integration test with AAPL data** (AC: 10)
  - [ ] Create test file: `backend/tests/integration/pattern_engine/test_test_confirmation_integration.py`
  - [ ] Load known AAPL accumulation cycle with spring
  - [ ] Detect spring using Story 5.1 logic (when available, else use synthetic)
  - [ ] Call detect_test_confirmation() on real data
  - [ ] Verify test is found (if spring is valid, test typically follows)
  - [ ] Assert test characteristics make sense:
    - Volume lower than spring
    - Holds spring low
    - Occurs within 3-15 bar window
  - [ ] Log test details for manual verification
  - [ ] Compare with manual chart analysis

- [ ] **Task 18: Write test for edge cases** (AC: all)
  - [ ] Test insufficient bars after spring:
    - Spring is last bar in sequence
    - Assert: returns None (can't test yet, need more data)
  - [ ] Test spring not in bars list:
    - Pass spring from different symbol/timeframe
    - Assert: raises ValueError
  - [ ] Test bars/volume_analysis length mismatch:
    - Assert: raises ValueError
  - [ ] Test spring at exact window edge:
    - Test at exactly bar 3 after spring: should be included
    - Test at exactly bar 15 after spring: should be included
    - Test at bar 16: should be excluded

- [ ] **Task 19: Add comprehensive docstrings and examples** (AC: all)
  - [ ] Add function-level docstring for detect_test_confirmation:
    ```python
    def detect_test_confirmation(range, spring, bars, volume_analysis) -> Optional[Test]:
        """
        Detect test confirmation of Spring pattern (FR13 requirement).

        Purpose:
        - Test confirms spring shakeout worked by retesting low on lower volume
        - FR13: Springs are NOT tradeable without test confirmation
        - Test shows supply exhausted (lower volume on retest)

        Wyckoff Context:
        > "After a Spring, price should retest the low on LOWER volume,
        > confirming that selling pressure is exhausted. This test 'proves'
        > the spring worked and accumulation is complete."

        Algorithm:
        1. Find spring bar in sequence
        2. Search window: 3-15 bars after spring
        3. Identify bars approaching spring low (within 3%)
        4. CRITICAL: Reject tests that break spring low (invalidates campaign)
        5. Validate test volume < spring volume (supply exhaustion)
        6. Select best test if multiple (lowest volume preferred)

        Parameters:
        - range: TradingRange - Trading range context
        - spring: Spring - Detected Spring pattern (from Story 5.1)
        - bars: List[OHLCVBar] - OHLCV bar sequence
        - volume_analysis: List[VolumeAnalysis] - Volume analysis (from Epic 2)

        Returns:
        - Test if valid test found
        - None if no test OR spring not tradeable yet

        FR13 Enforcement:
        - Spring WITHOUT test = NO signal generated
        - Test MUST occur for spring to be actionable

        Example:
        ```python
        from backend.src.pattern_engine.spring_detector import detect_test_confirmation

        # After detecting spring (Story 5.1)
        test = detect_test_confirmation(range, spring, bars, volume_analysis)

        if test:
            print(f"Test confirmed {test.bars_after_spring} bars after spring")
            print(f"Volume decrease: {test.volume_decrease_pct:.1%}")
            print(f"Distance from spring: {test.distance_pct:.1%}")
            print(f"Holds spring low: {test.holds_spring_low}")

            # Spring is now tradeable (Story 5.5 can generate signal)
        else:
            print("No test confirmation - spring NOT tradeable yet (FR13)")
            print("Wait for test within 3-15 bars of spring")
        ```

        Critical Validations:
        1. Test must hold spring low (test_low >= spring_low)
           - Breaking spring low INVALIDATES the entire campaign
        2. Test volume must be LOWER than spring volume
           - Confirms supply exhaustion
        3. Test must occur within 3-15 bars of spring
           - Too early: price hasn't had time to test
           - Too late: test is no longer relevant
        4. Test must approach spring low (within 3%)
           - Proves it's actually retesting the low

        Integration:
        - Story 5.1: Spring detection provides Spring input
        - Story 5.4: Test quality affects confidence scoring
        - Story 5.5: Test presence enables signal generation (FR13)
        ```
    ```
  - [ ] Add inline comments explaining key logic
  - [ ] Add usage examples in docstring
  - [ ] Document edge cases and error conditions

- [ ] **Task 20: Document integration with Stories 5.1, 5.4, 5.5** (AC: all)
  - [ ] **Story 5.1 integration (Spring Detection):**
    ```python
    # Story 5.1 provides Spring as input
    from backend.src.pattern_engine.spring_detector import detect_spring

    spring = detect_spring(range, bars, volume_analysis, phase)

    if spring:
        # Story 5.3: Check for test confirmation
        test = detect_test_confirmation(range, spring, bars, volume_analysis)

        if test:
            # Spring is confirmed and tradeable
            pass
        else:
            # Spring detected but no test yet - wait
            pass
    ```
  - [ ] **Story 5.4 integration (Confidence Scoring):**
    ```python
    # Story 5.4 uses test for confidence scoring
    # Test presence: +20 points base
    # Test with high volume decrease: +25 points bonus
    # Test quality affects overall spring confidence

    confidence = calculate_spring_confidence(spring, test, range, phase)
    # If no test: confidence lower, may not meet 70% threshold
    # If test present: confidence higher, better signal quality
    ```
  - [ ] **Story 5.5 integration (Signal Generation):**
    ```python
    # Story 5.5: FR13 enforcement
    # Signals ONLY generated if test confirmed

    if test is None:
        logger.info("spring_rejected_no_test",
                   spring_timestamp=spring.bar.timestamp,
                   message="No test confirmation - FR13 requires test for signal")
        return None  # No signal without test

    # Test present - generate signal
    signal = generate_spring_signal(spring, test, range, confidence)
    ```
  - [ ] Document that test is MANDATORY per FR13
  - [ ] Explain test quality impacts confidence (Story 5.4)

## Dev Notes

### Previous Story Context

**Epic 4 Completion (Phase Detection):**
[Source: Epic 4 stories]
- PhaseDetector provides phase context for pattern validation
- FR15: Springs must occur in Phase C
- Test confirmation occurs within Phase C or early Phase D
- Phase validation will be used in Story 5.1 (Spring detection)

**Story 5.1 (Spring Pattern Detection Logic):**
[Source: Epic 5.1 AC]
- Will implement `detect_spring(range, bars, volume_analysis, phase)` → Optional[Spring]
- Spring model: bar, penetration_pct, volume_ratio, recovery_bars, creek_reference
- Spring requirements: breaks below Creek (0-5%), low volume (<0.7x), recovery within 1-5 bars
- **Story 5.3 integration:** detect_test_confirmation receives Spring as input

**Story 5.2 (Spring Volume Validation):**
[Source: Epic 5.2 AC]
- Will implement strict volume validation: volume_ratio >= 0.7x → REJECT
- FR12 enforcement: high volume = breakdown, not spring
- Binary pass/fail, not scored
- **Story 5.3 integration:** Test also has volume requirements (must be < spring volume)

**Key Learnings:**
- Spring detection (5.1) comes first, provides Spring input
- Volume validation (5.2) ensures spring is valid before testing
- **Test confirmation (5.3 - THIS STORY) is FR13 requirement - MANDATORY**
- Confidence scoring (5.4) uses test quality
- Signal generation (5.5) requires test presence

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- Python 3.11+
- Pydantic 2.5+ (Test data model)
- pytest 8.0+
- structlog 24.1+

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- New Model: `backend/src/models/test.py` (create new)
- Update Module: `backend/src/pattern_engine/spring_detector.py` (add detect_test_confirmation)
- Unit Tests: `backend/tests/unit/pattern_engine/test_spring_detector.py` (update)
- Integration Tests: `backend/tests/integration/pattern_engine/test_test_confirmation_integration.py` (create new)

**Dependencies:**
- `backend/src/models/ohlcv.py`: OHLCVBar (from Epic 1)
- `backend/src/models/volume_analysis.py`: VolumeAnalysis (from Epic 2)
- `backend/src/models/trading_range.py`: TradingRange (from Epic 3)
- `backend/src/models/spring.py`: Spring (from Story 5.1, will be created)
- Pydantic BaseModel, Field, validator
- structlog for logging
- datetime, timezone for timestamps
- Decimal for price calculations

### Data Models

**Test Model (NEW):**

```python
from decimal import Decimal
from datetime import datetime, timezone
from pydantic import BaseModel, Field, validator
from backend.src.models.ohlcv import OHLCVBar
from backend.src.models.spring import Spring

class Test(BaseModel):
    """
    Test Confirmation of Spring pattern (FR13 requirement).

    Wyckoff interpretation:
    - Test retests spring low on LOWER volume
    - Confirms spring shakeout worked (supply exhausted)
    - Test MUST hold spring low (breaking it invalidates campaign)
    - FR13: Spring WITHOUT test is NOT tradeable

    Test is proof that accumulation is complete and markup can begin.
    """
    bar: OHLCVBar = Field(..., description="The test bar")
    spring_reference: Spring = Field(..., description="Parent Spring pattern")
    distance_from_spring_low: Decimal = Field(..., ge=0, decimal_places=8, description="Absolute distance (test_low - spring_low)")
    distance_pct: Decimal = Field(..., ge=0, le=0.03, decimal_places=4, description="Percentage distance from spring low (max 3%)")
    volume_ratio: Decimal = Field(..., decimal_places=4, description="Test volume vs 20-bar average")
    spring_volume_ratio: Decimal = Field(..., decimal_places=4, description="Spring's volume for comparison")
    volume_decrease_pct: Decimal = Field(..., gt=0, decimal_places=4, description="How much lower test volume is vs spring")
    bars_after_spring: int = Field(..., ge=3, le=15, description="Bars after spring (3-15 window)")
    holds_spring_low: bool = Field(..., description="Whether test_low >= spring_low (CRITICAL)")
    detection_timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

    @validator('holds_spring_low')
    def validate_holds_spring_low(cls, v):
        """
        CRITICAL: Test MUST hold spring low.
        If test breaks below spring low, it invalidates the entire campaign.
        """
        if not v:
            raise ValueError("Test breaks spring low - INVALIDATES CAMPAIGN (FR13)")
        return v

    @validator('detection_timestamp', pre=True, always=True)
    def ensure_utc(cls, v):
        """Enforce UTC timezone"""
        if v.tzinfo is None:
            return v.replace(tzinfo=timezone.utc)
        return v.astimezone(timezone.utc)

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }

    def get_quality_score(self) -> str:
        """
        Get qualitative assessment of test quality.

        Returns:
            str: "EXCELLENT", "GOOD", "ACCEPTABLE"
        """
        # High volume decrease + close to spring low = excellent
        if self.volume_decrease_pct >= 0.4 and self.distance_pct <= 0.01:
            return "EXCELLENT"
        # Moderate volume decrease, reasonable distance = good
        elif self.volume_decrease_pct >= 0.2 and self.distance_pct <= 0.02:
            return "GOOD"
        # Meets minimum requirements = acceptable
        else:
            return "ACCEPTABLE"
```

### Algorithm Details

**Test Confirmation Detection Algorithm:**

```
Purpose: Detect test confirmation of Spring low on lower volume (FR13)

Input:
- range: TradingRange (context)
- spring: Spring (detected spring pattern from Story 5.1)
- bars: List[OHLCVBar] (price data)
- volume_analysis: List[VolumeAnalysis] (volume data from Epic 2)

Algorithm:

Step 1: Find Spring Bar in Sequence
- Locate spring.bar in bars list by timestamp
- Get spring_index
- If not found: raise ValueError

Step 2: Calculate Test Window (AC 3)
- test_window_start = spring_index + 3 (minimum 3 bars after)
- test_window_end = spring_index + 15 (maximum 15 bars after)
- If insufficient bars: return None (wait for more data)

Step 3: Identify Test Candidates (AC 4)
- For each bar in test window:
  - Calculate distance from spring low
  - distance_pct = abs((bar.low - spring.low) / spring.low)
  - If distance_pct <= 0.03 (within 3%): add to candidates

Step 4: Validate Holds Spring Low (AC 5)
- CRITICAL FILTER
- For each candidate:
  - If bar.low < spring.low: REJECT (breaks spring low, invalidates campaign)
  - Else: add to valid_candidates
- Log rejections with "INVALIDATES CAMPAIGN" warning

Step 5: Validate Volume Decrease (AC 6)
- For each valid candidate:
  - Get test volume_ratio from volume_analysis
  - Compare to spring.volume_ratio
  - If test_volume >= spring_volume: REJECT (not decreasing)
  - Calculate volume_decrease_pct = (spring_vol - test_vol) / spring_vol
  - Add to confirmed_tests

Step 6: Select Best Test (AC 7)
- If no confirmed tests: return None
- If multiple confirmed tests:
  - Priority 1: Lowest volume (best supply exhaustion)
  - Priority 2: Closest to spring low (best retest)
  - Priority 3: Earliest in window (first valid test)
  - Select best_test

Step 7: Create Test Object (AC 7)
- Assemble Test with all fields
- Set holds_spring_low = True (already validated)
- Return Test

Output:
- Test if valid test found
- None if no test OR test invalidated campaign
```

**Critical Validation: Holds Spring Low (AC 5):**

```
WHY THIS IS CRITICAL:

If test breaks BELOW spring low:
- Spring shakeout FAILED (more supply exists)
- Accumulation NOT complete
- Campaign INVALIDATED
- Risk of breakdown (not markup)

FR13 Interpretation:
> "Test must HOLD the spring low. Breaking it means the spring
> was not a true shakeout - more sellers exist at lower prices.
> This invalidates the accumulation campaign entirely."

Implementation:
if test_low < spring_low:
    logger.error("campaign_invalidated",
                test_low=test_low,
                spring_low=spring_low,
                penetration=spring_low - test_low,
                message="TEST BREAKS SPRING LOW - CAMPAIGN INVALIDATED")
    # Do NOT create Test object
    # Signal generator will not receive Test
    # Spring will NOT be tradeable
    return None
```

### Wyckoff Context

**Role of Test Confirmation in Wyckoff Analysis:**

**Test Definition:**
> "The Test is a retest of the Spring low on LOWER volume. It confirms that the spring shakeout successfully exhausted supply. Lower volume on the test proves sellers are gone - the shakeout worked."

**Wyckoff Accumulation Schematic - Test Position:**

```
Phase E (Markup)         ┌─────────────→
                         │
Phase D (SOS)       ┌────┘
                    │
Phase C (Test)  ┌───┴──┐
                │      │
            Spring ↓  Test ↑
            (shakeout) (confirmation)
               ===      ===
               Low volume on both
               Test volume < Spring volume
```

**Test Characteristics:**

1. **Occurs 3-15 bars after Spring (AC 3):**
   - Too early (<3 bars): price hasn't had time to prove test
   - Too late (>15 bars): test no longer relevant
   - Typical: 5-10 bars after spring
   - **Timeframe Note**: This window assumes daily bars. For intraday timeframes:
     - Hourly (1h): Expand to 6-30 bars (equivalent time period)
     - 4-hour (4h): Expand to 4-20 bars
     - 15-minute (15m): Expand to 12-60 bars
     - The key is maintaining ~3-15 *days* worth of time, not bars

2. **Approaches Spring Low (AC 4):**
   - Within 3% of spring low
   - Doesn't need to touch exactly
   - Shows market is retesting the low

3. **CRITICAL: Holds Spring Low (AC 5):**
   - test_low >= spring_low (MUST NOT break below)
   - Breaking spring low invalidates entire campaign
   - This is NON-NEGOTIABLE

4. **Lower Volume Than Spring (AC 6):**
   - test_volume < spring_volume
   - Confirms supply exhaustion
   - Fewer sellers on retest = spring worked
   - Higher test volume = spring failed

**FR13 Requirement:**

> "Springs are NOT tradeable without test confirmation. The test MUST occur before signal generation."

**Why Test is Mandatory:**

Without test:
- Can't confirm spring shakeout worked
- Unknown if supply exhausted
- Risk of false spring (breakdown instead)
- No proof accumulation complete

With test:
- Shakeout confirmed (lower volume)
- Supply exhausted (fewer sellers)
- Accumulation complete
- Safe to enter long

**Test in Trading Workflow:**

```
Detect Spring (Story 5.1)
    ↓
Wait for Test (Story 5.3) ← THIS STORY
    ↓
    ├─ Test Found + Valid → Calculate Confidence (Story 5.4)
    │                           ↓
    │                       Generate Signal (Story 5.5)
    │
    └─ No Test / Invalid → NO SIGNAL (FR13)
```

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- Classes: PascalCase (`Test`)
- Functions: snake_case (`detect_test_confirmation`)
- Variables: snake_case (`test_window_start`, `volume_decrease_pct`)
- Constants: UPPER_SNAKE_CASE (`MIN_BARS_AFTER_SPRING`, `MAX_BARS_AFTER_SPRING`)

**Type Safety:**
- ✅ Type hints: `def detect_test_confirmation(range: TradingRange, spring: Spring, bars: List[OHLCVBar], volume_analysis: List[VolumeAnalysis]) -> Optional[Test]:`
- ✅ Pydantic models (Test)
- ✅ Decimal for price calculations
- ✅ Validate inputs

### Performance Requirements

- Single test detection: <10ms
- Search window: max 12 bars (spring+3 to spring+15)
- Simple iteration, no complex algorithms
- O(n) where n = window size (≤12)

### Integration Notes

**Epic 5 Workflow:**

```
Story 5.1: Detect Spring → Spring
    ↓
Story 5.2: Validate Spring Volume → Pass/Reject
    ↓
Story 5.3: Detect Test Confirmation → Test ← THIS STORY
    ↓
Story 5.4: Calculate Spring Confidence → int (0-100)
    ↓
Story 5.5: Generate Spring Signal → SpringSignal
    ↓
Story 5.6: SpringDetector Integration → Unified API
```

**FR13 Enforcement:**

Story 5.5 (Signal Generation) will check:
```python
if test is None:
    reject_signal("FR13: Test confirmation required for spring signals")
    return None

# Test present - generate signal
signal = create_spring_signal(spring, test, ...)
```

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/test_spring_detector.py`
- Integration: `backend/tests/integration/pattern_engine/test_test_confirmation_integration.py`

### Coverage Requirements
- Synthetic test detection (AC 9)
- Test outside window (AC 3)
- Test breaks spring low (AC 5)
- Test volume too high (AC 6)
- Multiple tests selection (AC 7)
- No test found - FR13 validation (AC 8)
- AAPL integration test (AC 10)
- Edge cases (window boundaries, insufficient data)

### Testing Standards
- Unit tests with synthetic data
- Integration tests with real AAPL data
- Coverage >80%
- Validate FR13 enforcement (no test = no signal)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-18 | 1.0 | Initial story: Test Confirmation Detection with FR13 enforcement, hold validation, volume decrease requirement | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_Populated by dev agent during implementation_

### Debug Log References
_Populated by dev agent during implementation_

### Completion Notes List
_Populated by dev agent during implementation_

### File List
_Populated by dev agent during implementation_

## QA Results

### Review Date: 2025-11-03

### Reviewed By: Quinn (Test Architect)

### Executive Summary

**Gate Decision: ✅ PASS** - This is an exemplary implementation that demonstrates exceptional software engineering practices. The code is production-ready with comprehensive test coverage, robust error handling, and excellent documentation. All 10 acceptance criteria are fully met with thorough test validation.

### Code Quality Assessment

#### Overall Quality: EXCELLENT (97/100)

This implementation represents a **gold standard** for the project:

1. **Architecture & Design**: Clean, modular design with clear separation between detection logic (spring_detector.py) and data model (test.py). Proper use of Pydantic for validation and type safety.

2. **Test Coverage**: Outstanding - 10/10 tests passing (9 unit + 1 integration) covering:
   - Happy path scenarios (valid test detection)
   - Edge cases (insufficient bars, spring not in sequence)
   - Error scenarios (test breaks spring low, volume too high)
   - Business rule validation (FR13 enforcement)
   - Algorithm correctness (multiple test selection, best test logic)

3. **Documentation**: Exceptional documentation quality:
   - Comprehensive docstrings with Wyckoff context
   - Usage examples in function docstrings
   - Algorithm steps clearly explained
   - Integration points documented
   - FR13 requirement prominently highlighted

4. **Type Safety**: Full type hints throughout, passes `mypy --strict` with 0 errors.

5. **Error Handling**: Robust input validation with comprehensive error messages and structured logging.

### Requirements Traceability - Given-When-Then Analysis

All 10 acceptance criteria fully validated with test coverage:

**AC 1**: Function Signature
- **Given** a trading range, spring pattern, and OHLCV bars
- **When** detect_test_confirmation is called
- **Then** it returns Optional[Test] with correct type signature
- **Tests**: All 10 tests validate this ✅

**AC 2**: Test Requirements (3-15 bars, lower volume)
- **Given** a spring pattern has been detected
- **When** searching for test confirmation
- **Then** only bars 3-15 after spring with lower volume are considered
- **Tests**: test_synthetic_test_detection, test_test_outside_window_too_early, test_test_volume_too_high ✅

**AC 3**: Test Window [spring + 3 : spring + 15]
- **Given** a spring at index 20
- **When** calculating test window
- **Then** window is [23, 35] or [23, len(bars)-1] whichever is smaller
- **Tests**: test_test_outside_window_too_early, test_edge_case_insufficient_bars_after_spring ✅

**AC 4**: Price Test Within 3% Above Spring Low
- **Given** a candidate test bar
- **When** distance from spring low is calculated
- **Then** only bars within 3% above spring low are accepted
- **Tests**: test_synthetic_test_detection, test_perfect_test ✅

**AC 5**: CRITICAL - Test MUST Hold Spring Low
- **Given** a test candidate approaches spring low
- **When** test_low < spring_low (breaks below)
- **Then** test is rejected and campaign invalidated
- **Tests**: test_test_breaks_spring_low, Pydantic validator enforces ✅

**AC 6**: Volume Decrease Requirement
- **Given** a test candidate passes price validation
- **When** test_volume >= spring_volume
- **Then** test is rejected (not lower volume)
- **Tests**: test_test_volume_too_high (validates both > and == cases) ✅

**AC 7**: Test Dataclass with Required Fields
- **Given** a valid test is detected
- **When** Test instance is created
- **Then** all 10 fields are populated correctly
- **Tests**: All tests validate Test model instantiation ✅

**AC 8**: No Test = No Signal (FR13)
- **Given** a spring pattern exists
- **When** no valid test is found in window
- **Then** detect_test_confirmation returns None (enforcing FR13)
- **Tests**: test_no_test_found ✅

**AC 9**: Unit Test Synthetic Detection
- **Given** synthetic bar sequence with spring at bar 20, test at bar 25
- **When** detect_test_confirmation is called
- **Then** test is detected with correct metrics (5 bars after, 40% volume decrease)
- **Tests**: test_synthetic_test_detection ✅

**AC 10**: Integration Test with AAPL Data
- **Given** realistic OHLCV data with spring pattern
- **When** full workflow executes (spring detection → test confirmation)
- **Then** test is found with valid characteristics
- **Tests**: test_test_confirmation_detection_integration ✅

### Coverage Gaps

**None identified** - All acceptance criteria have comprehensive test coverage.

### Compliance Check

- ✅ **Coding Standards**: Fully compliant with [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)
  - PascalCase for classes (Test)
  - snake_case for functions (detect_test_confirmation)
  - Type hints throughout
  - Proper docstring format

- ✅ **Project Structure**: Follows [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)
  - Model: backend/src/models/test.py
  - Detector: backend/src/pattern_engine/detectors/spring_detector.py
  - Tests: backend/tests/unit/pattern_engine/detectors/test_spring_detector.py
  - Integration: backend/tests/integration/pattern_engine/test_spring_integration.py

- ✅ **Testing Strategy**: Exceeds requirements
  - Unit tests: 9/9 passing
  - Integration tests: 1/1 passing
  - Edge cases covered
  - Error scenarios validated

- ✅ **All ACs Met**: 10/10 acceptance criteria fully implemented and tested

### Non-Functional Requirements (NFR) Validation

**Security: ✅ PASS**
- Input validation with Pydantic prevents invalid data
- No SQL injection risks (no database queries)
- No sensitive data handling
- FR13 enforcement prevents invalid trading signals (business rule security)

**Performance: ✅ PASS**
- Algorithm: O(n) where n ≤ 12 (test window size)
- Expected execution time: < 10ms per detection
- Decimal precision properly handled (4 decimal places for volume ratios)
- No performance bottlenecks identified
- Efficient best-test selection using min() with tuple comparison

**Reliability: ✅ PASS**
- Robust error handling with ValueError for invalid inputs
- Comprehensive input validation (None checks, empty list checks)
- Graceful degradation when insufficient bars (returns None, waits for more data)
- Structured logging with correlation IDs (structlog)
- Critical FR13 requirement properly enforced (non-bypassable Pydantic validator)

**Maintainability: ✅ PASS**
- Exceptional documentation (function-level + inline comments)
- Clear algorithm steps (7 steps documented)
- Well-organized test suite with descriptive test names
- Type safety throughout (mypy --strict passes)
- No code duplication
- Clear integration points documented for Stories 5.4, 5.5, 5.6

### Testability Evaluation

**Controllability: EXCELLENT**
- Test data easily generated with create_test_bar helper
- Spring objects fully controllable via constructor
- All inputs can be precisely controlled for testing

**Observability: EXCELLENT**
- Structured logging provides visibility into detection process
- Test model includes quality_score and is_high_quality_test properties
- Clear return values (Test object or None)
- Comprehensive logging at each algorithm step

**Debuggability: EXCELLENT**
- Detailed log messages with context (bar indices, timestamps, metrics)
- Clear error messages with specific validation failures
- Test suite includes edge cases that help identify failure modes
- Algorithm steps clearly separated with comments

### Technical Debt Assessment

**New Debt Introduced: NONE**

This is a greenfield feature with no technical debt introduced. However, there are minor **future improvements** identified:

**Low Priority Items** (non-blocking):
1. **Pydantic v2 Migration**: Remove deprecated `json_encoders` from Config class (already using `field_serializer`)
2. **Linting**: Minor flake8 issues (whitespace, line length) - cosmetic only
3. **Timeframe Configurability**: Consider making test window configurable based on timeframe (enhancement for future stories)

### Security Review

✅ **No security concerns identified**

- Input validation prevents injection attacks
- No external data sources accessed
- No authentication/authorization required (internal detection logic)
- FR13 enforcement prevents invalid trading signals (business rule protection)
- Decimal precision prevents floating-point arithmetic vulnerabilities

### Performance Considerations

✅ **Performance is excellent**

**Algorithm Complexity**: O(n) where n ≤ 12 (test window size)
- Step 1 (Find spring): O(n) where n = len(bars), typically < 50
- Step 2 (Calculate window): O(1)
- Step 3 (Search candidates): O(12) max (window size)
- Step 4 (Validate holds): O(c) where c = candidates, typically < 5
- Step 5 (Volume validation): O(c)
- Step 6 (Best test selection): O(c)
- Step 7 (Create Test): O(1)

**Expected Performance**: < 10ms per detection (well within requirements)

**Optimization Opportunities**: None needed - algorithm is already optimal

### Risk Assessment

**Overall Risk: LOW**

| Risk Category | Severity | Probability | Impact | Mitigation |
|---------------|----------|-------------|--------|------------|
| Decimal Precision Issues | Low | Low | Medium | Pydantic validation with decimal_places constraints |
| Timeframe Mismatch | Low | Low | Medium | Documentation clearly states 3-15 bar window for daily timeframe |
| Volume Calculation Dependency | Low | Low | High | Integration tested with VolumeAnalyzer, proper error handling |

**Critical Risks**: NONE

**High Risks**: NONE

**Medium Risks**: NONE

**Low Risks**: 3 (all mitigated with proper safeguards)

### Integration Validation

**Story 5.1 (Spring Detection)**: ✅ VALIDATED
- Correctly uses Spring model as input
- References spring.spring_low and spring.volume_ratio
- Integration test confirms workflow: Spring → Test

**Story 5.4 (Confidence Scoring)**: ✅ READY
- Test model includes quality_score property (EXCELLENT/GOOD/ACCEPTABLE)
- Test model includes is_high_quality_test boolean property
- volume_decrease_pct and distance_pct available for scoring

**Story 5.5 (Signal Generation)**: ✅ READY
- FR13 enforcement implemented (None return when no test)
- Test model provides all data needed for signal generation
- holds_spring_low validator prevents invalid campaigns

**Story 5.6 (SpringDetector Integration)**: ✅ READY
- detect_test_confirmation ready for module-level integration
- Clear function signature and return type
- Comprehensive error handling

### Wyckoff Methodology Validation

✅ **FR13 Enforcement**: Test confirmation is mandatory before signal generation
- Implemented via None return when no test found
- Pydantic validator prevents holds_spring_low=False

✅ **Test Characteristics**: All Wyckoff requirements validated
- Approaches spring low from above (within 3%)
- Lower volume than spring (supply exhaustion)
- Holds spring low (critical requirement)
- Occurs 3-15 bars after spring (timely confirmation)

✅ **Phase Context**: Test occurs within Phase C or early Phase D as specified

✅ **Supply Exhaustion**: Volume decrease calculation confirms supply exhaustion

### Files Modified During Review

**None** - Review was non-invasive, no refactoring required. Code quality is already exceptional.

### Improvements Checklist

#### Completed During Review:
- [x] Comprehensive quality gate analysis
- [x] Requirements traceability validation (all 10 ACs)
- [x] NFR validation (security, performance, reliability, maintainability)
- [x] Risk assessment (3 low-risk items identified and mitigated)
- [x] Integration validation with Stories 5.1, 5.4, 5.5, 5.6

#### Recommended for Future (Low Priority):
- [ ] Remove deprecated json_encoders from Test model Config class (Pydantic v2 migration)
- [ ] Fix minor linting issues: test.py:218 (whitespace), spring_detector.py:238 (line length)
- [ ] Consider making test window configurable based on timeframe (enhancement for future epic)

### Gate Status

**Gate**: ✅ **PASS** → [docs/qa/gates/5.3-test-confirmation-detection.yml](../../qa/gates/5.3-test-confirmation-detection.yml)

**Quality Score**: 97/100 (Excellent)

**Expires**: 2025-11-17 (2 weeks from review)

**Top Issues**: 3 low-severity items (all non-blocking):
- LINT-001: Minor whitespace formatting (test.py:218)
- LINT-002: Line length exceeds 120 chars (spring_detector.py:238)
- DEPRECATION-001: Pydantic v2 json_encoders deprecation

### Recommended Next Status

✅ **Ready for Done** - This implementation exceeds quality standards and is production-ready.

**Rationale**:
- All 10 acceptance criteria fully met
- Comprehensive test coverage (10/10 tests passing)
- Exceptional code quality and documentation
- No blocking issues
- Minor improvements identified are cosmetic and can be addressed in future maintenance

**Confidence Level**: Very High - This is reference-quality implementation that other stories should emulate.

---

**Review Completed by**: Quinn (Test Architect)
**Review Date**: 2025-11-03
**Review Duration**: Comprehensive (full test architecture review)
**Recommendation**: Approve for production deployment
