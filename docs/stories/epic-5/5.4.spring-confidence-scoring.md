# Story 5.4: Spring Confidence Scoring

## Status
Done
**Ready for Development** - Team Review Recommendations APPLIED

**Last Updated:** 2025-11-03 (Scrum Master update - tasks aligned with AC)

**Team Review:** Team review on 2025-11-03 identified significant improvements to confidence scoring formula. Volume quality, penetration depth, and recovery speed weights increased. Spread narrowness and range quality removed. New volume trend and Creek strength bonuses added. See [SCRUM-MASTER-UPDATE-REPORT.md](SCRUM-MASTER-UPDATE-REPORT.md#story-54-spring-confidence-scoring--requires-updates) for complete details.

**Changes Summary:**
- Volume Quality: 30→40 points (↑ most important indicator)
- Penetration Depth: 10→35 points (↑ critical for spring quality)
- Recovery Speed: 15→25 points (↑ demand strength indicator)
- ❌ REMOVED: Spread narrowness (15 pts) - less reliable than volume/penetration
- ❌ REMOVED: Range quality (10 pts) - Creek strength more important
- ✅ NEW: Volume trend bonus (+10 pts) - declining volume from previous tests
- ✅ NEW: Creek strength bonus (+10 pts) - replaces phase bonus
- Test confirmation: 20 pts (no volume decrease bonus - use volume trend instead)
- Total possible: 120 points (capped at 100 for final score)

**Dependencies:**
- ✅ DEPENDENCY RESOLVED: Story 5.3 (Test Confirmation) is COMPLETE
- ⚠️ BLOCKS: Story 5.5 (Signal Generation) depends on updated confidence scoring

**Original Status:** Draft

## Story

**As a** spring detector,
**I want** to calculate confidence scores for spring patterns,
**so that** only high-quality springs (70%+ confidence) generate signals.

## Acceptance Criteria

**UPDATED BASED ON TEAM REVIEW (2025-11-03):**

1. Function: `calculate_spring_confidence(spring, creek, previous_tests=[]) -> SpringConfidence` returns dataclass with total_score 0-100
2. Volume quality (40 points max - UPDATED from 30): <0.3x = 40pts, 0.3-0.4x = 30pts, 0.4-0.5x = 20pts, 0.5-0.6x = 10pts, 0.6-0.69x = 5pts
3. ❌ REMOVED: Spread narrowness - less reliable indicator per team consensus
4. Recovery speed (25 points max - UPDATED from 15): 1 bar = 25pts, 2 bars = 20pts, 3 bars = 15pts, 4-5 bars = 10pts
5. Test confirmation (20 points - NO volume decrease bonus): test present = 20 pts (use volume trend bonus instead)
6. ❌ REMOVED: Range quality - Creek strength more important per team consensus
7. Penetration depth (35 points max - UPDATED from 10): 1-2% = 35pts, 2-3% = 25pts, 3-4% = 15pts, 4-5% = 5pts
8. Creek strength bonus (10 points max - REPLACES phase bonus): strength >=80 = 10pts, 70-79 = 7pts, 60-69 = 5pts, <60 = 0pts
9. Volume trend bonus (10 points max - NEW): declining volume from previous tests (20%+ decrease) = 10pts, stable (±20%) = 5pts, rising = 0pts
10. Total possible: 120 points with bonuses (capped at 100 for final score)
11. FR4 minimum: 70% confidence required for signal generation
12. Return SpringConfidence dataclass with: total_score, component_scores dict, quality_tier string

## Tasks / Subtasks

**✅ TASKS UPDATED (2025-11-03):** All tasks aligned with revised acceptance criteria based on team review.

**⚠️ CRITICAL DEVELOPER NOTE:**
The tasks below are being updated to reflect the new formula. **USE THE ACCEPTANCE CRITERIA (AC 1-12) AS YOUR PRIMARY SOURCE OF TRUTH** for implementation. The AC reflect the team-approved formula:
- Volume: 40pts (5 tiers)
- Penetration: 35pts (4 tiers)
- Recovery: 25pts (4 tiers)
- Test: 20pts (flat, no bonus)
- Creek Strength Bonus: +10pts (NEW)
- Volume Trend Bonus: +10pts (NEW)
- **REMOVED:** Spread, Range Quality, Phase Bonus
- **Function signature:** `calculate_spring_confidence(spring, creek, previous_tests=[]) -> SpringConfidence`
- **Return type:** SpringConfidence dataclass (not int)

**Implementation Guidance:** See SCRUM-MASTER-UPDATE-REPORT.md Section "Story 5.4" (lines 69-217) for complete code examples and Wyckoff context.

**Task List Status:** Tasks 1-20 are being rewritten to match the AC. If you encounter conflicts, **AC takes precedence over tasks**.

---

### **Task 1: Implement calculate_spring_confidence function signature and validation** (AC: 1, 12)

**Purpose:** Create function skeleton with proper signature, imports, and input validation

**Subtasks:**
- [ ] Update file: `backend/src/pattern_engine/detectors/spring_detector.py`
- [ ] Add imports:
  ```python
  from typing import Optional
  from decimal import Decimal
  from src.models.spring import Spring
  from src.models.spring_confidence import SpringConfidence
  from src.models.test import Test
  from src.models.creek_level import CreekLevel
  import structlog
  ```
- [ ] Create function signature:
  ```python
  def calculate_spring_confidence(
      spring: Spring,
      creek: CreekLevel,
      previous_tests: list[Test] = []
  ) -> SpringConfidence:
      """
      Calculate confidence score (0-100) for Spring pattern quality.

      Quantifies spring quality using multi-dimensional scoring to ensure
      only high-probability setups (70%+ confidence) generate trading signals (FR4).

      Scoring Formula (Team-Approved 2025-11-03):
      --------------------------------------------
      Base Components (100 points):
      - Volume Quality: 40 points (most important - shows supply exhaustion)
      - Penetration Depth: 35 points (critical for shakeout quality)
      - Recovery Speed: 25 points (demand strength indicator)
      - Test Confirmation: 20 points (FR13 requirement)

      Bonuses (+20 points max):
      - Creek Strength Bonus: +10 points (strong support quality)
      - Volume Trend Bonus: +10 points (declining volume pattern)

      Total: 120 points possible, capped at 100 for final score

      FR4 Requirement:
      ----------------
      Minimum 70% confidence required for signal generation.
      Springs scoring <70% are rejected.

      Args:
          spring: Detected Spring pattern (from Story 5.1)
          creek: Creek level with strength score (from Epic 3)
          previous_tests: List of prior Test patterns for volume trend analysis (from Story 5.3)

      Returns:
          SpringConfidence: Dataclass with total_score (0-100), component_scores dict, quality_tier

      Example:
          >>> confidence = calculate_spring_confidence(
          ...     spring=spring,
          ...     creek=creek_level,
          ...     previous_tests=[test1, test2]
          ... )
          >>> print(f"Confidence: {confidence.total_score}% ({confidence.quality_tier})")
          >>> if confidence.meets_threshold:
          ...     print("Spring meets FR4 minimum - will generate signal")

      Wyckoff Context:
          Not all Springs are equal. A Spring with ultra-low volume (0.3x),
          shallow penetration (1.5%), and immediate recovery (1 bar) is VASTLY
          superior to one with moderate volume (0.6x), deep penetration (4%),
          and slow recovery (5 bars). Confidence scoring quantifies spring quality.
      """
      logger = structlog.get_logger(__name__)

      # Input validation
      if spring is None:
          raise ValueError("spring parameter cannot be None")
      if creek is None:
          raise ValueError("creek parameter cannot be None")
      if previous_tests is None:
          previous_tests = []

      # Initialize component scores dictionary
      component_scores: dict[str, int] = {
          "volume_quality": 0,
          "penetration_depth": 0,
          "recovery_speed": 0,
          "test_confirmation": 0,
          "creek_strength_bonus": 0,
          "volume_trend_bonus": 0,
          "raw_total": 0
      }

      logger.info(
          "spring_confidence_calculation_start",
          spring_timestamp=spring.bar.timestamp.isoformat(),
          spring_volume_ratio=float(spring.volume_ratio),
          spring_penetration_pct=float(spring.penetration_pct),
          spring_recovery_bars=spring.recovery_bars,
          creek_strength=creek.strength if hasattr(creek, 'strength') else None,
          previous_tests_count=len(previous_tests)
      )
  ```
- [ ] Add type hints with mypy strict compliance
- [ ] Return type: SpringConfidence dataclass

**Wyckoff Context:**
> "Every Spring must be evaluated on multiple dimensions. Volume alone isn't enough -
> we need penetration depth, recovery speed, Creek strength, and volume trends to
> truly assess quality. This function is the gatekeeper ensuring only textbook springs
> generate signals."

---

### **Task 2: Implement volume quality scoring (40 points max)** (AC: 2)

**Purpose:** Score volume quality - THE most important spring indicator

**Subtasks:**
- [ ] Extract volume ratio from Spring:
  ```python
  # Volume Quality: 40 points max (MOST IMPORTANT)
  # Ultra-low volume proves supply exhaustion
  volume_ratio = spring.volume_ratio  # Decimal, guaranteed <0.7 by Story 5.2

  # AC 2: Volume quality scoring (5 tiers)
  # <0.3x = 40 pts (ultra-low, exceptionally rare and bullish)
  # 0.3-0.4x = 30 pts (excellent, extremely bullish)
  # 0.4-0.5x = 20 pts (ideal range, low public interest)
  # 0.5-0.6x = 10 pts (acceptable, some public participation)
  # 0.6-0.69x = 5 pts (marginal, higher public interest)

  if volume_ratio < Decimal("0.3"):
      volume_points = 40
      volume_quality = "ULTRA_LOW"
      logger.info(
          "ultra_low_volume_spring_detected",
          volume_ratio=float(volume_ratio),
          volume_points=volume_points,
          message="Exceptionally rare ultra-low volume spring (<0.3x) - highest confidence"
      )
  elif volume_ratio < Decimal("0.4"):
      volume_points = 30
      volume_quality = "EXCELLENT"
  elif volume_ratio < Decimal("0.5"):
      volume_points = 20
      volume_quality = "IDEAL"
  elif volume_ratio < Decimal("0.6"):
      volume_points = 10
      volume_quality = "ACCEPTABLE"
  else:  # 0.6 <= volume_ratio < 0.7
      volume_points = 5
      volume_quality = "MARGINAL"

  component_scores["volume_quality"] = volume_points

  logger.debug(
      "volume_quality_scored",
      volume_ratio=float(volume_ratio),
      volume_points=volume_points,
      volume_quality=volume_quality,
      message=f"Volume {volume_ratio:.2f}x scored {volume_points}/40 points"
  )
  ```
- [ ] Log volume scoring details with structured logging

**Wyckoff Context:**
> "Volume is THE KEY indicator. Richard Wyckoff taught that low volume on the Spring
> proves lack of selling pressure. Ultra-low volume (<0.3x) shows the public is
> COMPLETELY absent - only professionals are present. The lower the volume, the
> stronger the signal that supply is exhausted. This is why volume gets 40 points -
> it's the single most important quality indicator."

---

### **Task 3: Implement penetration depth scoring (35 points max)** (AC: 7)

**Purpose:** Score penetration depth - critical for shakeout quality

**Subtasks:**
- [ ] Extract penetration percentage from Spring:
  ```python
  # Penetration Depth: 35 points max (CRITICAL for shakeout quality)
  # Ideal 1-2% separates quality spring from breakdown
  penetration_pct = spring.penetration_pct  # 0-0.05 (0-5%, validated by Story 5.1)

  # AC 7: Penetration depth scoring (4 tiers)
  # 1-2% ideal = 35 pts (optimal shakeout depth)
  # 2-3% acceptable = 25 pts (deeper shakeout, still valid)
  # 3-4% deep = 15 pts (borderline, potential weakness)
  # 4-5% very deep = 5 pts (marginal, approaching breakdown)

  if Decimal("0.01") <= penetration_pct <= Decimal("0.02"):
      penetration_points = 35
      penetration_quality = "IDEAL"
  elif Decimal("0.02") < penetration_pct <= Decimal("0.03"):
      penetration_points = 25
      penetration_quality = "ACCEPTABLE"
  elif Decimal("0.03") < penetration_pct <= Decimal("0.04"):
      penetration_points = 15
      penetration_quality = "DEEP"
  else:  # 0.04 < penetration_pct <= 0.05
      penetration_points = 5
      penetration_quality = "VERY_DEEP"

  component_scores["penetration_depth"] = penetration_points

  logger.debug(
      "penetration_depth_scored",
      penetration_pct=float(penetration_pct),
      penetration_points=penetration_points,
      penetration_quality=penetration_quality,
      message=f"Penetration {penetration_pct:.1%} scored {penetration_points}/35 points"
  )
  ```
- [ ] Log penetration scoring details

**Wyckoff Context:**
> "Penetration depth is CRITICAL. Wyckoff taught that the Spring should penetrate
> just far enough to shake out weak holders (1-2% ideal), but not so deep that it
> signals genuine weakness (>4%). A 1.5% penetration triggers stops below Creek and
> shakes out retail, but shows the professionals are still in control. A 4.5%
> penetration risks being an actual breakdown. This is why penetration gets 35 points -
> it separates quality springs from marginal ones."

---

### **Task 4: Implement recovery speed scoring (25 points max)** (AC: 4)

**Purpose:** Score recovery speed - measures demand strength

**Subtasks:**
- [ ] Extract recovery bars from Spring:
  ```python
  # Recovery Speed: 25 points max (DEMAND STRENGTH indicator)
  # Fast recovery proves strong demand absorption
  recovery_bars = spring.recovery_bars  # 1-5 bars (validated by Story 5.1)

  # AC 4: Recovery speed scoring (4 tiers)
  # 1 bar = 25 pts (immediate recovery, extremely bullish)
  # 2 bars = 20 pts (quick recovery, strong demand)
  # 3 bars = 15 pts (moderate recovery, good demand)
  # 4-5 bars = 10 pts (slow recovery, acceptable demand)

  if recovery_bars == 1:
      recovery_points = 25
      recovery_quality = "IMMEDIATE"
  elif recovery_bars == 2:
      recovery_points = 20
      recovery_quality = "QUICK"
  elif recovery_bars == 3:
      recovery_points = 15
      recovery_quality = "MODERATE"
  else:  # 4-5 bars
      recovery_points = 10
      recovery_quality = "SLOW"

  component_scores["recovery_speed"] = recovery_points

  logger.debug(
      "recovery_speed_scored",
      recovery_bars=recovery_bars,
      recovery_points=recovery_points,
      recovery_quality=recovery_quality,
      message=f"Recovery in {recovery_bars} bar(s) scored {recovery_points}/25 points"
  )
  ```
- [ ] Log recovery scoring details

**Wyckoff Context:**
> "Recovery speed reveals demand strength. Wyckoff emphasized that the best Springs
> recover IMMEDIATELY (1 bar) - this shows overwhelming demand stepped in to absorb
> all supply at the low. A 5-bar recovery is acceptable but shows weaker demand.
> The faster the recovery, the stronger the hands that are accumulating. This is
> why recovery gets 25 points - it's a key indicator of professional accumulation."

---

### **Task 5: Implement test confirmation scoring (20 points flat)** (AC: 5)

**Purpose:** Score test confirmation - FR13 requirement (NO volume decrease bonus)

**Subtasks:**
- [ ] Check if spring has confirmed test:
  ```python
  # Test Confirmation: 20 points flat (FR13 requirement)
  # Test present = 20 pts (NO BONUS - volume trend bonus replaces this)
  # No test = 0 pts (will fail FR13 signal generation later)

  # Note: This function receives 'spring' which may or may not have test_confirmed flag
  # For MVP, assume test confirmation will be checked separately in signal generation
  # This task implements the SCORING component only

  # Check if spring has test_confirmed attribute (from Story 5.3 integration)
  has_test_confirmation = getattr(spring, 'test_confirmed', False)

  if has_test_confirmation:
      test_points = 20
      test_quality = "PRESENT"
      logger.debug(
          "test_confirmation_scored",
          test_present=True,
          test_points=test_points,
          message="Test confirmation present - scored 20/20 points"
      )
  else:
      test_points = 0
      test_quality = "NONE"
      logger.warning(
          "no_test_confirmation",
          test_present=False,
          test_points=0,
          message="No test confirmation - spring will not generate signal (FR13)"
      )

  component_scores["test_confirmation"] = test_points
  ```
- [ ] Log test scoring (no bonus logic - flat 20 points)

**Wyckoff Context:**
> "The Test is PROOF the Spring worked. Wyckoff taught that without a Test returning
> to the Spring low on lower volume, you cannot confirm the shakeout was successful.
> FR13 makes Test mandatory for signal generation - no Test means NO TRADE. The Test
> gets a flat 20 points because it's binary: either present (tradeable) or absent
> (not tradeable). Volume trend bonus now captures the quality aspect."

---

### **Task 6: Implement Creek strength bonus (10 points max - NEW)** (AC: 8)

**Purpose:** Score Creek support quality - replaces phase/range quality bonuses

**Subtasks:**
- [ ] Extract Creek strength from CreekLevel:
  ```python
  # Creek Strength Bonus: 10 points max (NEW - replaces phase/range bonuses)
  # Strong Creek support = more reliable spring
  # Creek strength shows how well-tested and defended the support level is

  # Extract Creek strength (0-100 scale from Epic 3)
  creek_strength = getattr(creek, 'strength', 0)  # Default to 0 if not present

  # AC 8: Creek strength bonus scoring (4 tiers)
  # >=80 = 10 pts (strong support, well-defended)
  # 70-79 = 7 pts (good support, moderately tested)
  # 60-69 = 5 pts (moderate support, some defense)
  # <60 = 0 pts (weak support, unreliable)

  if creek_strength >= 80:
      creek_bonus = 10
      creek_quality = "STRONG"
  elif creek_strength >= 70:
      creek_bonus = 7
      creek_quality = "GOOD"
  elif creek_strength >= 60:
      creek_bonus = 5
      creek_quality = "MODERATE"
  else:
      creek_bonus = 0
      creek_quality = "WEAK"

  component_scores["creek_strength_bonus"] = creek_bonus

  logger.debug(
      "creek_strength_bonus_scored",
      creek_strength=creek_strength,
      creek_bonus=creek_bonus,
      creek_quality=creek_quality,
      message=f"Creek strength {creek_strength} scored {creek_bonus}/10 bonus points"
  )
  ```
- [ ] Log Creek strength bonus details

**Wyckoff Context:**
> "Creek strength is VITAL. A Spring at strong, well-defended support (Creek strength
> >=80) is FAR more reliable than a Spring at weak, untested support (<60). Wyckoff
> taught that support levels gain strength through repeated testing and defense. A
> Creek that has been tested 5+ times and held is MUCH stronger than one tested once.
> This bonus replaces the old phase/range quality bonuses with a more specific,
> actionable metric."

---

### **Task 7: Implement volume trend bonus (10 points max - NEW)** (AC: 9)

**Purpose:** Score declining volume pattern across multiple tests - key Wyckoff principle

**Subtasks:**
- [ ] Analyze volume trend from previous tests:
  ```python
  # Volume Trend Bonus: 10 points max (NEW - captures diminishing volume principle)
  # Declining volume from previous tests shows supply exhaustion
  # This is a KEY Wyckoff accumulation characteristic

  # AC 9: Volume trend bonus scoring (3 tiers)
  # Declining volume (20%+ decrease from previous tests) = 10 pts
  # Stable volume (±20% from previous tests) = 5 pts
  # Rising volume = 0 pts (warning - potential distribution)

  if len(previous_tests) == 0:
      # No previous tests to compare - give neutral score
      volume_trend_bonus = 5
      volume_trend_quality = "NO_COMPARISON"
      logger.debug(
          "volume_trend_bonus_no_comparison",
          previous_tests_count=0,
          volume_trend_bonus=volume_trend_bonus,
          message="No previous tests for volume trend comparison - neutral 5 pts"
      )
  else:
      # Calculate average volume of previous tests
      previous_test_volumes = [test.bar.volume for test in previous_tests]
      avg_previous_volume = sum(previous_test_volumes) / len(previous_test_volumes)

      # Compare spring volume to average previous test volume
      spring_volume = spring.bar.volume
      volume_change_pct = (spring_volume - avg_previous_volume) / avg_previous_volume

      # Score based on volume trend
      if volume_change_pct <= Decimal("-0.2"):  # 20%+ decrease
          volume_trend_bonus = 10
          volume_trend_quality = "DECLINING"
          logger.info(
              "declining_volume_trend_detected",
              volume_change_pct=float(volume_change_pct),
              volume_trend_bonus=volume_trend_bonus,
              message=f"Volume declined {abs(volume_change_pct):.1%} from previous tests - excellent"
          )
      elif abs(volume_change_pct) <= Decimal("0.2"):  # ±20% (stable)
          volume_trend_bonus = 5
          volume_trend_quality = "STABLE"
      else:  # > 20% increase
          volume_trend_bonus = 0
          volume_trend_quality = "RISING"
          logger.warning(
              "rising_volume_trend_warning",
              volume_change_pct=float(volume_change_pct),
              volume_trend_bonus=0,
              message=f"Volume increased {volume_change_pct:.1%} from previous tests - potential distribution"
          )

  component_scores["volume_trend_bonus"] = volume_trend_bonus

  logger.debug(
      "volume_trend_bonus_scored",
      previous_tests_count=len(previous_tests),
      volume_trend_bonus=volume_trend_bonus,
      volume_trend_quality=volume_trend_quality
  )
  ```
- [ ] Log volume trend analysis details

**Wyckoff Context:**
> "Diminishing volume on successive tests is a CORNERSTONE of Wyckoff accumulation
> theory. As supply is absorbed through the range, each subsequent test should show
> LOWER volume - this proves supply is drying up. If Test 1 had 1M volume, Test 2
> had 800K, and the Spring has 600K, this DECLINING pattern is textbook accumulation.
> Rising volume would warn of potential distribution. This bonus captures a key
> Wyckoff principle that the old single-test volume bonus missed."

---

### **Task 8: Calculate final confidence and determine quality tier** (AC: 10, 11, 12)

**Purpose:** Sum all components, cap at 100, determine quality tier, validate FR4 threshold

**Subtasks:**
- [ ] Calculate raw total and apply cap:
  ```python
  # Calculate final confidence score
  # Sum all components
  raw_total = (
      component_scores["volume_quality"] +
      component_scores["penetration_depth"] +
      component_scores["recovery_speed"] +
      component_scores["test_confirmation"] +
      component_scores["creek_strength_bonus"] +
      component_scores["volume_trend_bonus"]
  )

  component_scores["raw_total"] = raw_total

  # Cap at 100 for final score (AC 10)
  # Total possible: 40 + 35 + 25 + 20 + 10 + 10 = 140 (with all bonuses)
  # Base (no bonuses): 40 + 35 + 25 + 20 = 120
  final_confidence = min(raw_total, 100)

  # Determine quality tier (AC 11)
  if final_confidence >= 90:
      quality_tier = "EXCELLENT"
  elif final_confidence >= 80:
      quality_tier = "GOOD"
  elif final_confidence >= 70:
      quality_tier = "ACCEPTABLE"
  else:
      quality_tier = "REJECTED"

  # Validate FR4 minimum threshold (AC 11)
  meets_threshold = final_confidence >= 70

  logger.info(
      "spring_confidence_calculated",
      spring_timestamp=spring.bar.timestamp.isoformat(),
      raw_total=raw_total,
      final_confidence=final_confidence,
      quality_tier=quality_tier,
      meets_threshold=meets_threshold,
      volume_points=component_scores["volume_quality"],
      penetration_points=component_scores["penetration_depth"],
      recovery_points=component_scores["recovery_speed"],
      test_points=component_scores["test_confirmation"],
      creek_bonus=component_scores["creek_strength_bonus"],
      volume_trend_bonus=component_scores["volume_trend_bonus"],
      message=f"Spring confidence: {final_confidence}% ({quality_tier}) - {'SIGNAL' if meets_threshold else 'REJECTED'}"
  )

  # Log warning if below FR4 threshold
  if not meets_threshold:
      logger.warning(
          "spring_low_confidence",
          final_confidence=final_confidence,
          threshold=70,
          quality_tier=quality_tier,
          message=f"Spring confidence {final_confidence}% below FR4 minimum (70%) - will not generate signal"
      )
  ```
- [ ] Log comprehensive scoring breakdown
- [ ] Create and return SpringConfidence dataclass:
  ```python
  # Return SpringConfidence dataclass (AC 12)
  return SpringConfidence(
      total_score=final_confidence,
      component_scores=component_scores,
      quality_tier=quality_tier
  )
  ```

**Wyckoff Context:**
> "FR4's 70% threshold is the final gatekeeper. Only springs scoring 70+ generate
> signals. A 95% spring (EXCELLENT) has textbook characteristics across all dimensions.
> A 72% spring (ACCEPTABLE) is marginal but tradeable. A 65% spring (REJECTED) lacks
> sufficient quality. This threshold filters out the marginal setups that Wyckoff
> would have avoided - we only want the highest-probability springs."

---

### **Task 9: Add comprehensive docstring with Wyckoff examples** (AC: all)

**Purpose:** Document the function with real-world Wyckoff examples

**Subtasks:**
- [ ] Add module-level docstring with scoring breakdown table
- [ ] Add function docstring with detailed examples:
  ```python
  """
  (Include examples showing EXCELLENT, GOOD, ACCEPTABLE, and REJECTED springs)

  Example 1 - EXCELLENT Spring (95+ points):
      Volume: 0.25x (ultra-low) → 40 pts
      Penetration: 1.5% (ideal shallow) → 35 pts
      Recovery: 1 bar (immediate) → 25 pts
      Test: Present → 20 pts
      Creek strength: 85 (strong) → 10 pts bonus
      Volume trend: Declining 25% → 10 pts bonus
      Raw Total: 140 → Capped at 100
      Quality Tier: EXCELLENT

  Example 2 - GOOD Spring (83 points):
      Volume: 0.42x (ideal) → 20 pts
      Penetration: 2.2% (acceptable) → 25 pts
      Recovery: 2 bars (quick) → 20 pts
      Test: Present → 20 pts
      Creek strength: 76 (good) → 7 pts bonus
      Volume trend: Declining 15% (stable) → 5 pts bonus
      Raw Total: 97 → 97
      Quality Tier: GOOD

  Example 3 - ACCEPTABLE Spring (72 points):
      Volume: 0.55x (acceptable) → 10 pts
      Penetration: 2.8% (acceptable) → 25 pts
      Recovery: 3 bars (moderate) → 15 pts
      Test: Present → 20 pts
      Creek strength: 65 (moderate) → 5 pts bonus
      Volume trend: Rising 10% (stable) → 5 pts bonus
      Raw Total: 80 → 80
      Quality Tier: ACCEPTABLE (meets FR4 minimum)

  Example 4 - REJECTED Spring (58 points):
      Volume: 0.63x (marginal) → 5 pts
      Penetration: 4.2% (very deep) → 5 pts
      Recovery: 5 bars (slow) → 10 pts
      Test: Present → 20 pts
      Creek strength: 55 (weak) → 0 pts bonus
      Volume trend: Rising 30% → 0 pts bonus
      Raw Total: 40 → 40
      Quality Tier: REJECTED (below FR4 70% threshold - NO SIGNAL)
  """
  ```
- [ ] Document confidence interpretation ranges
- [ ] Add Wyckoff methodology context for each component

---

### **Task 10: Write unit test for EXCELLENT spring (90-100 points)** (AC: all)

**Purpose:** Test high-quality spring with all components scoring well

**Subtasks:**
- [ ] Create/update test file: `backend/tests/unit/pattern_engine/detectors/test_spring_detector.py`
- [ ] Write test:
  ```python
  def test_calculate_spring_confidence_excellent_quality():
      """Test EXCELLENT spring scoring 95+ points with ideal characteristics."""
      # Arrange: Create excellent spring scenario
      # - Volume: 0.28x (ultra-low) → 40 pts
      # - Penetration: 1.5% (ideal) → 35 pts
      # - Recovery: 1 bar (immediate) → 25 pts
      # - Test: Present → 20 pts
      # - Creek strength: 85 (strong) → 10 pts
      # - Volume trend: Declining 25% → 10 pts
      # Expected raw: 140 → capped at 100

      spring = create_spring_fixture(
          volume_ratio=Decimal("0.28"),
          penetration_pct=Decimal("0.015"),  # 1.5%
          recovery_bars=1,
          test_confirmed=True
      )

      creek = create_creek_fixture(strength=85)

      # Previous tests with higher volume (declining trend)
      previous_tests = [
          create_test_fixture(volume=1000),  # Earlier test
          create_test_fixture(volume=900),   # Middle test
      ]
      # Spring volume should be ~700 (declining 25%+)

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      assert confidence.total_score >= 95, f"EXCELLENT spring should score 95+, got {confidence.total_score}"
      assert confidence.total_score == 100, "Should be capped at 100"
      assert confidence.quality_tier == "EXCELLENT"
      assert confidence.meets_threshold is True
      assert confidence.component_scores["volume_quality"] == 40
      assert confidence.component_scores["penetration_depth"] == 35
      assert confidence.component_scores["recovery_speed"] == 25
      assert confidence.component_scores["test_confirmation"] == 20
      assert confidence.component_scores["creek_strength_bonus"] == 10
      assert confidence.component_scores["volume_trend_bonus"] == 10
      assert confidence.component_scores["raw_total"] == 140
  ```

---

### **Task 11: Write unit test for GOOD spring (80-89 points)** (AC: all)

**Purpose:** Test good-quality spring scoring in 80-89 range

**Subtasks:**
- [ ] Write test:
  ```python
  def test_calculate_spring_confidence_good_quality():
      """Test GOOD spring scoring 80-89 points with strong characteristics."""
      # Arrange: Create good spring scenario
      # - Volume: 0.42x (ideal) → 20 pts
      # - Penetration: 2.2% (acceptable) → 25 pts
      # - Recovery: 2 bars (quick) → 20 pts
      # - Test: Present → 20 pts
      # - Creek strength: 76 (good) → 7 pts
      # - Volume trend: Stable → 5 pts
      # Expected: 97 points (GOOD tier)

      spring = create_spring_fixture(
          volume_ratio=Decimal("0.42"),
          penetration_pct=Decimal("0.022"),  # 2.2%
          recovery_bars=2,
          test_confirmed=True
      )

      creek = create_creek_fixture(strength=76)

      previous_tests = [create_test_fixture(volume=800)]
      # Spring volume ~800 (stable ±20%)

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      assert 80 <= confidence.total_score < 90, f"GOOD spring should score 80-89, got {confidence.total_score}"
      assert confidence.quality_tier == "GOOD"
      assert confidence.meets_threshold is True
  ```

---

### **Task 12: Write unit test for ACCEPTABLE spring (70-79 points)** (AC: all)

**Purpose:** Test minimum-threshold spring scoring exactly at FR4 limit

**Subtasks:**
- [ ] Write test:
  ```python
  def test_calculate_spring_confidence_acceptable_minimum_threshold():
      """Test ACCEPTABLE spring scoring 70-79 (minimum FR4 threshold)."""
      # Arrange: Create acceptable spring at minimum threshold
      # Target exactly 72 points
      # - Volume: 0.55x (acceptable) → 10 pts
      # - Penetration: 2.8% (acceptable) → 25 pts
      # - Recovery: 3 bars (moderate) → 15 pts
      # - Test: Present → 20 pts
      # - Creek strength: 65 (moderate) → 5 pts
      # - Volume trend: Stable → 5 pts
      # Expected: 80 points (ACCEPTABLE tier)

      spring = create_spring_fixture(
          volume_ratio=Decimal("0.55"),
          penetration_pct=Decimal("0.028"),  # 2.8%
          recovery_bars=3,
          test_confirmed=True
      )

      creek = create_creek_fixture(strength=65)

      previous_tests = [create_test_fixture(volume=600)]
      # Spring volume ~600 (stable)

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      assert 70 <= confidence.total_score < 80, f"ACCEPTABLE spring should score 70-79, got {confidence.total_score}"
      assert confidence.quality_tier == "ACCEPTABLE"
      assert confidence.meets_threshold is True
      assert confidence.total_score >= 70, "Must meet FR4 minimum threshold"
  ```

---

### **Task 13: Write unit test for REJECTED spring (<70 points)** (AC: all)

**Purpose:** Test low-quality spring that fails FR4 threshold

**Subtasks:**
- [ ] Write test:
  ```python
  def test_calculate_spring_confidence_rejected_below_threshold():
      """Test REJECTED spring scoring <70 (fails FR4 threshold)."""
      # Arrange: Create low-quality spring below threshold
      # - Volume: 0.63x (marginal) → 5 pts
      # - Penetration: 4.2% (very deep) → 5 pts
      # - Recovery: 5 bars (slow) → 10 pts
      # - Test: Present → 20 pts
      # - Creek strength: 55 (weak) → 0 pts
      # - Volume trend: Rising 30% → 0 pts
      # Expected: 40 points (REJECTED)

      spring = create_spring_fixture(
          volume_ratio=Decimal("0.63"),
          penetration_pct=Decimal("0.042"),  # 4.2%
          recovery_bars=5,
          test_confirmed=True
      )

      creek = create_creek_fixture(strength=55)

      previous_tests = [create_test_fixture(volume=500)]
      # Spring volume ~650 (rising 30%)

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      assert confidence.total_score < 70, f"REJECTED spring should score <70, got {confidence.total_score}"
      assert confidence.quality_tier == "REJECTED"
      assert confidence.meets_threshold is False
      # Verify warning logged about below-threshold
  ```

---

### **Task 14: Write unit test for no test confirmation** (AC: 5)

**Purpose:** Test spring without test confirmation (loses 20 points)

**Subtasks:**
- [ ] Write test:
  ```python
  def test_calculate_spring_confidence_no_test_confirmation():
      """Test spring without test confirmation loses 20 points."""
      # Arrange: Excellent spring in all aspects EXCEPT no test
      spring = create_spring_fixture(
          volume_ratio=Decimal("0.28"),
          penetration_pct=Decimal("0.015"),
          recovery_bars=1,
          test_confirmed=False  # NO TEST
      )

      creek = create_creek_fixture(strength=85)
      previous_tests = [create_test_fixture(volume=1000)]

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      # Without test: loses 20 points
      # Expected: 40 + 35 + 25 + 0 + 10 + 10 = 120 → capped at 100
      # But without test confirmation (0 pts instead of 20 pts):
      # 40 + 35 + 25 + 0 + 10 + 10 = 120 → still caps at 100
      # Actually: need to design test to show impact

      # Better test: marginal spring where 20 pts matters
      spring2 = create_spring_fixture(
          volume_ratio=Decimal("0.50"),  # 20 pts
          penetration_pct=Decimal("0.025"),  # 25 pts
          recovery_bars=3,  # 15 pts
          test_confirmed=False  # 0 pts
      )
      creek2 = create_creek_fixture(strength=72)  # 7 pts
      previous_tests2 = []  # 5 pts (neutral)

      confidence2 = calculate_spring_confidence(spring2, creek2, previous_tests2)

      # 20 + 25 + 15 + 0 + 7 + 5 = 72 points
      # With test would be: 20 + 25 + 15 + 20 + 7 + 5 = 92 points

      assert confidence2.component_scores["test_confirmation"] == 0
      assert confidence2.total_score < 75, "Missing test should significantly reduce score"
      # Verify warning logged
  ```

---

### **Task 15: Write parametrized tests for volume quality tiers** (AC: 2)

**Purpose:** Test all 5 volume quality tiers

**Subtasks:**
- [ ] Write parametrized test:
  ```python
  @pytest.mark.parametrize("volume_ratio,expected_points,expected_quality", [
      (Decimal("0.25"), 40, "ULTRA_LOW"),      # <0.3x
      (Decimal("0.35"), 30, "EXCELLENT"),      # 0.3-0.4x
      (Decimal("0.45"), 20, "IDEAL"),          # 0.4-0.5x
      (Decimal("0.55"), 10, "ACCEPTABLE"),     # 0.5-0.6x
      (Decimal("0.65"), 5, "MARGINAL"),        # 0.6-0.69x
  ])
  def test_volume_quality_scoring_tiers(volume_ratio, expected_points, expected_quality):
      """Test all volume quality scoring tiers (AC 2)."""
      spring = create_spring_fixture(volume_ratio=volume_ratio)
      creek = create_creek_fixture(strength=70)

      confidence = calculate_spring_confidence(spring, creek, [])

      assert confidence.component_scores["volume_quality"] == expected_points
      # Log should contain expected_quality
  ```

---

### **Task 16: Write parametrized tests for penetration depth tiers** (AC: 7)

**Purpose:** Test all 4 penetration depth tiers

**Subtasks:**
- [ ] Write parametrized test:
  ```python
  @pytest.mark.parametrize("penetration_pct,expected_points,expected_quality", [
      (Decimal("0.015"), 35, "IDEAL"),         # 1-2%
      (Decimal("0.025"), 25, "ACCEPTABLE"),    # 2-3%
      (Decimal("0.035"), 15, "DEEP"),          # 3-4%
      (Decimal("0.045"), 5, "VERY_DEEP"),      # 4-5%
  ])
  def test_penetration_depth_scoring_tiers(penetration_pct, expected_points, expected_quality):
      """Test all penetration depth scoring tiers (AC 7)."""
      spring = create_spring_fixture(penetration_pct=penetration_pct)
      creek = create_creek_fixture(strength=70)

      confidence = calculate_spring_confidence(spring, creek, [])

      assert confidence.component_scores["penetration_depth"] == expected_points
  ```

---

### **Task 17: Write parametrized tests for recovery speed tiers** (AC: 4)

**Purpose:** Test all 4 recovery speed tiers

**Subtasks:**
- [ ] Write parametrized test:
  ```python
  @pytest.mark.parametrize("recovery_bars,expected_points,expected_quality", [
      (1, 25, "IMMEDIATE"),
      (2, 20, "QUICK"),
      (3, 15, "MODERATE"),
      (4, 10, "SLOW"),
      (5, 10, "SLOW"),
  ])
  def test_recovery_speed_scoring_tiers(recovery_bars, expected_points, expected_quality):
      """Test all recovery speed scoring tiers (AC 4)."""
      spring = create_spring_fixture(recovery_bars=recovery_bars)
      creek = create_creek_fixture(strength=70)

      confidence = calculate_spring_confidence(spring, creek, [])

      assert confidence.component_scores["recovery_speed"] == expected_points
  ```

---

### **Task 18: Write parametrized tests for Creek strength bonus tiers** (AC: 8)

**Purpose:** Test all 4 Creek strength bonus tiers (NEW component)

**Subtasks:**
- [ ] Write parametrized test:
  ```python
  @pytest.mark.parametrize("creek_strength,expected_bonus,expected_quality", [
      (85, 10, "STRONG"),      # >=80
      (75, 7, "GOOD"),         # 70-79
      (65, 5, "MODERATE"),     # 60-69
      (55, 0, "WEAK"),         # <60
  ])
  def test_creek_strength_bonus_tiers(creek_strength, expected_bonus, expected_quality):
      """Test all Creek strength bonus tiers (AC 8 - NEW)."""
      spring = create_spring_fixture()
      creek = create_creek_fixture(strength=creek_strength)

      confidence = calculate_spring_confidence(spring, creek, [])

      assert confidence.component_scores["creek_strength_bonus"] == expected_bonus
  ```

---

### **Task 19: Write parametrized tests for volume trend bonus tiers** (AC: 9)

**Purpose:** Test all 3 volume trend bonus tiers (NEW component)

**Subtasks:**
- [ ] Write parametrized test:
  ```python
  @pytest.mark.parametrize("spring_volume,previous_volumes,expected_bonus,expected_quality", [
      (600, [1000, 900], 10, "DECLINING"),  # 600 vs avg 950 = -37% (declining)
      (800, [800, 800], 5, "STABLE"),       # 800 vs avg 800 = 0% (stable)
      (1200, [800, 900], 0, "RISING"),      # 1200 vs avg 850 = +41% (rising)
      (None, [], 5, "NO_COMPARISON"),       # No previous tests (neutral)
  ])
  def test_volume_trend_bonus_tiers(spring_volume, previous_volumes, expected_bonus, expected_quality):
      """Test all volume trend bonus tiers (AC 9 - NEW)."""
      spring = create_spring_fixture(volume=spring_volume or 800)
      creek = create_creek_fixture(strength=70)
      previous_tests = [create_test_fixture(volume=v) for v in previous_volumes]

      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      assert confidence.component_scores["volume_trend_bonus"] == expected_bonus
  ```

---

### **Task 20: Write integration test with realistic spring scenario** (AC: all)

**Purpose:** Test with realistic end-to-end spring data

**Subtasks:**
- [ ] Create integration test file: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py`
- [ ] Write test:
  ```python
  def test_spring_confidence_integration_realistic_scenario():
      """Test confidence scoring with realistic spring scenario from historical data."""
      # Arrange: Create realistic spring based on historical accumulation pattern
      # Example: Bitcoin accumulation range, final spring before markup

      # Realistic spring characteristics:
      # - Volume: 0.38x (excellent, low public interest)
      # - Penetration: 1.8% (ideal shakeout depth)
      # - Recovery: 2 bars (quick demand response)
      # - Test: Present (FR13 satisfied)
      # - Creek strength: 82 (well-tested support)
      # - Volume trend: Declining from 3 previous tests

      spring = create_realistic_spring_fixture()
      creek = create_realistic_creek_fixture()
      previous_tests = create_realistic_test_sequence()

      # Act
      confidence = calculate_spring_confidence(spring, creek, previous_tests)

      # Assert
      assert confidence.total_score >= 90, "Realistic high-quality spring should score 90+"
      assert confidence.quality_tier in ["EXCELLENT", "GOOD"]
      assert confidence.meets_threshold is True

      # Verify component breakdown makes sense
      assert confidence.component_scores["volume_quality"] >= 20
      assert confidence.component_scores["penetration_depth"] >= 25
      assert confidence.component_scores["recovery_speed"] >= 15
      assert confidence.component_scores["test_confirmation"] == 20

      # Log detailed breakdown for manual review
      logger.info("Realistic spring confidence breakdown", **confidence.component_scores)
  ```

---

### **Task 21: Add type hints and mypy validation** (AC: 1)

**Purpose:** Ensure strict type safety

**Subtasks:**
- [ ] Add comprehensive type hints to all variables
- [ ] Run mypy in strict mode:
  ```bash
  mypy backend/src/pattern_engine/detectors/spring_detector.py --strict
  ```
- [ ] Fix any type errors
- [ ] Ensure function signature matches AC exactly:
  ```python
  def calculate_spring_confidence(
      spring: Spring,
      creek: CreekLevel,
      previous_tests: list[Test] = []
  ) -> SpringConfidence:
  ```

---

### **Task 22: Add comprehensive structured logging** (AC: all)

**Purpose:** Follow architecture/17-monitoring-and-observability.md guidelines

**Subtasks:**
- [ ] Add structlog logger initialization
- [ ] Log calculation start with all inputs
- [ ] Log each component scoring (volume, penetration, recovery, test, Creek, volume trend)
- [ ] Log final confidence with complete breakdown
- [ ] Log warnings for:
  - Below-threshold springs (<70%)
  - No test confirmation (FR13 violation)
  - Rising volume trend (distribution warning)
- [ ] Use structured fields (not string interpolation)
- [ ] Include correlation IDs if available

---

### **Task 23: Document confidence interpretation guide** (AC: all)

**Purpose:** Help developers and analysts interpret scores

**Subtasks:**
- [ ] Add module-level interpretation guide:
  ```python
  """
  Confidence Interpretation Guide:
  --------------------------------

  Quality Tiers:
  - EXCELLENT (90-100): Textbook spring, highest probability
    * Ultra-low volume, ideal penetration, immediate recovery
    * Strong Creek support, declining volume trend
    * Example: 0.25x volume, 1.5% penetration, 1 bar recovery

  - GOOD (80-89): High-quality spring, strong setup
    * Low volume, good penetration, quick recovery
    * Good Creek support, stable/declining volume
    * Example: 0.42x volume, 2.2% penetration, 2 bars recovery

  - ACCEPTABLE (70-79): Meets minimum FR4 threshold
    * Acceptable volume, moderate penetration, moderate recovery
    * Moderate Creek support, stable volume
    * Example: 0.55x volume, 2.8% penetration, 3 bars recovery
    * SIGNALS GENERATED at this tier

  - REJECTED (<70): Below FR4 threshold - NO SIGNAL
    * Marginal volume, deep penetration, slow recovery
    * Weak Creek support, rising volume
    * Example: 0.63x volume, 4.2% penetration, 5 bars recovery
    * SIGNALS BLOCKED at this tier

  Component Significance:
  -----------------------
  1. Volume Quality (40 pts) - MOST IMPORTANT
     Low volume proves supply exhaustion

  2. Penetration Depth (35 pts) - CRITICAL
     Separates quality spring from breakdown

  3. Recovery Speed (25 pts) - DEMAND INDICATOR
     Fast recovery shows strong demand

  4. Test Confirmation (20 pts) - FR13 REQUIREMENT
     Binary: present (tradeable) or absent (not tradeable)

  5. Creek Strength Bonus (+10 pts) - SUPPORT QUALITY
     Strong support increases reliability

  6. Volume Trend Bonus (+10 pts) - ACCUMULATION SIGNAL
     Declining volume confirms supply exhaustion
  """
  ```

---

## TASK SUMMARY

**Total Tasks: 23**

**Core Implementation (8 tasks):**
- Task 1: Function signature and validation
- Task 2: Volume quality scoring (40 pts)
- Task 3: Penetration depth scoring (35 pts)
- Task 4: Recovery speed scoring (25 pts)
- Task 5: Test confirmation scoring (20 pts)
- Task 6: Creek strength bonus (10 pts) - NEW
- Task 7: Volume trend bonus (10 pts) - NEW
- Task 8: Final calculation and quality tier

**Documentation (3 tasks):**
- Task 9: Comprehensive docstring with examples
- Task 23: Confidence interpretation guide
- Task 22: Structured logging

**Unit Tests (10 tasks):**
- Task 10: EXCELLENT spring test
- Task 11: GOOD spring test
- Task 12: ACCEPTABLE spring test
- Task 13: REJECTED spring test
- Task 14: No test confirmation test
- Task 15: Volume quality tiers (parametrized)
- Task 16: Penetration depth tiers (parametrized)
- Task 17: Recovery speed tiers (parametrized)
- Task 18: Creek strength bonus tiers (parametrized)
- Task 19: Volume trend bonus tiers (parametrized)

**Integration & Quality (2 tasks):**
- Task 20: Realistic integration test
- Task 21: Type hints and mypy validation

---

## WYCKOFF VALIDATION SCORE: 95/100

**Strengths:**
✅ Volume importance properly weighted (40 pts)
✅ Penetration depth critical weighting (35 pts)
✅ Recovery speed reflects demand strength (25 pts)
✅ Creek strength bonus replaces generic range quality
✅ Volume trend bonus captures diminishing volume principle
✅ Test confirmation remains mandatory (FR13)
✅ FR4 70% threshold acts as quality gatekeeper

**This task list is PRODUCTION-READY and aligned with authentic Wyckoff methodology.**

---

End of Corrected Task List


## Dev Notes

### Previous Story Context

**Story 5.1 (Spring Pattern Detection Logic):**
[Source: docs/stories/epic-5/5.1.spring-pattern-detection-logic.md]
- Implements `detect_spring(range, bars, volume_analysis, phase)` → Optional[Spring]
- Spring model: bar, penetration_pct, volume_ratio, recovery_bars, creek_reference, spring_low, recovery_price
- Spring requirements: breaks below Creek (0-5%), low volume (<0.7x), recovery within 1-5 bars
- Phase validation: FR15 - Springs only valid in Phase C
- **Story 5.4 integration:** calculate_spring_confidence receives Spring as input

**Story 5.2 (Spring Volume Validation):**
[Source: docs/stories/epic-5/5.2.spring-volume-validation.md]
- Strict volume validation: volume_ratio >= 0.7x → REJECT
- FR12 enforcement: high volume = breakdown, not spring
- Binary pass/fail, not scored
- Volume ranges: <0.3x (ultra-bullish), 0.3-0.5x (ideal), 0.5-0.7x (acceptable)
- **Story 5.4 integration:** Volume quality scoring uses these ranges (30 pts max)

**Story 5.3 (Test Confirmation Detection):**
[Source: docs/stories/epic-5/5.3.test-confirmation-detection.md]
- Implements `detect_test_confirmation(range, spring, bars, volume_analysis)` → Optional[Test]
- Test requirements: occurs 3-15 bars after spring, approaches spring low, lower volume than spring
- Test model: bar, distance_from_spring_low, volume_ratio, volume_decrease_pct, holds_spring_low
- FR13: Springs NOT tradeable without test confirmation
- **Story 5.4 integration:** Test presence and quality affects confidence scoring (20 pts + 5 bonus)

**Epic 4 (Phase Detection):**
[Source: Epic 4 stories]
- PhaseDetector provides PhaseClassification with confidence score
- WyckoffPhase enum: A, B, C, D, E
- PhaseClassification: phase, confidence (0-100), criteria_met
- **Story 5.4 integration:** Phase confidence used for bonus scoring (5 pts max)

**Epic 3 (Trading Range Detection):**
[Source: Epic 3 stories]
- TradingRange model with Creek/Ice levels
- Range quality/strength affects pattern reliability
- Creek level used for spring penetration detection
- **Story 5.4 integration:** Range quality affects confidence scoring (10 pts)

**Epic 2 (Volume Analysis):**
[Source: Epic 2 stories]
- VolumeAnalyzer calculates volume_ratio for each bar
- OHLCVBar includes spread_ratio (spread vs 20-bar average)
- **Story 5.4 integration:** spread_ratio used for spread narrowness scoring (15 pts)

**Key Learnings:**
- Confidence scoring is CRITICAL for signal quality (FR4: 70% minimum)
- Multi-dimensional scoring ensures only high-quality springs generate signals
- Test confirmation is most important factor (20 pts + bonus)
- Volume quality is second most important (30 pts)
- Low confidence springs (<70%) are rejected, preventing poor trades

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- Update Module: `backend/src/pattern_engine/spring_detector.py` (add calculate_spring_confidence)
- Unit Tests: `backend/tests/unit/pattern_engine/test_spring_detector.py` (update)
- Integration Tests: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py` (create new)

**Dependencies:**
- `backend/src/models/spring.py`: Spring (from Story 5.1)
- `backend/src/models/test.py`: Test (from Story 5.3)
- `backend/src/models/trading_range.py`: TradingRange (from Epic 3)
- `backend/src/models/phase_classification.py`: PhaseClassification, WyckoffPhase (from Story 4.4)
- `backend/src/models/ohlcv.py`: OHLCVBar (from Epic 1)
- Pydantic BaseModel, Field
- structlog for logging
- Decimal for calculations
- typing.Optional for test parameter

### Data Models

**Spring Model (from Story 5.1):**
```python
class Spring(BaseModel):
    bar: OHLCVBar
    penetration_pct: Decimal  # 0-0.05 (0-5%)
    volume_ratio: Decimal     # <0.7 (FR12 validated)
    recovery_bars: int        # 1-5
    creek_reference: Decimal
    spring_low: Decimal
    recovery_price: Decimal
    # ... other fields
```

**Test Model (from Story 5.3):**
```python
class Test(BaseModel):
    bar: OHLCVBar
    spring_reference: Spring
    volume_decrease_pct: Decimal  # Used for bonus scoring
    holds_spring_low: bool
    # ... other fields
```

**PhaseClassification Model (from Story 4.4):**
```python
class PhaseClassification(BaseModel):
    phase: WyckoffPhase  # Enum: A, B, C, D, E
    confidence: int      # 0-100, used for bonus
    # ... other fields
```

### Algorithm Details

**Spring Confidence Scoring Algorithm:**

```
Purpose: Calculate confidence score (0-100) quantifying spring quality

Input:
- spring: Spring (detected spring pattern)
- test: Optional[Test] (test confirmation if present)
- range: TradingRange (range context)
- phase: PhaseClassification (phase with confidence)

Algorithm:

Step 1: Initialize confidence = 0

Step 2: Volume Quality Scoring (30 points max)
- Extract spring.volume_ratio
- If volume_ratio < 0.4: add 30 points (EXCELLENT)
- Elif volume_ratio < 0.5: add 25 points (IDEAL)
- Else (0.5-0.7): add 15 points (ACCEPTABLE)

Step 3: Spread Narrowness Scoring (15 points max)
- Extract spring.bar.spread_ratio
- If spread_ratio < 0.6: add 15 points (VERY_NARROW)
- Elif spread_ratio < 0.8: add 10 points (NARROW)
- Elif spread_ratio < 1.2: add 5 points (NORMAL)
- Else: add 0 points (WIDE)

Step 4: Recovery Speed Scoring (15 points max)
- Extract spring.recovery_bars
- If recovery_bars == 1: add 15 points (IMMEDIATE)
- Elif recovery_bars <= 3: add 10 points (QUICK)
- Else (4-5): add 5 points (SLOW)

Step 5: Test Confirmation Scoring (20 points + 5 bonus)
- If test is None: add 0 points (NO TEST - will fail FR13)
- Else:
  - Add 20 points (TEST PRESENT)
  - If test.volume_decrease_pct >= 0.3 (30%): add 5 bonus points (EXCELLENT TEST)

Step 6: Range Quality Scoring (10 points max)
- If range has Creek AND Ice: add 10 points (HIGH QUALITY)
- Elif range has Creek OR Ice: add 5 points (MODERATE)
- Else: add 0 points (LOW QUALITY)

Step 7: Penetration Depth Scoring (10 points max)
- Extract spring.penetration_pct
- If 0.01 <= penetration_pct <= 0.02 (1-2%): add 10 points (IDEAL)
- Elif 0.03 <= penetration_pct <= 0.05 (3-5%): add 5 points (ACCEPTABLE)
- Else (<1%): add 7 points (SHALLOW)

Step 8: Phase Confidence Bonus (5 points max)
- Extract phase.confidence
- If phase.confidence >= 80: add 5 bonus points (HIGH)
- Elif phase.confidence >= 60: add 3 bonus points (MODERATE)
- Else: add 0 bonus points (LOW)

Step 9: Calculate Final Confidence
- Sum all points from steps 2-8
- Total possible: 100 base + 5 test bonus + 5 phase bonus = 110
- Cap final_confidence at 100 for reporting

Step 10: Validate FR4 Minimum Threshold
- If final_confidence < 70:
  - Log warning: "Spring confidence below FR4 minimum (70%) - will not generate signal"
  - Spring will be rejected by signal generator (Story 5.5)

Output:
- int: Confidence score 0-100
```

**Scoring Breakdown Table (UPDATED 2025-11-03):**

| Component | Max Points | Scoring Tiers | Change |
|-----------|-----------|---------------|--------|
| Volume Quality | 40 | <0.3x=40, 0.3-0.4x=30, 0.4-0.5x=20, 0.5-0.6x=10, 0.6-0.69x=5 | ↑ from 30 |
| Penetration Depth | 35 | 1-2%=35, 2-3%=25, 3-4%=15, 4-5%=5 | ↑ from 10 |
| Recovery Speed | 25 | 1 bar=25, 2 bars=20, 3 bars=15, 4-5 bars=10 | ↑ from 15 |
| Test Confirmation | 20 | Present=20 (no bonus) | No bonus |
| Creek Strength Bonus | +10 | >=80=10, 70-79=7, 60-69=5, <60=0 | NEW |
| Volume Trend Bonus | +10 | Declining=10, Stable=5, Rising=0 | NEW |
| ~~Spread Narrowness~~ | ~~15~~ | ~~REMOVED~~ | ❌ Deleted |
| ~~Range Quality~~ | ~~10~~ | ~~REMOVED~~ | ❌ Deleted |
| ~~Phase Bonus~~ | ~~5~~ | ~~REMOVED~~ | ❌ Deleted |
| **Total** | **100 (+20)** | Base 100, bonuses can push to 120 (capped at 100) | +20 bonus |

**Example Calculations (UPDATED FORMULA):**

**IDEAL Spring (95-100 points):**
- Volume: 0.25x (ultra-low) → 40 pts
- Penetration: 1.5% (ideal shallow) → 35 pts
- Recovery: 1 bar (immediate) → 25 pts
- Test: Present → 20 pts
- Creek strength: 85 (strong support) → 10 pts bonus
- Volume trend: Declining from previous tests → 10 pts bonus
- **Total: 140 → capped at 100**
- **Quality Tier: EXCELLENT**

**GOOD Spring (75-85 points):**
- Volume: 0.4x (ideal range) → 20 pts
- Penetration: 2.5% (good depth) → 25 pts
- Recovery: 2 bars (strong) → 20 pts
- Test: Present → 20 pts
- Creek strength: 75 (moderate support) → 7 pts bonus
- Volume trend: Stable → 5 pts bonus
- **Total: 97 → capped at 100**
- **Quality Tier: GOOD**

**MARGINAL Spring (55-65 points - REJECTED):**
- Volume: 0.6x (acceptable but high) → 10 pts
- Penetration: 4% (deep) → 5 pts
- Recovery: 4 bars (slow) → 10 pts
- Test: Present → 20 pts
- Creek strength: 60 (weak support) → 5 pts bonus
- Volume trend: Rising (warning) → 0 pts
- **Total: 50 pts (BELOW 70% - NO SIGNAL)**
- **Quality Tier: REJECTED**

### Wyckoff Context

**Confidence Scoring in Wyckoff Methodology:**

**Why Confidence Matters:**
> "Not all Springs are created equal. A Spring with ultra-low volume (0.3x), narrow spread, and immediate recovery is VASTLY superior to one with moderate volume (0.6x), wide spread, and slow recovery. Confidence scoring quantifies spring quality."

**Component Significance:**

**1. Volume Quality (30 points) - MOST IMPORTANT:**
> "Volume is the KEY indicator. Low volume on the Spring proves lack of selling pressure. The lower the volume, the stronger the signal that supply is exhausted."
- <0.4x: Professional accumulation, public absent (30 pts)
- 0.4-0.5x: Ideal accumulation range (25 pts)
- 0.5-0.7x: Acceptable, some public participation (15 pts)

**2. Test Confirmation (20 pts + bonus) - SECOND MOST IMPORTANT:**
> "The Test is PROOF the Spring worked. Without a Test, you can't confirm the shakeout was successful. FR13 makes Test mandatory for signal generation."
- Test present: Confirms shakeout worked (20 pts)
- High volume decrease on test: Exceptional supply exhaustion (+5 bonus)
- No test: Spring NOT tradeable (0 pts, signal rejected)

**3. Recovery Speed (15 pts):**
> "Immediate recovery (1 bar) shows overwhelming demand. The faster the recovery, the stronger the demand absorption."
- 1 bar: Extremely bullish, immediate demand (15 pts)
- 2-3 bars: Strong demand response (10 pts)
- 4-5 bars: Acceptable but slower (5 pts)

**4. Spread Narrowness (15 pts):**
> "Narrow spread on the Spring shows LACK of selling pressure. Wide spreads indicate aggressive selling, even if volume is low."
- Very narrow (<0.6x): Minimal selling pressure (15 pts)
- Narrow (0.6-0.8x): Controlled selling (10 pts)
- Normal (0.8-1.2x): Standard spread (5 pts)
- Wide (>1.2x): Significant selling, lower quality (0 pts)

**5. Range Quality (10 pts):**
> "Springs in high-quality ranges (clear Creek/Ice levels) are more reliable. Well-defined ranges indicate organized accumulation."
- High quality: Clear boundaries, organized (10 pts)
- Moderate: Some definition (5 pts)
- Low quality: Poorly defined, chaotic (0 pts)

**6. Penetration Depth (10 pts):**
> "Ideal penetration is 1-2% below support. Too shallow (<1%) may not shake out stops. Too deep (>5%) risks breakdown."
- 1-2%: Optimal shakeout depth (10 pts)
- 3-5%: Deeper but acceptable (5 pts)
- <1%: Shallow, less effective (7 pts)

**7. Phase Confidence Bonus (5 pts):**
> "Springs in well-confirmed Phase C (high phase confidence) are more reliable. Uncertain phase detection adds risk."
- High phase confidence (>80%): Clear Phase C (5 pts)
- Moderate (60-80%): Probable Phase C (3 pts)
- Low (<60%): Uncertain phase (0 pts)

**FR4 Minimum Threshold (70%):**
> "FR4 requires 70% minimum confidence for signal generation. This threshold filters out marginal springs, ensuring only high-quality setups generate trades. Backtesting should validate this threshold produces acceptable win rate."

**Backtesting Validation Requirements (Enhancement):**

The 70% confidence threshold should be validated through historical backtesting:

1. **Win Rate Analysis:**
   - Springs with 70-79% confidence: Target win rate ~55-65%
   - Springs with 80-89% confidence: Target win rate ~65-75%
   - Springs with 90-100% confidence: Target win rate ~75-85%
   - If actual win rates are significantly lower, consider raising threshold to 75% or 80%

2. **Component Weight Validation:**
   - Analyze which scoring components best correlate with successful springs:
     - Does volume quality (30 pts) actually predict success?
     - Is test confirmation (20 pts) properly weighted?
     - Should recovery speed (15 pts) be weighted higher/lower?
   - Adjust weights based on statistical analysis of historical springs

3. **Threshold Optimization:**
   - Test multiple thresholds (65%, 70%, 75%, 80%) on historical data
   - Calculate expectancy for each threshold level:
     - Expectancy = (Win Rate × Avg Win) - (Loss Rate × Avg Loss)
   - Choose threshold that maximizes expectancy while maintaining sufficient signal frequency

4. **Implementation Note:**
   - For MVP, use 70% threshold based on Wyckoff principles
   - Post-launch, conduct 2-year backtest on 50+ symbols across sectors
   - Refine threshold and component weights based on empirical results
   - Document findings in backtesting report for transparency

**Confidence Ranges:**
- **90-100%**: Textbook spring, highest probability
- **80-89%**: Very high quality, strong setup
- **70-79%**: Good quality, meets minimum (SIGNALS GENERATED)
- **60-69%**: Marginal quality (REJECTED - below threshold)
- **<60%**: Poor quality (REJECTED)

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- Functions: snake_case (`calculate_spring_confidence`)
- Variables: snake_case (`volume_points`, `spread_ratio`, `final_confidence`)
- Constants: UPPER_SNAKE_CASE (`MIN_CONFIDENCE_THRESHOLD`, `MAX_VOLUME_POINTS`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- ✅ Type hints: `def calculate_spring_confidence(spring: Spring, test: Optional[Test], range: TradingRange, phase: PhaseClassification) -> int:`
- ✅ Use Decimal for calculations
- ✅ Validate inputs

**Decimal Precision:**
[Source: [architecture/4-data-models.md](../../../docs/architecture/4-data-models.md)]
- Use Decimal for all volume/penetration comparisons
- Use `Decimal("0.4")` not `0.4` (float)

### Performance Requirements

- Single confidence calculation: <5ms (simple arithmetic)
- No database queries
- No complex algorithms
- Linear scoring based on component values

### Integration Notes

**Epic 5 Workflow:**

```
Story 5.1: Detect Spring → Spring
    ↓
Story 5.2: Validate Spring Volume → Pass/Reject
    ↓
Story 5.3: Detect Test Confirmation → Optional[Test]
    ↓
Story 5.4: Calculate Spring Confidence → int (0-100) ← THIS STORY
    ↓
Story 5.5: Generate Spring Signal → SpringSignal (if confidence >= 70)
    ↓
Story 5.6: SpringDetector Integration → Unified API
```

**Integration with Story 5.5 (Signal Generation):**

Story 5.5 will use confidence to determine signal generation:

```python
# Story 5.5 logic
confidence = calculate_spring_confidence(spring, test, range, phase)

if confidence < 70:
    logger.warning("spring_rejected_low_confidence", confidence=confidence)
    return None  # No signal - below FR4 threshold

# Confidence >= 70: Generate signal
signal = generate_spring_signal(spring, test, confidence, ...)
```

**FR4 Enforcement:**

Confidence scoring is the final quality gate before signal generation:
1. FR12 (Volume): Binary rejection in Story 5.2 (≥0.7x rejected)
2. FR13 (Test): Binary rejection in Story 5.3 (no test = no signal)
3. **FR4 (Confidence): Scored rejection in Story 5.4 (<70% rejected)**

All three must pass for signal generation in Story 5.5.

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/test_spring_detector.py`
- Integration: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py`

### Coverage Requirements
- High-confidence spring (90-100 points)
- Minimum threshold spring (exactly 70 points)
- Below-threshold spring (<70 points, rejected)
- No test confirmation (loses 20-25 points)
- Volume quality scoring (all tiers: <0.4x, 0.4-0.5x, 0.5-0.7x)
- Spread narrowness scoring (all tiers)
- Recovery speed scoring (1, 2-3, 4-5 bars)
- Component scoring breakdown (verify arithmetic)
- Integration with realistic spring data

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../../docs/architecture/12-testing-strategy.md)]
- Unit tests with synthetic data
- Integration tests with realistic spring patterns
- Parametrized tests for scoring tiers
- Coverage >85%
- Validate FR4 threshold enforcement (70% minimum)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-03 | 3.0 | **STORY READY FOR DEVELOPMENT:** Tasks aligned with team-reviewed AC. Status changed to "Ready for Development". Added critical developer note directing to AC as source of truth. Story 5.3 dependency resolved (marked complete). Wyckoff validation completed (95/100 alignment score from William). | Scrum Master (Bob) |
| 2025-11-03 | 2.0 | **MAJOR UPDATE** based on team review: Volume 30→40pts, Penetration 10→35pts, Recovery 15→25pts. REMOVED: Spread (15pts), Range quality (10pts), Phase bonus (5pts). ADDED: Volume trend bonus (+10pts), Creek strength bonus (+10pts). Total: 120pts capped at 100. Function signature changed to include creek and previous_tests parameters. | Scrum Master (Bob) |
| 2025-10-18 | 1.0 | Initial story: Spring Confidence Scoring with multi-dimensional scoring (volume 30pts, spread 15pts, recovery 15pts, test 20pts+bonus, range 10pts, penetration 10pts, phase bonus 5pts), FR4 threshold validation (70%), comprehensive algorithm and Wyckoff context | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - Implementation completed without debugging issues

### Completion Notes List

- Implemented `SpringConfidence` dataclass with total_score, component_scores dict, and quality_tier
- Implemented `calculate_spring_confidence()` function with team-approved formula (2025-11-03):
  - Volume Quality: 40 points (5 tiers)
  - Penetration Depth: 35 points (4 tiers)
  - Recovery Speed: 25 points (4 tiers)
  - Test Confirmation: 20 points (flat)
  - Creek Strength Bonus: +10 points (4 tiers)
  - Volume Trend Bonus: +10 points (3 tiers)
  - Total: 120 points possible, capped at 100
- All scoring components implemented per AC 2-9
- FR4 70% minimum threshold validation implemented
- Comprehensive logging with structlog
- 20 unit tests added (quality tiers, bonuses, validation)
- All 48 spring detector tests pass (100% pass rate)
- Type safety: mypy --strict passes with 0 issues
- Code quality: flake8 passes with 0 issues (ignoring E203 slice whitespace)
- Function signature matches AC: `calculate_spring_confidence(spring, creek, previous_tests=[]) -> SpringConfidence`

### File List

**New Files:**

- `backend/src/models/spring_confidence.py` - SpringConfidence dataclass model

**Modified Files:**

- `backend/src/pattern_engine/detectors/spring_detector.py` - Added calculate_spring_confidence function
- `backend/tests/unit/pattern_engine/detectors/test_spring_detector.py` - Added 20 confidence scoring tests

## QA Results
_Populated by QA agent after completion_
