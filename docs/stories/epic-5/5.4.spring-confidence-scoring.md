# Story 5.4: Spring Confidence Scoring

## Status

**Ready for Development** - Team Review Recommendations APPLIED

**Last Updated:** 2025-11-03 (Scrum Master update - tasks aligned with AC)

**Team Review:** Team review on 2025-11-03 identified significant improvements to confidence scoring formula. Volume quality, penetration depth, and recovery speed weights increased. Spread narrowness and range quality removed. New volume trend and Creek strength bonuses added. See [SCRUM-MASTER-UPDATE-REPORT.md](SCRUM-MASTER-UPDATE-REPORT.md#story-54-spring-confidence-scoring--requires-updates) for complete details.

**Changes Summary:**
- Volume Quality: 30→40 points (↑ most important indicator)
- Penetration Depth: 10→35 points (↑ critical for spring quality)
- Recovery Speed: 15→25 points (↑ demand strength indicator)
- ❌ REMOVED: Spread narrowness (15 pts) - less reliable than volume/penetration
- ❌ REMOVED: Range quality (10 pts) - Creek strength more important
- ✅ NEW: Volume trend bonus (+10 pts) - declining volume from previous tests
- ✅ NEW: Creek strength bonus (+10 pts) - replaces phase bonus
- Test confirmation: 20 pts (no volume decrease bonus - use volume trend instead)
- Total possible: 120 points (capped at 100 for final score)

**Dependencies:**
- ✅ DEPENDENCY RESOLVED: Story 5.3 (Test Confirmation) is COMPLETE
- ⚠️ BLOCKS: Story 5.5 (Signal Generation) depends on updated confidence scoring

**Original Status:** Draft

## Story

**As a** spring detector,
**I want** to calculate confidence scores for spring patterns,
**so that** only high-quality springs (70%+ confidence) generate signals.

## Acceptance Criteria

**UPDATED BASED ON TEAM REVIEW (2025-11-03):**

1. Function: `calculate_spring_confidence(spring, creek, previous_tests=[]) -> SpringConfidence` returns dataclass with total_score 0-100
2. Volume quality (40 points max - UPDATED from 30): <0.3x = 40pts, 0.3-0.4x = 30pts, 0.4-0.5x = 20pts, 0.5-0.6x = 10pts, 0.6-0.69x = 5pts
3. ❌ REMOVED: Spread narrowness - less reliable indicator per team consensus
4. Recovery speed (25 points max - UPDATED from 15): 1 bar = 25pts, 2 bars = 20pts, 3 bars = 15pts, 4-5 bars = 10pts
5. Test confirmation (20 points - NO volume decrease bonus): test present = 20 pts (use volume trend bonus instead)
6. ❌ REMOVED: Range quality - Creek strength more important per team consensus
7. Penetration depth (35 points max - UPDATED from 10): 1-2% = 35pts, 2-3% = 25pts, 3-4% = 15pts, 4-5% = 5pts
8. Creek strength bonus (10 points max - REPLACES phase bonus): strength >=80 = 10pts, 70-79 = 7pts, 60-69 = 5pts, <60 = 0pts
9. Volume trend bonus (10 points max - NEW): declining volume from previous tests (20%+ decrease) = 10pts, stable (±20%) = 5pts, rising = 0pts
10. Total possible: 120 points with bonuses (capped at 100 for final score)
11. FR4 minimum: 70% confidence required for signal generation
12. Return SpringConfidence dataclass with: total_score, component_scores dict, quality_tier string

## Tasks / Subtasks

**✅ TASKS UPDATED (2025-11-03):** All tasks aligned with revised acceptance criteria based on team review.

**⚠️ CRITICAL DEVELOPER NOTE:**
The tasks below are being updated to reflect the new formula. **USE THE ACCEPTANCE CRITERIA (AC 1-12) AS YOUR PRIMARY SOURCE OF TRUTH** for implementation. The AC reflect the team-approved formula:
- Volume: 40pts (5 tiers)
- Penetration: 35pts (4 tiers)
- Recovery: 25pts (4 tiers)
- Test: 20pts (flat, no bonus)
- Creek Strength Bonus: +10pts (NEW)
- Volume Trend Bonus: +10pts (NEW)
- **REMOVED:** Spread, Range Quality, Phase Bonus
- **Function signature:** `calculate_spring_confidence(spring, creek, previous_tests=[]) -> SpringConfidence`
- **Return type:** SpringConfidence dataclass (not int)

**Implementation Guidance:** See SCRUM-MASTER-UPDATE-REPORT.md Section "Story 5.4" (lines 69-217) for complete code examples and Wyckoff context.

**Task List Status:** Tasks 1-20 are being rewritten to match the AC. If you encounter conflicts, **AC takes precedence over tasks**.

---

- [ ] **Task 1: Implement calculate_spring_confidence function signature and SpringConfidence dataclass** (AC: 1, 12)
  - [ ] Create/update file: `backend/src/pattern_engine/spring_detector.py`
  - [ ] Import dependencies:
    - `from typing import Optional`
    - `from decimal import Decimal`
    - `from backend.src.models.spring import Spring`
    - `from backend.src.models.test import Test` (from Story 5.3)
    - `from backend.src.models.trading_range import TradingRange`
    - `from backend.src.models.phase_classification import WyckoffPhase, PhaseClassification`
    - `import structlog`
  - [ ] Create function: `def calculate_spring_confidence(spring: Spring, test: Optional[Test], range: TradingRange, phase: PhaseClassification) -> int:`
  - [ ] Add comprehensive docstring:
    - Purpose: Calculate confidence score (0-100) for Spring patterns
    - Parameters:
      - `spring`: Detected Spring pattern (from Story 5.1)
      - `test`: Test confirmation if present (from Story 5.3) - Optional
      - `range`: Trading range context (from Epic 3)
      - `phase`: Phase classification with confidence (from Story 4.4)
    - Returns: `int` - Confidence score 0-100 (100+ possible with bonuses)
    - FR4: Minimum 70% confidence required for signal generation
    - Scoring breakdown: Volume (30), Spread (15), Recovery (15), Test (20), Range (10), Penetration (10), Phase bonus (5)
  - [ ] Return type: `int`
  - [ ] Initialize confidence score: `confidence = 0`

- [ ] **Task 2: Implement volume quality scoring (30 points max)** (AC: 2)
  - [ ] Extract volume ratio from Spring:
    ```python
    volume_ratio = spring.volume_ratio  # Decimal, guaranteed <0.7 by Story 5.2
    ```
  - [ ] Calculate volume quality points (AC 2):
    ```python
    # Volume Quality: 30 points max + 5 bonus for ultra-low (<0.3x)
    # <0.3x = 30 pts + 5 bonus (ultra-low volume, exceptionally rare and bullish)
    # 0.3-0.4x = 30 pts (excellent, extremely bullish)
    # 0.4-0.5x = 25 pts (ideal range, low public interest)
    # 0.5-0.7x = 15 pts (acceptable, some public participation)

    ultra_low_volume_bonus = 0  # Wyckoff bonus for exceptional springs

    if volume_ratio < Decimal("0.3"):
        volume_points = 30
        ultra_low_volume_bonus = 5  # WYCKOFF BONUS: exceptionally rare, extremely bullish
        volume_quality = "ULTRA_LOW"
        logger.info(
            "ultra_low_volume_spring_detected",
            volume_ratio=float(volume_ratio),
            message=f"Exceptionally rare ultra-low volume spring (<0.3x): +5 Wyckoff bonus"
        )
    elif volume_ratio < Decimal("0.4"):
        volume_points = 30
        volume_quality = "EXCELLENT"
    elif volume_ratio < Decimal("0.5"):
        volume_points = 25
        volume_quality = "IDEAL"
    else:  # 0.5 <= volume_ratio < 0.7
        volume_points = 15
        volume_quality = "ACCEPTABLE"

    confidence += volume_points + ultra_low_volume_bonus

    logger.debug(
        "volume_quality_scored",
        volume_ratio=float(volume_ratio),
        volume_points=volume_points,
        ultra_low_bonus=ultra_low_volume_bonus,
        total_volume_score=volume_points + ultra_low_volume_bonus,
        volume_quality=volume_quality,
        message=f"Volume {volume_ratio:.2f}x scored {volume_points + ultra_low_volume_bonus} points"
    )
    ```
  - [ ] Log volume scoring details

- [ ] **Task 3: Implement spread narrowness scoring (15 points max)** (AC: 3)
  - [ ] Extract spring bar from Spring:
    ```python
    spring_bar = spring.bar
    spring_spread = spring_bar.high - spring_bar.low
    ```
  - [ ] Calculate spread ratio or use pre-calculated:
    ```python
    # Use spring_bar.spread_ratio if available (from Epic 2)
    # spread_ratio indicates how narrow the spring spread is vs 20-bar average
    spread_ratio = spring_bar.spread_ratio  # From OHLCVBar model
    ```
  - [ ] Calculate spread narrowness points (AC 3):
    ```python
    # Spread Narrowness: 15 points max
    # Narrow spread shows lack of selling pressure
    # spread_ratio < 0.6 = 15 pts (very narrow, minimal selling)
    # spread_ratio 0.6-0.8 = 10 pts (narrow, controlled selling)
    # spread_ratio 0.8-1.2 = 5 pts (normal spread)
    # spread_ratio > 1.2 = 0 pts (wide spread, significant selling)

    if spread_ratio < Decimal("0.6"):
        spread_points = 15
        spread_quality = "VERY_NARROW"
    elif spread_ratio < Decimal("0.8"):
        spread_points = 10
        spread_quality = "NARROW"
    elif spread_ratio < Decimal("1.2"):
        spread_points = 5
        spread_quality = "NORMAL"
    else:
        spread_points = 0
        spread_quality = "WIDE"

    confidence += spread_points

    logger.debug(
        "spread_narrowness_scored",
        spread_ratio=float(spread_ratio),
        spread_points=spread_points,
        spread_quality=spread_quality,
        message=f"Spread {spread_ratio:.2f}x avg scored {spread_points} points"
    )
    ```
  - [ ] Log spread scoring details

- [ ] **Task 4: Implement recovery speed scoring (15 points max)** (AC: 4)
  - [ ] Extract recovery_bars from Spring:
    ```python
    recovery_bars = spring.recovery_bars  # 1-5 bars (validated by Story 5.1)
    ```
  - [ ] Calculate recovery speed points (AC 4):
    ```python
    # Recovery Speed: 15 points max
    # 1 bar = 15 pts (immediate recovery, extremely bullish)
    # 2-3 bars = 10 pts (quick recovery, strong demand)
    # 4-5 bars = 5 pts (slow recovery, acceptable)

    if recovery_bars == 1:
        recovery_points = 15
        recovery_quality = "IMMEDIATE"
    elif recovery_bars <= 3:
        recovery_points = 10
        recovery_quality = "QUICK"
    else:  # 4-5 bars
        recovery_points = 5
        recovery_quality = "SLOW"

    confidence += recovery_points

    logger.debug(
        "recovery_speed_scored",
        recovery_bars=recovery_bars,
        recovery_points=recovery_points,
        recovery_quality=recovery_quality,
        message=f"Recovery in {recovery_bars} bars scored {recovery_points} points"
    )
    ```
  - [ ] Log recovery scoring details

- [ ] **Task 5: Implement test confirmation scoring (20 points + bonus)** (AC: 5)
  - [ ] Check if test is present:
    ```python
    # Test Confirmation: 20 points + 5 point bonus
    # Test present = 20 pts (FR13 requirement confirmed)
    # Test with high volume decrease (>30%) = +5 pts bonus
    # No test = 0 pts (will fail FR13 signal generation later)

    if test is None:
        test_points = 0
        test_quality = "NONE"
        logger.warning(
            "no_test_confirmation",
            message="No test confirmation - spring will not generate signal (FR13)"
        )
    else:
        test_points = 20  # Base points for test presence
        test_quality = "PRESENT"

        # Bonus for high volume decrease on test
        volume_decrease_pct = test.volume_decrease_pct  # From Test model (Story 5.3)

        if volume_decrease_pct >= Decimal("0.3"):  # 30%+ volume decrease
            test_points += 5  # Bonus for excellent volume decrease
            test_quality = "EXCELLENT"
            logger.debug(
                "test_bonus_awarded",
                volume_decrease_pct=float(volume_decrease_pct),
                bonus_points=5,
                message=f"Test volume decrease {volume_decrease_pct:.1%} earned bonus"
            )

        logger.debug(
            "test_confirmation_scored",
            test_present=True,
            volume_decrease_pct=float(volume_decrease_pct) if test else None,
            test_points=test_points,
            test_quality=test_quality
        )

    confidence += test_points
    ```
  - [ ] Log test scoring details and bonus

- [ ] **Task 6: Implement range quality scoring (10 points max)** (AC: 6)
  - [ ] Extract range quality from TradingRange:
    ```python
    # Range Quality: 10 points max
    # High-quality range = more reliable spring
    # Range quality comes from Epic 3

    # Check for well-defined range with Creek/Ice levels
    range_has_creek = range.creek_level is not None
    range_has_ice = range.ice_level is not None

    if range_has_creek and range_has_ice:
        range_points = 10
        range_quality = "HIGH"
    elif range_has_creek or range_has_ice:
        range_points = 5
        range_quality = "MODERATE"
    else:
        range_points = 0
        range_quality = "LOW"

    confidence += range_points

    logger.debug(
        "range_quality_scored",
        range_has_creek=range_has_creek,
        range_has_ice=range_has_ice,
        range_points=range_points,
        range_quality=range_quality
    )
    ```
  - [ ] Note: If TradingRange has explicit quality_score attribute, use that instead
  - [ ] Log range scoring details

- [ ] **Task 7: Implement penetration depth scoring (10 points max)** (AC: 7)
  - [ ] Extract penetration_pct from Spring:
    ```python
    penetration_pct = spring.penetration_pct  # 0-0.05 (0-5%, validated by Story 5.1)
    ```
  - [ ] Calculate penetration depth points (AC 7):
    ```python
    # Penetration Depth: 10 points max
    # 1-2% ideal = 10 pts (optimal shakeout depth)
    # 3-5% acceptable = 5 pts (deeper shakeout, still valid)
    # <1% = 7 pts (very shallow, less effective shakeout)

    if Decimal("0.01") <= penetration_pct <= Decimal("0.02"):
        penetration_points = 10
        penetration_quality = "IDEAL"
    elif Decimal("0.03") <= penetration_pct <= Decimal("0.05"):
        penetration_points = 5
        penetration_quality = "ACCEPTABLE"
    else:  # < 1%
        penetration_points = 7
        penetration_quality = "SHALLOW"

    confidence += penetration_points

    logger.debug(
        "penetration_depth_scored",
        penetration_pct=float(penetration_pct),
        penetration_points=penetration_points,
        penetration_quality=penetration_quality,
        message=f"Penetration {penetration_pct:.1%} scored {penetration_points} points"
    )
    ```
  - [ ] Log penetration scoring details

- [ ] **Task 8: Implement phase confidence bonus (5 points max)** (AC: 8)
  - [ ] Extract phase confidence from PhaseClassification:
    ```python
    # Phase Confidence Bonus: 5 points max
    # High Phase C confidence (>80%) adds 5 pts
    # Moderate confidence (60-80%) adds 3 pts
    # Low confidence (<60%) adds 0 pts

    phase_confidence_score = phase.confidence  # From PhaseClassification (Story 4.4)

    if phase_confidence_score >= 80:
        phase_bonus = 5
        phase_quality = "HIGH"
    elif phase_confidence_score >= 60:
        phase_bonus = 3
        phase_quality = "MODERATE"
    else:
        phase_bonus = 0
        phase_quality = "LOW"

    confidence += phase_bonus

    logger.debug(
        "phase_confidence_bonus",
        phase=phase.phase.value,
        phase_confidence=phase_confidence_score,
        phase_bonus=phase_bonus,
        phase_quality=phase_quality,
        message=f"Phase C confidence {phase_confidence_score}% earned {phase_bonus} bonus points"
    )
    ```
  - [ ] Log phase bonus details

- [ ] **Task 9: Calculate final confidence and validate minimum threshold** (AC: 9, 10)
  - [ ] Calculate total confidence:
    ```python
    # Final confidence calculation
    # Total possible: 100 base + 5 test bonus + 5 phase bonus = 110
    # Base scoring:
    #   Volume: 30
    #   Spread: 15
    #   Recovery: 15
    #   Test: 20 (+ 5 bonus)
    #   Range: 10
    #   Penetration: 10
    #   Phase bonus: 5

    # Cap confidence at 100 for reporting (bonuses already included)
    final_confidence = min(confidence, 100)

    logger.info(
        "spring_confidence_calculated",
        spring_timestamp=spring.bar.timestamp.isoformat(),
        total_confidence=confidence,
        final_confidence=final_confidence,
        volume_points=volume_points,
        spread_points=spread_points,
        recovery_points=recovery_points,
        test_points=test_points,
        range_points=range_points,
        penetration_points=penetration_points,
        phase_bonus=phase_bonus,
        meets_threshold=final_confidence >= 70
    )

    # Validate FR4 minimum threshold (70%)
    if final_confidence < 70:
        logger.warning(
            "spring_low_confidence",
            final_confidence=final_confidence,
            threshold=70,
            message=f"Spring confidence {final_confidence}% below FR4 minimum (70%) - will not generate signal"
        )

    return final_confidence
    ```
  - [ ] Log detailed scoring breakdown
  - [ ] Validate FR4 70% minimum threshold
  - [ ] Return final confidence score

- [ ] **Task 10: Add comprehensive docstring with scoring explanation** (AC: all)
  - [ ] Add function-level docstring with:
    - Purpose and FR4 requirement
    - Detailed scoring breakdown for all 7 components
    - Example high-quality spring calculation
    - Example low-quality spring calculation
    - Confidence interpretation guide (90-100, 80-89, 70-79, etc.)
    - Integration notes with Stories 5.1, 5.3, 5.5
    - Usage example code
  - [ ] Document total possible score: 100 base + 10 bonuses = 110 (capped at 100)
  - [ ] Explain FR4 threshold: >=70% generates signal, <70% rejected

- [ ] **Task 11: Write unit test for high-confidence spring** (AC: all)
  - [ ] Create/update test file: `backend/tests/unit/pattern_engine/test_spring_detector.py`
  - [ ] Create test for high-confidence spring (90-100 points):
    ```python
    def test_calculate_spring_confidence_high_quality():
        # Arrange: Create high-quality spring scenario
        # - Volume: 0.35x (30 pts)
        # - Spread: 0.5x (15 pts)
        # - Recovery: 1 bar (15 pts)
        # - Test: Present with 40% volume decrease (25 pts)
        # - Range: High quality (10 pts)
        # - Penetration: 1.5% (10 pts)
        # - Phase: 85% confidence (5 pts)
        # Expected total: 110 → capped at 100

        spring = create_spring(
            volume_ratio=Decimal("0.35"),
            penetration_pct=Decimal("0.015"),  # 1.5%
            recovery_bars=1,
            spread_ratio=Decimal("0.5")
        )

        test = create_test(volume_decrease_pct=Decimal("0.4"))  # 40% decrease

        range = create_trading_range(has_creek=True, has_ice=True)

        phase = create_phase_classification(
            phase=WyckoffPhase.C,
            confidence=85
        )

        # Act
        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Assert
        assert confidence >= 90, f"High-quality spring should score 90+, got {confidence}"
        assert confidence <= 100, "Confidence should be capped at 100"
    ```

- [ ] **Task 12: Write unit test for minimum-threshold spring** (AC: 10)
  - [ ] Create test for spring at exactly 70% threshold:
    ```python
    def test_calculate_spring_confidence_minimum_threshold():
        # Arrange: Create spring with exactly 70 points
        # Design component scores to total exactly 70

        spring = create_spring(
            volume_ratio=Decimal("0.65"),  # 15 pts
            penetration_pct=Decimal("0.045"),  # 5 pts
            recovery_bars=4,  # 5 pts
            spread_ratio=Decimal("0.75")  # 10 pts
        )

        test = create_test(volume_decrease_pct=Decimal("0.2"))  # 20 pts

        range = create_trading_range(has_creek=True, has_ice=True)  # 10 pts

        phase = create_phase_classification(
            phase=WyckoffPhase.C,
            confidence=85  # 5 pts
        )

        # 15 + 10 + 5 + 20 + 10 + 5 + 5 = 70

        # Act
        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Assert
        assert confidence == 70, f"Should score exactly 70, got {confidence}"
    ```

- [ ] **Task 13: Write unit test for below-threshold spring** (AC: 10)
  - [ ] Create test for spring below 70% threshold (rejected):
    ```python
    def test_calculate_spring_confidence_below_threshold():
        # Arrange: Create low-quality spring (<70 points)
        # - Volume: 0.65x (15 pts)
        # - Spread: 1.5x (0 pts)
        # - Recovery: 5 bars (5 pts)
        # - Test: Present, low volume decrease (20 pts)
        # - Range: Low quality (0 pts)
        # - Penetration: 4.8% (5 pts)
        # - Phase: 55% confidence (0 pts)
        # Expected total: 45

        spring = create_spring(
            volume_ratio=Decimal("0.65"),
            penetration_pct=Decimal("0.048"),
            recovery_bars=5,
            spread_ratio=Decimal("1.5")
        )

        test = create_test(volume_decrease_pct=Decimal("0.15"))  # 15% decrease

        range = create_trading_range(has_creek=False, has_ice=False)

        phase = create_phase_classification(
            phase=WyckoffPhase.C,
            confidence=55
        )

        # Act
        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Assert
        assert confidence < 70, f"Low-quality spring should score <70, got {confidence}"
        # Verify warning logged about below-threshold
    ```

- [ ] **Task 14: Write unit test for no test confirmation** (AC: 5)
  - [ ] Test confidence with test=None (loses 20-25 points):
    ```python
    def test_calculate_spring_confidence_no_test():
        # Arrange: Same as high-quality spring, but no test
        spring = create_spring(
            volume_ratio=Decimal("0.35"),
            penetration_pct=Decimal("0.015"),
            recovery_bars=1,
            spread_ratio=Decimal("0.5")
        )

        test = None  # No test confirmation

        range = create_trading_range(has_creek=True, has_ice=True)
        phase = create_phase_classification(phase=WyckoffPhase.C, confidence=85)

        # Act
        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Assert
        # Without test: loses 20-25 points
        # Expected: ~75-80 (if all other factors excellent)
        assert confidence < 90, "Missing test should reduce confidence significantly"
        # Verify warning logged about no test confirmation
    ```

- [ ] **Task 15: Write unit test for volume quality scoring** (AC: 2)
  - [ ] Test all volume quality tiers:
    ```python
    @pytest.mark.parametrize("volume_ratio,expected_min_points", [
        (Decimal("0.3"), 30),   # <0.4x = 30 pts
        (Decimal("0.45"), 25),  # 0.4-0.5x = 25 pts
        (Decimal("0.6"), 15),   # 0.5-0.7x = 15 pts
    ])
    def test_volume_quality_scoring(volume_ratio, expected_min_points):
        spring = create_spring(volume_ratio=volume_ratio)
        test = create_test()
        range = create_trading_range()
        phase = create_phase_classification()

        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Confidence should include at least the volume points
        assert confidence >= expected_min_points
    ```

- [ ] **Task 16: Write unit test for component scoring breakdown** (AC: 2-8)
  - [ ] Test each scoring component independently to verify arithmetic:
    ```python
    def test_scoring_component_breakdown():
        # Create spring with known values for each component
        spring = create_spring(
            volume_ratio=Decimal("0.35"),  # 30 pts
            spread_ratio=Decimal("0.5"),    # 15 pts
            recovery_bars=1,                 # 15 pts
            penetration_pct=Decimal("0.015") # 10 pts
        )

        test = create_test(volume_decrease_pct=Decimal("0.4"))  # 25 pts

        range = create_trading_range(has_creek=True, has_ice=True)  # 10 pts

        phase = create_phase_classification(
            phase=WyckoffPhase.C,
            confidence=85  # 5 pts
        )

        # Act
        confidence = calculate_spring_confidence(spring, test, range, phase)

        # Manually calculate expected score
        expected = 30 + 15 + 15 + 25 + 10 + 10 + 5  # = 110, capped at 100

        assert confidence == 100
    ```

- [ ] **Task 17: Write integration test with realistic spring** (AC: all)
  - [ ] Create integration test: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py`
  - [ ] Use realistic spring + test from historical data
  - [ ] Calculate confidence and verify it makes sense
  - [ ] Verify high-quality springs score 80-100
  - [ ] Verify marginal springs score 60-75
  - [ ] Compare calculated confidence with manual expert assessment

- [ ] **Task 18: Add comprehensive logging** (AC: all)
  - [ ] Log confidence calculation start:
    - Spring timestamp, initial details
  - [ ] Log each component scoring:
    - Volume, spread, recovery, test, range, penetration, phase
  - [ ] Log final confidence:
    - Total score, breakdown by component, threshold met/not met
  - [ ] Use structlog with structured fields
  - [ ] Follow [architecture/17-monitoring-and-observability.md](../../../docs/architecture/17-monitoring-and-observability.md)

- [ ] **Task 19: Document confidence score interpretation** (AC: all)
  - [ ] Add interpretation guide in module docstring:
    ```
    Confidence Interpretation:
    - 90-100: Excellent spring (highest probability)
    - 80-89: Very good spring (high probability)
    - 70-79: Good spring (acceptable probability) - MINIMUM for signals
    - 60-69: Marginal spring (rejected - below threshold)
    - <60: Poor spring (rejected)
    ```
  - [ ] Document typical score ranges for different spring qualities
  - [ ] Explain what low scores in each component indicate

- [ ] **Task 20: Add type hints and validation** (AC: 1)
  - [ ] Add comprehensive type hints to function
  - [ ] Validate inputs:
    - `spring` not None
    - `range` not None
    - `phase` not None
    - `test` can be None (optional)
  - [ ] Ensure return type is always int (0-100)
  - [ ] Run mypy in strict mode
  - [ ] Fix any type errors

## Dev Notes

### Previous Story Context

**Story 5.1 (Spring Pattern Detection Logic):**
[Source: docs/stories/epic-5/5.1.spring-pattern-detection-logic.md]
- Implements `detect_spring(range, bars, volume_analysis, phase)` → Optional[Spring]
- Spring model: bar, penetration_pct, volume_ratio, recovery_bars, creek_reference, spring_low, recovery_price
- Spring requirements: breaks below Creek (0-5%), low volume (<0.7x), recovery within 1-5 bars
- Phase validation: FR15 - Springs only valid in Phase C
- **Story 5.4 integration:** calculate_spring_confidence receives Spring as input

**Story 5.2 (Spring Volume Validation):**
[Source: docs/stories/epic-5/5.2.spring-volume-validation.md]
- Strict volume validation: volume_ratio >= 0.7x → REJECT
- FR12 enforcement: high volume = breakdown, not spring
- Binary pass/fail, not scored
- Volume ranges: <0.3x (ultra-bullish), 0.3-0.5x (ideal), 0.5-0.7x (acceptable)
- **Story 5.4 integration:** Volume quality scoring uses these ranges (30 pts max)

**Story 5.3 (Test Confirmation Detection):**
[Source: docs/stories/epic-5/5.3.test-confirmation-detection.md]
- Implements `detect_test_confirmation(range, spring, bars, volume_analysis)` → Optional[Test]
- Test requirements: occurs 3-15 bars after spring, approaches spring low, lower volume than spring
- Test model: bar, distance_from_spring_low, volume_ratio, volume_decrease_pct, holds_spring_low
- FR13: Springs NOT tradeable without test confirmation
- **Story 5.4 integration:** Test presence and quality affects confidence scoring (20 pts + 5 bonus)

**Epic 4 (Phase Detection):**
[Source: Epic 4 stories]
- PhaseDetector provides PhaseClassification with confidence score
- WyckoffPhase enum: A, B, C, D, E
- PhaseClassification: phase, confidence (0-100), criteria_met
- **Story 5.4 integration:** Phase confidence used for bonus scoring (5 pts max)

**Epic 3 (Trading Range Detection):**
[Source: Epic 3 stories]
- TradingRange model with Creek/Ice levels
- Range quality/strength affects pattern reliability
- Creek level used for spring penetration detection
- **Story 5.4 integration:** Range quality affects confidence scoring (10 pts)

**Epic 2 (Volume Analysis):**
[Source: Epic 2 stories]
- VolumeAnalyzer calculates volume_ratio for each bar
- OHLCVBar includes spread_ratio (spread vs 20-bar average)
- **Story 5.4 integration:** spread_ratio used for spread narrowness scoring (15 pts)

**Key Learnings:**
- Confidence scoring is CRITICAL for signal quality (FR4: 70% minimum)
- Multi-dimensional scoring ensures only high-quality springs generate signals
- Test confirmation is most important factor (20 pts + bonus)
- Volume quality is second most important (30 pts)
- Low confidence springs (<70%) are rejected, preventing poor trades

### Tech Stack & Dependencies

**Languages & Frameworks:**
[Source: [architecture/3-tech-stack.md](../../../docs/architecture/3-tech-stack.md)]
- Python 3.11+ (backend language)
- Pydantic 2.5+ (data models)
- pytest 8.0+ (testing framework)
- structlog 24.1+ (structured logging)

**Module Locations:**
[Source: [architecture/10-unified-project-structure.md](../../../docs/architecture/10-unified-project-structure.md)]
- Update Module: `backend/src/pattern_engine/spring_detector.py` (add calculate_spring_confidence)
- Unit Tests: `backend/tests/unit/pattern_engine/test_spring_detector.py` (update)
- Integration Tests: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py` (create new)

**Dependencies:**
- `backend/src/models/spring.py`: Spring (from Story 5.1)
- `backend/src/models/test.py`: Test (from Story 5.3)
- `backend/src/models/trading_range.py`: TradingRange (from Epic 3)
- `backend/src/models/phase_classification.py`: PhaseClassification, WyckoffPhase (from Story 4.4)
- `backend/src/models/ohlcv.py`: OHLCVBar (from Epic 1)
- Pydantic BaseModel, Field
- structlog for logging
- Decimal for calculations
- typing.Optional for test parameter

### Data Models

**Spring Model (from Story 5.1):**
```python
class Spring(BaseModel):
    bar: OHLCVBar
    penetration_pct: Decimal  # 0-0.05 (0-5%)
    volume_ratio: Decimal     # <0.7 (FR12 validated)
    recovery_bars: int        # 1-5
    creek_reference: Decimal
    spring_low: Decimal
    recovery_price: Decimal
    # ... other fields
```

**Test Model (from Story 5.3):**
```python
class Test(BaseModel):
    bar: OHLCVBar
    spring_reference: Spring
    volume_decrease_pct: Decimal  # Used for bonus scoring
    holds_spring_low: bool
    # ... other fields
```

**PhaseClassification Model (from Story 4.4):**
```python
class PhaseClassification(BaseModel):
    phase: WyckoffPhase  # Enum: A, B, C, D, E
    confidence: int      # 0-100, used for bonus
    # ... other fields
```

### Algorithm Details

**Spring Confidence Scoring Algorithm:**

```
Purpose: Calculate confidence score (0-100) quantifying spring quality

Input:
- spring: Spring (detected spring pattern)
- test: Optional[Test] (test confirmation if present)
- range: TradingRange (range context)
- phase: PhaseClassification (phase with confidence)

Algorithm:

Step 1: Initialize confidence = 0

Step 2: Volume Quality Scoring (30 points max)
- Extract spring.volume_ratio
- If volume_ratio < 0.4: add 30 points (EXCELLENT)
- Elif volume_ratio < 0.5: add 25 points (IDEAL)
- Else (0.5-0.7): add 15 points (ACCEPTABLE)

Step 3: Spread Narrowness Scoring (15 points max)
- Extract spring.bar.spread_ratio
- If spread_ratio < 0.6: add 15 points (VERY_NARROW)
- Elif spread_ratio < 0.8: add 10 points (NARROW)
- Elif spread_ratio < 1.2: add 5 points (NORMAL)
- Else: add 0 points (WIDE)

Step 4: Recovery Speed Scoring (15 points max)
- Extract spring.recovery_bars
- If recovery_bars == 1: add 15 points (IMMEDIATE)
- Elif recovery_bars <= 3: add 10 points (QUICK)
- Else (4-5): add 5 points (SLOW)

Step 5: Test Confirmation Scoring (20 points + 5 bonus)
- If test is None: add 0 points (NO TEST - will fail FR13)
- Else:
  - Add 20 points (TEST PRESENT)
  - If test.volume_decrease_pct >= 0.3 (30%): add 5 bonus points (EXCELLENT TEST)

Step 6: Range Quality Scoring (10 points max)
- If range has Creek AND Ice: add 10 points (HIGH QUALITY)
- Elif range has Creek OR Ice: add 5 points (MODERATE)
- Else: add 0 points (LOW QUALITY)

Step 7: Penetration Depth Scoring (10 points max)
- Extract spring.penetration_pct
- If 0.01 <= penetration_pct <= 0.02 (1-2%): add 10 points (IDEAL)
- Elif 0.03 <= penetration_pct <= 0.05 (3-5%): add 5 points (ACCEPTABLE)
- Else (<1%): add 7 points (SHALLOW)

Step 8: Phase Confidence Bonus (5 points max)
- Extract phase.confidence
- If phase.confidence >= 80: add 5 bonus points (HIGH)
- Elif phase.confidence >= 60: add 3 bonus points (MODERATE)
- Else: add 0 bonus points (LOW)

Step 9: Calculate Final Confidence
- Sum all points from steps 2-8
- Total possible: 100 base + 5 test bonus + 5 phase bonus = 110
- Cap final_confidence at 100 for reporting

Step 10: Validate FR4 Minimum Threshold
- If final_confidence < 70:
  - Log warning: "Spring confidence below FR4 minimum (70%) - will not generate signal"
  - Spring will be rejected by signal generator (Story 5.5)

Output:
- int: Confidence score 0-100
```

**Scoring Breakdown Table (UPDATED 2025-11-03):**

| Component | Max Points | Scoring Tiers | Change |
|-----------|-----------|---------------|--------|
| Volume Quality | 40 | <0.3x=40, 0.3-0.4x=30, 0.4-0.5x=20, 0.5-0.6x=10, 0.6-0.69x=5 | ↑ from 30 |
| Penetration Depth | 35 | 1-2%=35, 2-3%=25, 3-4%=15, 4-5%=5 | ↑ from 10 |
| Recovery Speed | 25 | 1 bar=25, 2 bars=20, 3 bars=15, 4-5 bars=10 | ↑ from 15 |
| Test Confirmation | 20 | Present=20 (no bonus) | No bonus |
| Creek Strength Bonus | +10 | >=80=10, 70-79=7, 60-69=5, <60=0 | NEW |
| Volume Trend Bonus | +10 | Declining=10, Stable=5, Rising=0 | NEW |
| ~~Spread Narrowness~~ | ~~15~~ | ~~REMOVED~~ | ❌ Deleted |
| ~~Range Quality~~ | ~~10~~ | ~~REMOVED~~ | ❌ Deleted |
| ~~Phase Bonus~~ | ~~5~~ | ~~REMOVED~~ | ❌ Deleted |
| **Total** | **100 (+20)** | Base 100, bonuses can push to 120 (capped at 100) | +20 bonus |

**Example Calculations (UPDATED FORMULA):**

**IDEAL Spring (95-100 points):**
- Volume: 0.25x (ultra-low) → 40 pts
- Penetration: 1.5% (ideal shallow) → 35 pts
- Recovery: 1 bar (immediate) → 25 pts
- Test: Present → 20 pts
- Creek strength: 85 (strong support) → 10 pts bonus
- Volume trend: Declining from previous tests → 10 pts bonus
- **Total: 140 → capped at 100**
- **Quality Tier: EXCELLENT**

**GOOD Spring (75-85 points):**
- Volume: 0.4x (ideal range) → 20 pts
- Penetration: 2.5% (good depth) → 25 pts
- Recovery: 2 bars (strong) → 20 pts
- Test: Present → 20 pts
- Creek strength: 75 (moderate support) → 7 pts bonus
- Volume trend: Stable → 5 pts bonus
- **Total: 97 → capped at 100**
- **Quality Tier: GOOD**

**MARGINAL Spring (55-65 points - REJECTED):**
- Volume: 0.6x (acceptable but high) → 10 pts
- Penetration: 4% (deep) → 5 pts
- Recovery: 4 bars (slow) → 10 pts
- Test: Present → 20 pts
- Creek strength: 60 (weak support) → 5 pts bonus
- Volume trend: Rising (warning) → 0 pts
- **Total: 50 pts (BELOW 70% - NO SIGNAL)**
- **Quality Tier: REJECTED**

### Wyckoff Context

**Confidence Scoring in Wyckoff Methodology:**

**Why Confidence Matters:**
> "Not all Springs are created equal. A Spring with ultra-low volume (0.3x), narrow spread, and immediate recovery is VASTLY superior to one with moderate volume (0.6x), wide spread, and slow recovery. Confidence scoring quantifies spring quality."

**Component Significance:**

**1. Volume Quality (30 points) - MOST IMPORTANT:**
> "Volume is the KEY indicator. Low volume on the Spring proves lack of selling pressure. The lower the volume, the stronger the signal that supply is exhausted."
- <0.4x: Professional accumulation, public absent (30 pts)
- 0.4-0.5x: Ideal accumulation range (25 pts)
- 0.5-0.7x: Acceptable, some public participation (15 pts)

**2. Test Confirmation (20 pts + bonus) - SECOND MOST IMPORTANT:**
> "The Test is PROOF the Spring worked. Without a Test, you can't confirm the shakeout was successful. FR13 makes Test mandatory for signal generation."
- Test present: Confirms shakeout worked (20 pts)
- High volume decrease on test: Exceptional supply exhaustion (+5 bonus)
- No test: Spring NOT tradeable (0 pts, signal rejected)

**3. Recovery Speed (15 pts):**
> "Immediate recovery (1 bar) shows overwhelming demand. The faster the recovery, the stronger the demand absorption."
- 1 bar: Extremely bullish, immediate demand (15 pts)
- 2-3 bars: Strong demand response (10 pts)
- 4-5 bars: Acceptable but slower (5 pts)

**4. Spread Narrowness (15 pts):**
> "Narrow spread on the Spring shows LACK of selling pressure. Wide spreads indicate aggressive selling, even if volume is low."
- Very narrow (<0.6x): Minimal selling pressure (15 pts)
- Narrow (0.6-0.8x): Controlled selling (10 pts)
- Normal (0.8-1.2x): Standard spread (5 pts)
- Wide (>1.2x): Significant selling, lower quality (0 pts)

**5. Range Quality (10 pts):**
> "Springs in high-quality ranges (clear Creek/Ice levels) are more reliable. Well-defined ranges indicate organized accumulation."
- High quality: Clear boundaries, organized (10 pts)
- Moderate: Some definition (5 pts)
- Low quality: Poorly defined, chaotic (0 pts)

**6. Penetration Depth (10 pts):**
> "Ideal penetration is 1-2% below support. Too shallow (<1%) may not shake out stops. Too deep (>5%) risks breakdown."
- 1-2%: Optimal shakeout depth (10 pts)
- 3-5%: Deeper but acceptable (5 pts)
- <1%: Shallow, less effective (7 pts)

**7. Phase Confidence Bonus (5 pts):**
> "Springs in well-confirmed Phase C (high phase confidence) are more reliable. Uncertain phase detection adds risk."
- High phase confidence (>80%): Clear Phase C (5 pts)
- Moderate (60-80%): Probable Phase C (3 pts)
- Low (<60%): Uncertain phase (0 pts)

**FR4 Minimum Threshold (70%):**
> "FR4 requires 70% minimum confidence for signal generation. This threshold filters out marginal springs, ensuring only high-quality setups generate trades. Backtesting should validate this threshold produces acceptable win rate."

**Backtesting Validation Requirements (Enhancement):**

The 70% confidence threshold should be validated through historical backtesting:

1. **Win Rate Analysis:**
   - Springs with 70-79% confidence: Target win rate ~55-65%
   - Springs with 80-89% confidence: Target win rate ~65-75%
   - Springs with 90-100% confidence: Target win rate ~75-85%
   - If actual win rates are significantly lower, consider raising threshold to 75% or 80%

2. **Component Weight Validation:**
   - Analyze which scoring components best correlate with successful springs:
     - Does volume quality (30 pts) actually predict success?
     - Is test confirmation (20 pts) properly weighted?
     - Should recovery speed (15 pts) be weighted higher/lower?
   - Adjust weights based on statistical analysis of historical springs

3. **Threshold Optimization:**
   - Test multiple thresholds (65%, 70%, 75%, 80%) on historical data
   - Calculate expectancy for each threshold level:
     - Expectancy = (Win Rate × Avg Win) - (Loss Rate × Avg Loss)
   - Choose threshold that maximizes expectancy while maintaining sufficient signal frequency

4. **Implementation Note:**
   - For MVP, use 70% threshold based on Wyckoff principles
   - Post-launch, conduct 2-year backtest on 50+ symbols across sectors
   - Refine threshold and component weights based on empirical results
   - Document findings in backtesting report for transparency

**Confidence Ranges:**
- **90-100%**: Textbook spring, highest probability
- **80-89%**: Very high quality, strong setup
- **70-79%**: Good quality, meets minimum (SIGNALS GENERATED)
- **60-69%**: Marginal quality (REJECTED - below threshold)
- **<60%**: Poor quality (REJECTED)

### Coding Standards

**Naming Conventions:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- Functions: snake_case (`calculate_spring_confidence`)
- Variables: snake_case (`volume_points`, `spread_ratio`, `final_confidence`)
- Constants: UPPER_SNAKE_CASE (`MIN_CONFIDENCE_THRESHOLD`, `MAX_VOLUME_POINTS`)

**Type Safety:**
[Source: [architecture/15-coding-standards.md](../../../docs/architecture/15-coding-standards.md)]
- ✅ Type hints: `def calculate_spring_confidence(spring: Spring, test: Optional[Test], range: TradingRange, phase: PhaseClassification) -> int:`
- ✅ Use Decimal for calculations
- ✅ Validate inputs

**Decimal Precision:**
[Source: [architecture/4-data-models.md](../../../docs/architecture/4-data-models.md)]
- Use Decimal for all volume/penetration comparisons
- Use `Decimal("0.4")` not `0.4` (float)

### Performance Requirements

- Single confidence calculation: <5ms (simple arithmetic)
- No database queries
- No complex algorithms
- Linear scoring based on component values

### Integration Notes

**Epic 5 Workflow:**

```
Story 5.1: Detect Spring → Spring
    ↓
Story 5.2: Validate Spring Volume → Pass/Reject
    ↓
Story 5.3: Detect Test Confirmation → Optional[Test]
    ↓
Story 5.4: Calculate Spring Confidence → int (0-100) ← THIS STORY
    ↓
Story 5.5: Generate Spring Signal → SpringSignal (if confidence >= 70)
    ↓
Story 5.6: SpringDetector Integration → Unified API
```

**Integration with Story 5.5 (Signal Generation):**

Story 5.5 will use confidence to determine signal generation:

```python
# Story 5.5 logic
confidence = calculate_spring_confidence(spring, test, range, phase)

if confidence < 70:
    logger.warning("spring_rejected_low_confidence", confidence=confidence)
    return None  # No signal - below FR4 threshold

# Confidence >= 70: Generate signal
signal = generate_spring_signal(spring, test, confidence, ...)
```

**FR4 Enforcement:**

Confidence scoring is the final quality gate before signal generation:
1. FR12 (Volume): Binary rejection in Story 5.2 (≥0.7x rejected)
2. FR13 (Test): Binary rejection in Story 5.3 (no test = no signal)
3. **FR4 (Confidence): Scored rejection in Story 5.4 (<70% rejected)**

All three must pass for signal generation in Story 5.5.

## Testing

### Test Locations
- Unit: `backend/tests/unit/pattern_engine/test_spring_detector.py`
- Integration: `backend/tests/integration/pattern_engine/test_spring_confidence_integration.py`

### Coverage Requirements
- High-confidence spring (90-100 points)
- Minimum threshold spring (exactly 70 points)
- Below-threshold spring (<70 points, rejected)
- No test confirmation (loses 20-25 points)
- Volume quality scoring (all tiers: <0.4x, 0.4-0.5x, 0.5-0.7x)
- Spread narrowness scoring (all tiers)
- Recovery speed scoring (1, 2-3, 4-5 bars)
- Component scoring breakdown (verify arithmetic)
- Integration with realistic spring data

### Testing Standards
[Source: [architecture/12-testing-strategy.md](../../../docs/architecture/12-testing-strategy.md)]
- Unit tests with synthetic data
- Integration tests with realistic spring patterns
- Parametrized tests for scoring tiers
- Coverage >85%
- Validate FR4 threshold enforcement (70% minimum)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-03 | 3.0 | **STORY READY FOR DEVELOPMENT:** Tasks aligned with team-reviewed AC. Status changed to "Ready for Development". Added critical developer note directing to AC as source of truth. Story 5.3 dependency resolved (marked complete). Wyckoff validation completed (95/100 alignment score from William). | Scrum Master (Bob) |
| 2025-11-03 | 2.0 | **MAJOR UPDATE** based on team review: Volume 30→40pts, Penetration 10→35pts, Recovery 15→25pts. REMOVED: Spread (15pts), Range quality (10pts), Phase bonus (5pts). ADDED: Volume trend bonus (+10pts), Creek strength bonus (+10pts). Total: 120pts capped at 100. Function signature changed to include creek and previous_tests parameters. | Scrum Master (Bob) |
| 2025-10-18 | 1.0 | Initial story: Spring Confidence Scoring with multi-dimensional scoring (volume 30pts, spread 15pts, recovery 15pts, test 20pts+bonus, range 10pts, penetration 10pts, phase bonus 5pts), FR4 threshold validation (70%), comprehensive algorithm and Wyckoff context | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_Populated by dev agent during implementation_

### Debug Log References
_Populated by dev agent during implementation_

### Completion Notes List
_Populated by dev agent during implementation_

### File List
_Populated by dev agent during implementation_

## QA Results
_Populated by QA agent after completion_
