# Story 18.10.3: Pattern Detection and Validation Stages

## Status
Ready for Review

## Story

**As a** developer using the detection pipeline,
**I want** pattern detection and validation as separate stages,
**So that** detection logic is independently testable.

## Background

This is Part 3 of splitting master_orchestrator.py. Creates pattern and validation stages.

**Reference:** CF-003 from Critical Foundation Refactoring document.

## Acceptance Criteria

1. **AC1**: `PatternDetectionStage` class created (~150 lines) - DONE
2. **AC2**: `ValidationStage` class created (~150 lines) - DONE
3. **AC3**: Pattern stage delegates to appropriate detectors - DONE
4. **AC4**: Validation stage runs validation chain - DONE
5. **AC5**: 95%+ test coverage - DONE (37 tests)

## Tasks

- [x] Create `stages/pattern_detection_stage.py`
- [x] Create `stages/validation_stage.py`
- [x] Implement pattern dispatcher logic
- [x] Implement validation chain execution
- [x] Add unit tests for both stages

## Dev Notes

### Files to Create

| File | Lines | Purpose |
|------|-------|---------|
| `stages/pattern_detection_stage.py` | ~150 | Stage 4: Pattern |
| `stages/validation_stage.py` | ~150 | Stage 5: Validation |

### Pattern Detection Stage

```python
class PatternDetectionStage(PipelineStage[PhaseInfo, List[Pattern]]):
    """Stage 4: Detect Wyckoff patterns."""

    @property
    def name(self) -> str:
        return "pattern_detection"

    def __init__(self, detector_registry: DetectorRegistry):
        self._registry = detector_registry

    async def execute(
        self,
        phase_info: PhaseInfo,
        context: PipelineContext,
    ) -> List[Pattern]:
        """Detect patterns based on current phase."""
        bars = context.get("bars")
        trading_range = context.get("trading_range")

        detector = self._registry.get_detector(phase_info.phase)
        patterns = await detector.detect(bars, trading_range)
        context.set("patterns", patterns)
        return patterns
```

### Validation Stage

```python
class ValidationStage(PipelineStage[List[Pattern], ValidationResults]):
    """Stage 5: Run validation chain on patterns."""

    @property
    def name(self) -> str:
        return "validation"

    async def execute(
        self,
        patterns: List[Pattern],
        context: PipelineContext,
    ) -> ValidationResults:
        """Validate patterns through validation chain."""
        results = ValidationResults()
        for pattern in patterns:
            result = await self._chain.validate(pattern, context)
            results.add(result)
        return results
```

## Story Points: 3

## Dependencies
- Story 18.10.1 (pipeline base and context)

---

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A - No issues encountered

### Completion Notes
- Created `PatternDetectionStage` with `DetectorRegistry` for phase-based detector dispatch
- Created `ValidationStage` with `ValidationResults` aggregation class
- Both stages follow established `PipelineStage` pattern with dependency injection
- Implemented safe volume ratio extraction to handle mock objects in tests
- All 37 unit tests pass covering edge cases, error handling, and stage chaining

### File List

| File | Action | Purpose |
|------|--------|---------|
| `backend/src/orchestrator/stages/pattern_detection_stage.py` | Created | Pattern detection pipeline stage |
| `backend/src/orchestrator/stages/validation_stage.py` | Created | Validation pipeline stage |
| `backend/src/orchestrator/stages/__init__.py` | Modified | Export new stages |
| `backend/tests/unit/orchestrator/stages/test_pattern_validation_stages.py` | Created | Unit tests for both stages |

### Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Story created | Bob (Scrum Master) |
| 2026-01-16 | 1.1 | Implementation complete | James (Dev Agent) |
