# Story 18.10.4: Signal Generation and Risk Assessment Stages

## Status
Ready for Review

## Story

**As a** developer using the signal pipeline,
**I want** signal generation and risk assessment as separate stages,
**So that** each concern is independently testable.

## Background

This is Part 4 of splitting master_orchestrator.py. Creates final pipeline stages.

**Reference:** CF-003 from Critical Foundation Refactoring document.

## Acceptance Criteria

1. **AC1**: `SignalGenerationStage` class created (~100 lines)
2. **AC2**: `RiskAssessmentStage` class created (~100 lines)
3. **AC3**: Signal stage creates signals from validated patterns
4. **AC4**: Risk stage applies position sizing
5. **AC5**: 95%+ test coverage

## Tasks

- [x] Create `stages/signal_generation_stage.py`
- [x] Create `stages/risk_assessment_stage.py`
- [x] Implement signal creation logic
- [x] Implement risk assessment logic
- [x] Add unit tests for both stages

## Dev Notes

### Files to Create

| File | Lines | Purpose |
|------|-------|---------|
| `stages/signal_generation_stage.py` | ~100 | Stage 6: Signals |
| `stages/risk_assessment_stage.py` | ~100 | Stage 7: Risk |

### Signal Generation Stage

```python
class SignalGenerationStage(PipelineStage[ValidationResults, List[Signal]]):
    """Stage 6: Generate signals from validated patterns."""

    @property
    def name(self) -> str:
        return "signal_generation"

    async def execute(
        self,
        validation_results: ValidationResults,
        context: PipelineContext,
    ) -> List[Signal]:
        """Generate signals for passed validations."""
        signals = []
        for result in validation_results.passed:
            signal = await self._generator.generate(
                result.pattern,
                context.get("trading_range"),
            )
            if signal:
                signals.append(signal)
        return signals
```

### Risk Assessment Stage

```python
class RiskAssessmentStage(PipelineStage[List[Signal], List[Signal]]):
    """Stage 7: Apply risk management to signals."""

    @property
    def name(self) -> str:
        return "risk_assessment"

    async def execute(
        self,
        signals: List[Signal],
        context: PipelineContext,
    ) -> List[Signal]:
        """Apply position sizing and risk limits."""
        assessed = []
        for signal in signals:
            sized = await self._risk_manager.apply_sizing(signal)
            if sized:
                assessed.append(sized)
        return assessed
```

## Story Points: 2

## Dependencies
- Story 18.10.1 (pipeline base and context)

## File List

| File | Status | Description |
|------|--------|-------------|
| `backend/src/orchestrator/stages/signal_generation_stage.py` | Created | SignalGenerationStage - Stage 6 |
| `backend/src/orchestrator/stages/risk_assessment_stage.py` | Created | RiskAssessmentStage - Stage 7 |
| `backend/src/orchestrator/stages/__init__.py` | Modified | Added exports for new stages |
| `backend/tests/unit/orchestrator/stages/test_signal_risk_stages.py` | Created | Unit tests for both stages (29 tests) |

## Dev Agent Record

### Agent Model Used
Claude claude-opus-4-5-20251101 (James - Full Stack Developer)

### Debug Log References
- All tests passing (29 tests)
- Linting passed (ruff)
- Type checking passed (mypy)

### Completion Notes
- Implemented SignalGenerationStage with SignalGenerator protocol
- Implemented RiskAssessmentStage with RiskAssessor protocol
- Both stages use dependency injection for easy testing
- Stages handle errors gracefully without failing entire pipeline
- Context keys documented and used consistently

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Story created | Bob (Scrum Master) |
| 2026-01-16 | 1.1 | Implementation complete | James (Dev Agent) |
