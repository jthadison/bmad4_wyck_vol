# Story 18.2: Fix Thread-Unsafe Singleton in CampaignManager

## Status
Ready for Review

## Story

**As a** developer deploying the system in production,
**I want** thread-safe singleton implementation for CampaignManager,
**So that** concurrent requests don't cause race conditions or initialization bugs.

## Background

### Problem Statement

**File:** `backend/src/campaign_management/campaign_manager.py`
**Lines:** 132-165

The CampaignManager uses a manual singleton pattern with `__new__` and `hasattr(self, "_initialized")` check that is thread-unsafe.

### Current Problematic Implementation

```python
class CampaignManager:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if hasattr(self, "_initialized"):
            return
        self._initialized = True
        # ... initialization
```

### Race Condition Scenario

1. Thread A: `cls._instance is None` → True
2. Thread B: `cls._instance is None` → True (before A sets it)
3. Thread A: Creates instance
4. Thread B: Creates SECOND instance
5. Both threads now have different instances

### SOLID Violations

| Principle | Violation |
|-----------|-----------|
| **SRP** | Creation + allocation + events in one class |
| **DIP** | Hardcoded allocation percentages |

## Acceptance Criteria

1. **AC2.1**: Thread-safe under concurrent access (verified by concurrent tests)
2. **AC2.2**: Dependencies are injected, not hardcoded
3. **AC2.3**: No `hasattr` checks in `__init__`
4. **AC2.4**: Unit testable with mock dependencies
5. **AC2.5**: Existing functionality preserved (all tests pass)
6. **AC2.6**: Singleton instance retrievable via dependency injection container
7. **AC2.7**: 95%+ test coverage on refactored code

## Tasks / Subtasks

- [x] **Task 1**: Design Thread-Safe Pattern
  - [x] Choose between metaclass vs DI container approach (recommend DI)
  - [x] Document the chosen approach
  - [x] Create implementation plan

- [x] **Task 2**: Implement Dependency Injection Pattern
  - [x] Create factory function in campaign_manager.py (kept co-located for simplicity)
  - [x] Use double-checked locking with threading.Lock (lru_cache rejected due to CampaignRepository not being hashable)
  - [x] Define injectable dependencies (allocator, event_bus, repository)
  - [x] Add type hints for all dependencies

- [x] **Task 3**: Refactor CampaignManager
  - [x] Remove `__new__` override
  - [x] Remove `hasattr` check in `__init__`
  - [x] Accept dependencies via `__init__` parameters
  - [x] Make class a regular class (not singleton-aware)

- [x] **Task 4**: Update Consumers
  - [x] Find all places that instantiate CampaignManager directly
  - [x] Update to use DI container factory function
  - [x] Verify all call sites are updated

- [x] **Task 5**: Add Concurrent Access Tests
  - [x] Create test with multiple threads accessing singleton
  - [x] Verify all threads get same instance
  - [x] Test initialization race conditions
  - [x] Test with mock dependencies

- [x] **Task 6**: Cleanup and Documentation
  - [x] Update module docstrings
  - [x] Add usage examples in docstring
  - [x] Run full test suite
  - [x] Verify no regressions

## Dev Notes

### Context

This story implements **CF-004** from the Critical Foundation Refactoring document.

This is a quick win with no dependencies - can be done in parallel with other Phase 1 stories.

### Recommended Solution: Dependency Injection Container

```python
# backend/src/orchestrator/container.py

from functools import lru_cache
from typing import Optional

@lru_cache(maxsize=1)
def get_campaign_manager() -> CampaignManager:
    """
    Get singleton campaign manager instance.

    Thread-safe via lru_cache - only first call creates instance.
    All subsequent calls return the same instance.

    Returns:
        CampaignManager: The singleton instance
    """
    return CampaignManager(
        allocator=get_campaign_allocator(),
        event_bus=get_event_bus(),
        repository=get_campaign_repository(),
    )


def get_campaign_manager_for_testing(
    allocator: Optional[CampaignAllocator] = None,
    event_bus: Optional[EventBus] = None,
    repository: Optional[CampaignRepository] = None,
) -> CampaignManager:
    """
    Create CampaignManager for testing with optional mock dependencies.

    Does NOT use singleton - each call creates new instance.
    """
    return CampaignManager(
        allocator=allocator or MockCampaignAllocator(),
        event_bus=event_bus or MockEventBus(),
        repository=repository or MockCampaignRepository(),
    )
```

### Refactored CampaignManager

```python
# backend/src/campaign_management/campaign_manager.py

class CampaignManager:
    """
    Manages trading campaigns and position allocation.

    NOTE: Do not instantiate directly. Use get_campaign_manager() from container.
    """

    def __init__(
        self,
        allocator: CampaignAllocator,
        event_bus: EventBus,
        repository: CampaignRepository,
    ):
        """
        Initialize campaign manager with injected dependencies.

        Args:
            allocator: Handles campaign allocation logic
            event_bus: Publishes campaign events
            repository: Persists campaign data
        """
        self._allocator = allocator
        self._event_bus = event_bus
        self._repository = repository

        # Initialize state
        self._active_campaigns: Dict[str, Campaign] = {}

        logger.info("CampaignManager initialized")

    # ... rest of methods unchanged, but use injected dependencies
```

### Alternative: Thread-Safe Metaclass (Not Recommended)

If DI is not feasible, use a thread-safe metaclass:

```python
import threading

class SingletonMeta(type):
    """Thread-safe singleton metaclass."""
    _instances = {}
    _lock = threading.Lock()

    def __call__(cls, *args, **kwargs):
        with cls._lock:
            if cls not in cls._instances:
                instance = super().__call__(*args, **kwargs)
                cls._instances[cls] = instance
        return cls._instances[cls]

class CampaignManager(metaclass=SingletonMeta):
    def __init__(self, ...):
        # Normal init, no hasattr check needed
        pass
```

**Why DI is preferred:**
- More testable (can inject mocks)
- Clearer dependency graph
- Easier to understand and maintain
- No metaclass magic

### Files to Modify

| File | Changes |
|------|---------|
| `backend/src/campaign_management/campaign_manager.py` | Remove singleton pattern, accept DI |
| `backend/src/orchestrator/container.py` | Add factory function with lru_cache |
| Various consumer files | Update to use factory function |

### Finding Consumers

```bash
# Find all files that import CampaignManager
grep -r "from.*campaign_manager import" backend/src/
grep -r "CampaignManager()" backend/src/
```

### Testing Strategy

1. **Unit tests**: Mock all dependencies
2. **Concurrent tests**: Multiple threads accessing singleton
3. **Integration tests**: Full campaign flow with real dependencies
4. **Regression tests**: All existing tests must pass

### Example Concurrent Test

```python
# backend/tests/campaign_management/test_campaign_manager_thread_safety.py

import threading
import pytest
from src.orchestrator.container import get_campaign_manager

def test_singleton_thread_safety():
    """Verify same instance returned from multiple threads."""
    instances = []
    errors = []

    def get_instance():
        try:
            instance = get_campaign_manager()
            instances.append(id(instance))
        except Exception as e:
            errors.append(e)

    # Create 10 threads accessing singleton concurrently
    threads = [threading.Thread(target=get_instance) for _ in range(10)]

    for t in threads:
        t.start()
    for t in threads:
        t.join()

    assert len(errors) == 0, f"Errors: {errors}"
    assert len(set(instances)) == 1, "All threads should get same instance"

def test_campaign_manager_with_mocks():
    """Verify CampaignManager works with mock dependencies."""
    mock_allocator = MagicMock()
    mock_event_bus = MagicMock()
    mock_repository = MagicMock()

    manager = CampaignManager(
        allocator=mock_allocator,
        event_bus=mock_event_bus,
        repository=mock_repository,
    )

    # Test behavior with mocks
    manager.create_campaign(...)
    mock_repository.save.assert_called_once()
```

### Backward Compatibility

**Migration Strategy:**

```python
# Old code (needs migration):
manager = CampaignManager()

# New code (preferred):
from src.orchestrator.container import get_campaign_manager
manager = get_campaign_manager()

# For testing:
manager = CampaignManager(
    allocator=mock_allocator,
    event_bus=mock_event_bus,
    repository=mock_repository,
)
```

### Edge Cases to Handle

1. Multiple threads calling `get_campaign_manager()` simultaneously
2. Clearing cache for testing (need `get_campaign_manager.cache_clear()`)
3. Late initialization of dependencies
4. Error during dependency creation

### Performance Considerations

- `lru_cache` lookup is O(1)
- No performance regression from this change
- Actually slightly faster (no hasattr check)

### Dependencies

- None - this story can be done first

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-14 | 1.0 | Story created from CF-004 | Bob (Scrum Master) |
| 2026-01-14 | 1.1 | Implementation complete - thread-safe singleton via DI pattern | James (Dev Agent) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References
N/A - No significant debugging issues encountered

### Completion Notes List
1. **Design Decision**: Used double-checked locking with `threading.Lock` instead of `@lru_cache(maxsize=1)` because `CampaignRepository` is not hashable, making `lru_cache` unsuitable.
2. **Factory Location**: Kept factory functions (`get_campaign_manager`, `create_campaign_manager_for_testing`, `reset_campaign_manager_singleton`) co-located in `campaign_manager.py` rather than `container.py` for simpler imports and clearer module boundaries.
3. **Thread-Safety Pattern**: Implemented classic double-checked locking pattern with fast-path optimization (check without lock, then acquire lock and re-check).
4. **Dependency Injection**: Added optional `allocator` and `event_bus` parameters to `__init__` for testability. Defaults to real implementations when not provided.
5. **Test Coverage**: Created 13 comprehensive thread-safety tests covering concurrent access, singleton reset, testing factory, DI, and verification that `__new__` pattern was removed.
6. **Pre-existing Issues**: Identified pre-existing test failures unrelated to this story (TradeSignal validation with `created_at=None`, CampaignService API changes). These are not caused by Story 18.2 changes.

### File List
**Files Created**:
- `backend/tests/unit/campaign_management/test_campaign_manager_thread_safety.py` - 13 thread-safety tests

**Files Modified**:
- `backend/src/campaign_management/campaign_manager.py` - Refactored singleton pattern, added DI support, added factory functions

## QA Results
[To be filled by QA agent]
