# Story 10.9: WebSocket Real-Time Updates

## Status
Done

## Story
**As a** system,
**I want** WebSocket connections to push signal updates to the UI in real-time,
**so that** traders see new signals immediately without page refresh.

## Acceptance Criteria
1. Socket.IO client connects to backend on page load
2. Event subscriptions: `signal:new`, `signal:executed`, `signal:rejected`, `portfolio:updated`, `campaign:updated`
3. Automatic reconnection: exponential backoff on disconnect
4. Optimistic updates: UI updates immediately, rollback on error
5. Toast notifications: non-intrusive alerts for new signals
6. Connection status: indicator shows connected/disconnected state
7. Service: `websocketService.ts`
8. State integration: WebSocket updates trigger Pinia store updates
9. Unit test: mock WebSocket events trigger UI updates
10. Performance: handle 10 events/second without UI lag

## Tasks / Subtasks

- [ ] Backend WebSocket Implementation (AC: 1, 2)
  - [ ] Create WebSocket endpoint at `ws://localhost:8000/ws` in FastAPI
  - [ ] Implement ConnectionManager class to track active WebSocket connections
  - [ ] Add connection_id (UUID) and sequence_number tracking per connection
  - [ ] Implement WebSocket event emission methods: emit_pattern_detected(), emit_signal_generated(), emit_signal_executed(), emit_signal_rejected(), emit_portfolio_updated(), emit_campaign_updated()
  - [ ] Define WebSocket message format with types: "connected", "pattern_detected", "signal:new", "signal:executed", "signal:rejected", "portfolio:updated", "campaign:updated", "batch_update"
  - [ ] Implement sequence number increment per connection for message ordering
  - [ ] Add timestamp (UTC) to all WebSocket messages
  - [ ] Integrate with Pattern Detection Engine to emit pattern_detected events
  - [ ] Integrate with Signal Generator to emit signal events (new, executed, rejected)
  - [ ] Integrate with Risk Management Service to emit portfolio_updated events
  - [ ] Add heartbeat/ping mechanism (every 30 seconds) to keep connections alive
  - [ ] Implement graceful disconnect handling with cleanup
  - [ ] Write unit test for WebSocket connection lifecycle
  - [ ] Write unit test for event emission with correct message format

- [ ] Frontend WebSocket Service - Core Connection (AC: 1, 3, 6, 7)
  - [ ] Create `frontend/src/services/websocketService.ts` service module
  - [ ] Implement WebSocketService class with singleton pattern
  - [ ] Add connect() method: establish WebSocket connection to `ws://localhost:8000/ws`
  - [ ] Add disconnect() method: gracefully close connection
  - [ ] Store connection_id and last_sequence_number from server
  - [ ] Implement connection status tracking: "disconnected", "connecting", "connected", "reconnecting", "error"
  - [ ] Expose reactive connectionStatus ref for components to observe
  - [ ] Add event listeners for WebSocket: onopen, onmessage, onerror, onclose
  - [ ] Implement auto-connect on service initialization
  - [ ] Add TypeScript interfaces for all WebSocket message types (ConnectedMessage, PatternDetectedMessage, SignalMessage, etc.)
  - [ ] Use auto-generated TypeScript types from backend Pydantic models where applicable

- [ ] Frontend WebSocket Service - Reconnection Logic (AC: 3)
  - [ ] Implement exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s between retries
  - [ ] Add reconnection attempt counter (max 10 attempts before giving up)
  - [ ] Implement automatic reconnection on disconnect (unless explicitly disconnected by user)
  - [ ] Add message buffering during reconnection (store messages in queue)
  - [ ] Implement REST fallback: fetch missed updates via GET /api/v1/signals?since={lastTimestamp}
  - [ ] Sort buffered WebSocket messages by sequence_number before applying
  - [ ] Merge REST and buffered WebSocket updates to prevent duplicates
  - [ ] Reset backoff timer on successful reconnection
  - [ ] Emit reconnection events for UI feedback ("Reconnecting...", "Connected")
  - [ ] Write unit test for exponential backoff calculation
  - [ ] Write unit test for message buffering and replay logic

- [ ] Frontend WebSocket Service - Event Subscription (AC: 2, 8)
  - [ ] Implement subscribe() method: register callback for specific event types
  - [ ] Implement unsubscribe() method: remove callback registration
  - [ ] Support multiple subscribers per event type (array of callbacks)
  - [ ] Add event type constants: SIGNAL_NEW, SIGNAL_EXECUTED, SIGNAL_REJECTED, PORTFOLIO_UPDATED, CAMPAIGN_UPDATED, PATTERN_DETECTED
  - [ ] Parse incoming WebSocket messages and route to appropriate event handlers
  - [ ] Validate message format (type, sequence_number, timestamp required)
  - [ ] Log invalid messages for debugging (don't crash on bad messages)
  - [ ] Implement message deduplication using sequence_number (ignore duplicates)
  - [ ] Add error handling for subscriber callback failures (don't crash WebSocket)

- [ ] Pinia Store Integration (AC: 8)
  - [ ] Update `useWebSocketStore` to hold connection status and metadata
  - [ ] Store fields: connectionStatus, connectionId, lastSequenceNumber, lastMessageTime, reconnectAttempts
  - [ ] Create `useSignalStore` actions: addSignal(), updateSignal(), removeSignal()
  - [ ] Create `usePortfolioStore` actions: updatePortfolioHeat(), updateCampaigns()
  - [ ] Create `usePatternStore` actions: addPattern(), updatePattern()
  - [ ] Wire WebSocket event subscriptions to Pinia store actions in main.ts or App.vue
  - [ ] Subscribe to SIGNAL_NEW → useSignalStore.addSignal()
  - [ ] Subscribe to SIGNAL_EXECUTED → useSignalStore.updateSignal()
  - [ ] Subscribe to SIGNAL_REJECTED → useSignalStore.updateSignal()
  - [ ] Subscribe to PORTFOLIO_UPDATED → usePortfolioStore.updatePortfolioHeat()
  - [ ] Subscribe to CAMPAIGN_UPDATED → usePortfolioStore.updateCampaigns()
  - [ ] Subscribe to PATTERN_DETECTED → usePatternStore.addPattern()
  - [ ] Parse Decimal fields from WebSocket messages using big.js
  - [ ] Add optimistic update support (mark pending, confirm/rollback on response)

- [ ] Optimistic Updates (AC: 4)
  - [ ] Implement optimistic update pattern: immediately update UI, mark as "pending"
  - [ ] Add pending state field to Signal, Pattern models in stores
  - [ ] On WebSocket confirmation, mark as "confirmed" and update with server data
  - [ ] On WebSocket error, rollback optimistic update and show error message
  - [ ] Example: When trader clicks "Execute" button, immediately update UI, then confirm via WebSocket
  - [ ] Handle edge case: rollback if WebSocket confirmation doesn't arrive within 10 seconds
  - [ ] Write unit test for optimistic update flow (add → confirm)
  - [ ] Write unit test for optimistic update rollback (add → error)

- [ ] Toast Notifications (AC: 5)
  - [ ] Create `frontend/src/services/notificationService.ts` for toast management
  - [ ] Use PrimeVue Toast component for non-intrusive notifications
  - [ ] Configure toast position: top-right, auto-dismiss after 5 seconds
  - [ ] Show toast on SIGNAL_NEW event: "New signal: SPRING on AAPL"
  - [ ] Show toast on SIGNAL_EXECUTED event: "Signal executed: AAPL"
  - [ ] Show toast on PORTFOLIO_UPDATED event if heat >80%: "Portfolio heat at 82%"
  - [ ] Show toast on CAMPAIGN_UPDATED event if campaign >80%: "Campaign C-123 at 85%"
  - [ ] Add severity levels: info (new signal), success (executed), warn (heat warnings), error (rejected)
  - [ ] Add "View Details" button in toast that navigates to signal detail page
  - [ ] Implement toast throttling: max 3 toasts per 10 seconds to avoid spam
  - [ ] Add user preference to enable/disable toast notifications (stored in localStorage)
  - [ ] Write unit test for toast notification triggering logic

- [ ] Connection Status Indicator (AC: 6)
  - [ ] Create `frontend/src/components/ConnectionStatus.vue` component
  - [ ] Display status indicator in app header/navbar (always visible)
  - [ ] Status icon: green checkmark (connected), yellow spinner (connecting/reconnecting), red X (disconnected/error)
  - [ ] Status text: "Live", "Connecting...", "Reconnecting (attempt 3/10)", "Disconnected"
  - [ ] Add tooltip on hover with details: connection_id, last message time, sequence number
  - [ ] Show reconnection countdown if applicable: "Retrying in 8s..."
  - [ ] Add "Reconnect Now" button when disconnected (skips backoff timer)
  - [ ] Animate icon subtly when connecting/reconnecting (pulsing effect)
  - [ ] Use reactive connectionStatus from WebSocketService
  - [ ] Write unit test for status display logic (different connection states)

- [ ] Performance Optimization (AC: 10)
  - [ ] Implement message batching on backend: batch up to 10 events, send every 500ms
  - [ ] Add batch_update message type for high-volume scenarios
  - [ ] Use Vue's nextTick() to batch DOM updates from multiple WebSocket events
  - [ ] Debounce rapid store updates (max 1 update per 200ms per store)
  - [ ] Use computed properties in components instead of direct store access
  - [ ] Implement virtual scrolling in signal list if >100 signals to prevent lag
  - [ ] Profile WebSocket event handling: measure time from message receipt to UI update
  - [ ] Add performance monitoring: track events/second, average processing time
  - [ ] Log warning if processing time >100ms for single event
  - [ ] Test with simulated high-volume: 20 events/second for 60 seconds

- [ ] Unit Testing (AC: 9, backend)
  - [ ] Write pytest test for WebSocket connection establishment
  - [ ] Test: ConnectionManager tracks multiple concurrent connections
  - [ ] Test: sequence_number increments correctly per message
  - [ ] Test: event emission sends correct message format
  - [ ] Test: graceful disconnect removes connection from manager
  - [ ] Test: heartbeat/ping keeps connection alive
  - [ ] Mock WebSocket connection using pytest fixtures

- [ ] Unit Testing (AC: 9, frontend)
  - [ ] Write Vitest test for WebSocketService connection lifecycle
  - [ ] Test: connect() establishes WebSocket and stores connection_id
  - [ ] Test: disconnect() closes connection gracefully
  - [ ] Test: exponential backoff calculates correct intervals
  - [ ] Test: subscribe() registers callback for event type
  - [ ] Test: incoming message triggers subscribed callbacks
  - [ ] Test: message deduplication using sequence_number
  - [ ] Test: invalid messages logged but don't crash service
  - [ ] Mock WebSocket using Vitest mock functions

- [ ] Integration Testing (AC: 9, 10)
  - [ ] Write Vitest integration test for WebSocket → Pinia store flow
  - [ ] Test: SIGNAL_NEW event adds signal to useSignalStore
  - [ ] Test: PORTFOLIO_UPDATED event updates usePortfolioStore
  - [ ] Test: reconnection fetches missed updates via REST
  - [ ] Test: message buffering and replay on reconnection
  - [ ] Test: optimistic update confirmation flow
  - [ ] Test: toast notifications triggered by events
  - [ ] Test: connection status indicator reflects WebSocket state
  - [ ] Test: UI handles 10 events/second without lag
  - [ ] Mock WebSocket server and REST API responses

- [ ] End-to-End Testing (AC: 2, 3, 5)
  - [ ] Write Playwright E2E test for full WebSocket flow
  - [ ] Test: page loads, WebSocket connects, shows "Live" status
  - [ ] Test: backend emits signal event, toast notification appears, signal added to dashboard
  - [ ] Test: disconnect WebSocket, status shows "Reconnecting", reconnects successfully
  - [ ] Test: simulate network outage, verify REST fallback fetches missed updates
  - [ ] Test: verify no duplicate signals after reconnection
  - [ ] Test: toast auto-dismisses after 5 seconds
  - [ ] Use Playwright's WebSocket mocking capabilities

- [ ] Integration and Documentation
  - [ ] Wire up WebSocketService initialization in main.ts or App.vue
  - [ ] Connect service on app mount, disconnect on app unmount
  - [ ] Add ConnectionStatus component to main app layout (header/navbar)
  - [ ] Configure PrimeVue Toast in App.vue
  - [ ] Add environment variable for WebSocket URL (VITE_WS_URL)
  - [ ] Update API documentation with WebSocket endpoint and message types
  - [ ] Add developer guide: How to subscribe to WebSocket events in new components
  - [ ] Add troubleshooting guide: What to do if WebSocket won't connect

## Dev Notes

### Previous Story Insights
This story implements the real-time communication foundation for the entire Epic 10 dashboard. Previous stories (10.2, 10.3, 10.6) have created UI components that will consume WebSocket updates. This story provides the infrastructure layer that powers live updates across all dashboard components.

**Critical Integration Points:**
- Story 10.2 (System Status Widget): consumes WebSocket status for "live" indicator
- Story 10.3 (Daily Summary Card): doesn't use WebSocket (loads once per day)
- Story 10.4 (Live Signals Dashboard): primary consumer of SIGNAL_* events
- Story 10.5 (Enhanced Signal Cards): consumes signal updates for real-time status changes
- Story 10.6 (Enhanced Risk Dashboard): consumes PORTFOLIO_UPDATED and CAMPAIGN_UPDATED events
- Story 10.7 (Educational Rejection Detail View): consumes SIGNAL_REJECTED events
- Story 10.8 (Trade Audit Log Table): may use WebSocket for live updates (optional)

**Architecture Note:** The PRD Story 10.9 mentions "Socket.IO" but the Architecture specification clearly states to use **native FastAPI WebSocket support** (built-in, no external library). Socket.IO is NOT part of the tech stack.

[Source: docs/prd/epic-10-web-dashboard-monitoring-ui.md - Story 10.9]
[Source: docs/architecture/3-tech-stack.md - Real-Time Communication: WebSocket (FastAPI) Built-in]

### Data Models

**WebSocket Message Base Structure:**
All WebSocket messages share a common structure:
```typescript
interface WebSocketMessage {
  type: string;  // Event type identifier
  sequence_number: number;  // Monotonic counter per connection
  timestamp: string;  // ISO 8601 UTC
  data?: any;  // Message-specific payload
}
```

**Connection Established Message:**
```typescript
interface ConnectedMessage extends WebSocketMessage {
  type: "connected";
  connection_id: string;  // UUID
  sequence_number: 0;  // Always starts at 0
}
```

**Pattern Detected Message:**
```typescript
interface PatternDetectedMessage extends WebSocketMessage {
  type: "pattern_detected";
  data: {
    id: string;
    symbol: string;
    pattern_type: "SPRING" | "UTAD" | "SOS" | "LPS" | "SC" | "AR" | "ST";
    confidence_score: number;  // 70-95
    phase: string;
    test_confirmed: boolean;
  };
  full_details_url: string;  // e.g., "/api/v1/patterns/{id}"
}
```

**Signal Generated Message:**
```typescript
interface SignalMessage extends WebSocketMessage {
  type: "signal:new" | "signal:executed" | "signal:rejected";
  data: Signal;  // Full Signal object (auto-generated type)
}
```

**Portfolio Updated Message:**
```typescript
interface PortfolioUpdatedMessage extends WebSocketMessage {
  type: "portfolio:updated";
  data: {
    total_heat: string;  // Decimal as string
    available_capacity: string;
    timestamp: string;
  };
}
```

**Campaign Updated Message:**
```typescript
interface CampaignUpdatedMessage extends WebSocketMessage {
  type: "campaign:updated";
  data: {
    campaign_id: string;
    risk_allocated: string;  // Decimal as string
    positions_count: number;
  };
}
```

**Batch Update Message (High-Volume Scenarios):**
```typescript
interface BatchUpdateMessage extends WebSocketMessage {
  type: "batch_update";
  batch_size: number;
  patterns_detected: PatternDetectedMessage['data'][];
  signals_generated: SignalMessage['data'][];
}
```

[Source: docs/architecture/5-api-specification.md#5.3 - WebSocket API]

### API Specifications

**WebSocket Endpoint:** `ws://localhost:8000/ws`

**Technology:** Native FastAPI WebSocket support (NOT Socket.IO)
- Use `from fastapi import WebSocket` for backend
- Use native browser `WebSocket` API for frontend (NOT socket.io-client)

**Connection Flow:**
1. Client: `const ws = new WebSocket('ws://localhost:8000/ws')`
2. Server: Accept connection, assign connection_id and sequence_number=0
3. Server: Send `connected` message with connection_id
4. Client: Store connection_id and last_sequence_number
5. Server: Emit events as they occur (pattern detected, signal generated, etc.)
6. Client: Process messages, update Pinia stores, show toasts
7. On disconnect: Client implements exponential backoff reconnection

**Event Types (Server → Client):**
- `connected` - Connection established
- `pattern_detected` - Pattern detection event
- `signal:new` - New signal generated
- `signal:executed` - Signal executed
- `signal:rejected` - Signal rejected
- `portfolio:updated` - Portfolio heat changed
- `campaign:updated` - Campaign risk changed
- `batch_update` - Multiple events batched together

[Source: docs/architecture/5-api-specification.md#5.3]

**Reconnection Strategy:**
Frontend must implement robust reconnection with message deduplication:
1. Detect disconnect (onclose event)
2. Start exponential backoff reconnection
3. Buffer new messages during reconnection
4. Fetch missed updates via REST: `GET /api/v1/signals?since={lastTimestamp}`
5. Apply REST updates to Pinia stores
6. Sort buffered WebSocket messages by sequence_number
7. Apply buffered messages (skip duplicates using sequence_number)
8. Resume normal operation

[Source: docs/architecture/5-api-specification.md#5.3 - Reconnection Strategy]

### Component Specifications

**WebSocket Service Location:** `frontend/src/services/websocketService.ts`

**Technology Stack:**
- Native browser WebSocket API (NOT socket.io-client)
- Vue 3.4+ Composition API (reactive refs for status)
- TypeScript 5.3+
- big.js for Decimal parsing
[Source: docs/architecture/3-tech-stack.md]

**Service Pattern: Singleton with Event Subscription**
```typescript
class WebSocketService {
  private ws: WebSocket | null = null;
  private subscribers: Map<string, Array<(data: any) => void>>;
  private connectionStatus: Ref<ConnectionStatus>;
  private lastSequenceNumber: number = 0;

  connect(): void { /* ... */ }
  disconnect(): void { /* ... */ }
  subscribe(eventType: string, callback: (data: any) => void): void { /* ... */ }
  unsubscribe(eventType: string, callback: (data: any) => void): void { /* ... */ }
  private reconnect(): void { /* exponential backoff logic */ }
  private fetchMissedUpdates(): Promise<void> { /* REST fallback */ }
}

export const websocketService = new WebSocketService();  // Singleton export
```

**Pinia Store Integration:**
The WebSocket service integrates with existing Pinia stores:
- `useWebSocketStore` - Connection status metadata
- `useSignalStore` - Signal CRUD operations
- `usePortfolioStore` - Portfolio and campaign data
- `usePatternStore` - Pattern detection events

[Source: docs/architecture/6-components.md#6.2.5 - Pinia Stores]
[Source: docs/architecture/10-unified-project-structure.md - frontend/src/stores/]

### File Locations

**Backend Files:**
- WebSocket Endpoint: `backend/src/api/websocket.py` (new file)
- Connection Manager: `backend/src/api/websocket.py` (ConnectionManager class)
- Integration: Update `backend/src/pattern_engine/engine.py` to emit events
- Integration: Update `backend/src/signal_generator/generator.py` to emit events
- Integration: Update `backend/src/risk_management/service.py` to emit events

**Frontend Files:**
- WebSocket Service: `frontend/src/services/websocketService.ts` (new file)
- Notification Service: `frontend/src/services/notificationService.ts` (new file)
- Connection Status Component: `frontend/src/components/ConnectionStatus.vue` (new file)
- Pinia Stores: Extend existing stores in `frontend/src/stores/`
  - `frontend/src/stores/websocketStore.ts` (new file)
  - `frontend/src/stores/signalStore.ts` (extend)
  - `frontend/src/stores/portfolioStore.ts` (extend)
  - `frontend/src/stores/patternStore.ts` (extend)

**Test Files:**
- Backend: `backend/tests/unit/test_websocket.py`
- Backend Integration: `backend/tests/integration/test_websocket_events.py`
- Frontend Unit: `frontend/tests/services/websocketService.test.ts`
- Frontend Unit: `frontend/tests/services/notificationService.test.ts`
- Frontend Integration: `frontend/tests/integration/WebSocket.integration.test.ts`
- E2E: `frontend/tests/e2e/websocket.spec.ts` (Playwright)

[Source: docs/architecture/10-unified-project-structure.md]

### WebSocket Implementation Details

**Backend: ConnectionManager Pattern**
```python
# backend/src/api/websocket.py
from fastapi import WebSocket, WebSocketDisconnect
from typing import Dict, List
import asyncio
from uuid import uuid4

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, tuple[WebSocket, int]] = {}  # {connection_id: (ws, seq_num)}

    async def connect(self, websocket: WebSocket) -> str:
        await websocket.accept()
        connection_id = str(uuid4())
        self.active_connections[connection_id] = (websocket, 0)
        await self.send_message(connection_id, {
            "type": "connected",
            "connection_id": connection_id,
            "sequence_number": 0,
            "timestamp": datetime.now(timezone.utc).isoformat()
        })
        return connection_id

    async def disconnect(self, connection_id: str):
        if connection_id in self.active_connections:
            del self.active_connections[connection_id]

    async def send_message(self, connection_id: str, message: dict):
        if connection_id in self.active_connections:
            ws, seq = self.active_connections[connection_id]
            seq += 1
            message["sequence_number"] = seq
            self.active_connections[connection_id] = (ws, seq)
            await ws.send_json(message)

    async def broadcast(self, message: dict):
        # Send to all connected clients
        for connection_id in list(self.active_connections.keys()):
            await self.send_message(connection_id, message)

manager = ConnectionManager()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    connection_id = await manager.connect(websocket)
    try:
        while True:
            # Keep connection alive, listen for client messages if needed
            await websocket.receive_text()
    except WebSocketDisconnect:
        await manager.disconnect(connection_id)
```

**Frontend: Reconnection with Exponential Backoff**
```typescript
// frontend/src/services/websocketService.ts
class WebSocketService {
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 10;
  private reconnectTimer: number | null = null;

  private calculateBackoff(): number {
    // Exponential backoff: 1s, 2s, 4s, 8s, 16s, max 30s
    const baseDelay = 1000;  // 1 second
    const maxDelay = 30000;  // 30 seconds
    const delay = Math.min(baseDelay * Math.pow(2, this.reconnectAttempts), maxDelay);
    return delay;
  }

  private reconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.connectionStatus.value = 'error';
      console.error('Max reconnection attempts reached');
      return;
    }

    this.connectionStatus.value = 'reconnecting';
    this.reconnectAttempts++;

    const delay = this.calculateBackoff();
    this.reconnectTimer = window.setTimeout(() => {
      this.connect();
    }, delay);
  }
}
```

[Source: docs/architecture/5-api-specification.md#5.3 - Reconnection Strategy]

### Testing Requirements

**Testing Framework:**
- Backend: pytest 8.0+ with async WebSocket support
- Frontend Unit: Vitest 1.2+ with WebSocket mocking
- E2E: Playwright 1.41+ with WebSocket testing support
[Source: docs/architecture/3-tech-stack.md]

**Backend Testing Approach:**
```python
# Use pytest-asyncio for WebSocket testing
@pytest.mark.asyncio
async def test_websocket_connection():
    async with httpx.AsyncClient() as client:
        async with client.websocket_connect('ws://localhost:8000/ws') as ws:
            msg = await ws.receive_json()
            assert msg["type"] == "connected"
            assert "connection_id" in msg
            assert msg["sequence_number"] == 0
```

**Frontend Testing Approach:**
```typescript
// Mock WebSocket in Vitest
import { vi } from 'vitest';

class MockWebSocket {
  onopen: ((event: Event) => void) | null = null;
  onmessage: ((event: MessageEvent) => void) | null = null;
  onerror: ((event: Event) => void) | null = null;
  onclose: ((event: CloseEvent) => void) | null = null;

  send(data: string) { /* mock */ }
  close() { /* mock */ }
}

global.WebSocket = MockWebSocket as any;

test('WebSocketService connects and stores connection_id', async () => {
  const service = new WebSocketService();
  service.connect();

  // Simulate connected message
  const mockMsg = { type: 'connected', connection_id: 'uuid-123', sequence_number: 0 };
  service['ws']!.onmessage!(new MessageEvent('message', { data: JSON.stringify(mockMsg) }));

  expect(service['connectionId']).toBe('uuid-123');
});
```

**Performance Testing:**
- Simulate 20 events/second for 60 seconds
- Measure time from message receipt to UI update (<100ms target)
- Monitor memory usage (no leaks after 1000 messages)
- Test with 100 concurrent signals in store (virtual scrolling)

[Source: docs/architecture/12-testing-strategy.md]

### Technical Constraints

**WebSocket Message Size:**
- Keep messages <10KB for performance
- Use `full_details_url` pattern for large payloads (pattern_detected sends minimal data, link to full details)
- Batch updates when >10 events/500ms

**Decimal Precision:**
- Backend: Use Python `Decimal` for risk percentages, serialize as string
- Frontend: Parse decimal strings with big.js (never parseFloat)
[Source: docs/architecture/15-coding-standards.md#15.1]

**Timezone Handling:**
- All WebSocket message timestamps must be UTC
- Use ISO 8601 format: "2024-03-15T14:30:00Z"
[Source: docs/architecture/4-data-models.md#4.1]

**Connection Limits:**
- MVP: Support 10 concurrent WebSocket connections (single trader + multiple tabs/devices)
- FastAPI handles this natively with asyncio
- No additional infrastructure needed (Celery/Redis) for MVP

**Browser Compatibility:**
- Native WebSocket API supported in all modern browsers (Chrome, Firefox, Safari, Edge)
- No polyfill needed for MVP

### Coding Standards

**Naming Conventions:**
- Backend: snake_case functions (emit_signal_generated)
- Frontend: camelCase service methods (websocketService.subscribe)
- Event types: lowercase with colons (signal:new, portfolio:updated)
- TypeScript interfaces: PascalCase (SignalMessage, WebSocketService)
[Source: docs/architecture/15-coding-standards.md#15.2]

**Error Handling:**
- Never crash on invalid WebSocket message (log and skip)
- Never crash on subscriber callback error (log and continue to next subscriber)
- Show user-friendly error messages ("Connection lost, reconnecting...")
- Log all WebSocket errors with structured logging (correlation_id, event_type)

**Service Organization:**
Consider creating composables for WebSocket integration:
- `useWebSocket()` - Core connection management
- `useWebSocketSubscription(eventType, callback)` - Easy subscription in components
- `useWebSocketStatus()` - Reactive connection status

Example usage in component:
```vue
<script setup lang="ts">
import { useWebSocketSubscription } from '@/composables/useWebSocket';

useWebSocketSubscription('signal:new', (signal) => {
  console.log('New signal:', signal);
  // Component-specific logic
});
</script>
```

[Source: docs/architecture/15-coding-standards.md - Vue Composables: camelCase with 'use']

### Project Structure Notes

**Integration Point: App Initialization**
WebSocket connection should be initialized at the app level:

```typescript
// frontend/src/main.ts or App.vue
import { websocketService } from '@/services/websocketService';

// Initialize WebSocket on app mount
onMounted(() => {
  websocketService.connect();

  // Wire up store subscriptions
  websocketService.subscribe('signal:new', (data) => {
    const signalStore = useSignalStore();
    signalStore.addSignal(data);
  });

  // ... other subscriptions
});

onUnmounted(() => {
  websocketService.disconnect();
});
```

**Alternative: Use Pinia Plugin**
Consider creating a Pinia plugin to automatically wire WebSocket events to stores:
```typescript
// frontend/src/plugins/websocketPlugin.ts
export const websocketPlugin = ({ store }) => {
  if (store.$id === 'signal') {
    websocketService.subscribe('signal:new', store.addSignal);
    websocketService.subscribe('signal:executed', store.updateSignal);
  }
  // ... other stores
};

pinia.use(websocketPlugin);
```

### Security Considerations

**MVP Authentication:**
No authentication required for MVP (local-only deployment).
[Source: docs/architecture/5-api-specification.md#5.1]

**Phase 2 Authentication:**
When adding authentication, WebSocket connections must:
- Accept JWT token in connection URL query param: `ws://localhost:8000/ws?token={jwt}`
- Or accept token in first message after connection
- Validate token before accepting connection
- Associate connection_id with authenticated user_id

**Data Validation:**
- Validate all WebSocket message formats (type, sequence_number, timestamp required)
- Reject malformed messages (don't crash, log for debugging)
- Sanitize any user-generated content in messages (though MVP has no user → server WebSocket messages)

### Performance Considerations

**Backend Performance:**
- Use FastAPI's native async WebSocket support (highly efficient)
- ConnectionManager stores connections in memory (no database queries)
- Emit events asynchronously (don't block pattern detection pipeline)
- Consider message batching for high-volume scenarios (>10 events/second)

**Frontend Performance:**
- Debounce rapid store updates (max 1 update per 200ms per store)
- Use Vue's `nextTick()` to batch DOM updates
- Implement virtual scrolling for large signal lists (>100 signals)
- Monitor memory usage (unsubscribe from events when components unmount)
- Profile WebSocket event handling (should be <10ms per event)

**Network Efficiency:**
- Keep WebSocket messages small (<10KB)
- Use `full_details_url` pattern instead of sending large objects
- Batch updates during high-volume periods
- Implement heartbeat/ping every 30 seconds (keeps NAT/firewalls happy)

**Scalability Path (Beyond MVP):**
- At 50+ symbols: Consider Redis Pub/Sub for multi-server WebSocket distribution
- At 100+ concurrent users: Use dedicated WebSocket server (separate from API server)
- At 1000+ events/minute: Implement server-side event throttling/sampling

### Observability

**Logging Requirements:**
```python
# Backend structured logging
logger.info(
    "websocket_message_sent",
    connection_id=connection_id,
    message_type=message["type"],
    sequence_number=seq,
    event_source="pattern_engine",  # or signal_generator, risk_manager
    correlation_id=correlation_id
)
```

**Metrics to Track:**
- Active WebSocket connections count
- Messages sent per second (total and per event type)
- Average message processing time (backend emit → frontend store update)
- Reconnection attempts and success rate
- Message buffer size during reconnections
- Toast notification rate (ensure not spamming user)

**Debugging Tools:**
- Add `__DEV__` mode logging in frontend (log all WebSocket messages)
- Add admin endpoint to list active connections: `GET /api/admin/websocket/connections`
- Add health check for WebSocket: include in `GET /health` endpoint
- Consider WebSocket debug panel in UI (show connection status, last N messages)

[Source: docs/architecture/17-monitoring-and-observability.md - WebSocket uptime metric]

## Testing

### Test File Locations
- Backend Unit: `backend/tests/unit/test_websocket.py`
- Backend Integration: `backend/tests/integration/test_websocket_events.py`
- Frontend Unit: `frontend/tests/services/websocketService.test.ts`
- Frontend Unit: `frontend/tests/services/notificationService.test.ts`
- Frontend Integration: `frontend/tests/integration/WebSocket.integration.test.ts`
- E2E: `frontend/tests/e2e/websocket.spec.ts`

### Testing Frameworks
- Backend: pytest 8.0+ with pytest-asyncio for WebSocket testing
- Frontend: Vitest 1.2+ with WebSocket mocking
- E2E: Playwright 1.41+ with native WebSocket support
[Source: docs/architecture/3-tech-stack.md]

### Test Requirements

1. **Backend Unit Tests:**
   - Test ConnectionManager connects/disconnects clients
   - Test sequence_number increments correctly per connection
   - Test message format includes all required fields (type, sequence_number, timestamp)
   - Test event emission methods (emit_signal_generated, etc.)
   - Test heartbeat/ping mechanism
   - Test graceful disconnect cleanup
   - Mock WebSocket connections using pytest fixtures

2. **Backend Integration Tests:**
   - Test Pattern Detection Engine emits pattern_detected events
   - Test Signal Generator emits signal:new, signal:executed, signal:rejected events
   - Test Risk Management Service emits portfolio:updated events
   - Test WebSocket clients receive events in real-time
   - Test multiple concurrent connections receive same broadcast
   - Test connection cleanup on client disconnect

3. **Frontend Unit Tests:**
   - Test WebSocketService.connect() establishes connection
   - Test WebSocketService stores connection_id from server
   - Test exponential backoff calculation (1s, 2s, 4s, 8s, 16s, 30s)
   - Test subscribe() registers callback for event type
   - Test incoming message triggers subscribed callbacks
   - Test message deduplication using sequence_number
   - Test invalid message handling (logs, doesn't crash)
   - Test reconnection logic (attempts, max retries)
   - Mock WebSocket using Vitest mock

4. **Frontend Integration Tests:**
   - Test WebSocket event triggers Pinia store update
   - Test signal:new adds signal to useSignalStore
   - Test portfolio:updated updates usePortfolioStore
   - Test message buffering during reconnection
   - Test REST fallback fetches missed updates
   - Test buffered messages applied in sequence_number order
   - Test optimistic update confirmation/rollback
   - Test toast notification triggered by events
   - Test connection status indicator reflects WebSocket state
   - Mock WebSocket and REST API

5. **Performance Tests:**
   - Test handling 10 events/second without UI lag
   - Test handling 20 events/second for 60 seconds (stress test)
   - Test memory usage after 1000 messages (no leaks)
   - Test UI update time: message receipt → DOM update (<100ms)
   - Test with 100 concurrent signals in store

6. **E2E Tests (Playwright):**
   - Test full flow: page load → WebSocket connect → event received → UI updated
   - Test: backend emits signal:new → toast appears → signal in dashboard
   - Test: disconnect → status shows "Reconnecting" → reconnects → status "Live"
   - Test: network outage → REST fallback → no duplicate signals
   - Test: toast auto-dismiss after 5 seconds
   - Test: connection status indicator in header
   - Use Playwright's WebSocket mocking/interception

[Source: docs/architecture/12-testing-strategy.md]
[Source: docs/architecture/3-tech-stack.md - E2E Testing: Playwright with WebSocket testing]

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-19 | 1.0 | Initial story creation | Bob (SM Agent) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (model ID: claude-sonnet-4-5-20250929) via Claude Code CLI

### Debug Log References

- Backend WebSocket tests: All 11 tests passing after fixing sequence number protocol in connect() method
- MyPy strict type checking: Passed with 0 errors
- Fixed issue: Connected message was incorrectly incrementing sequence number when using send_message(). Changed to send directly with sequence_number=0.

### Completion Notes List

**Backend Implementation (Complete):**

- ✅ Created WebSocket endpoint with native FastAPI WebSocket support (NOT Socket.IO)
- ✅ Implemented ConnectionManager with UUID tracking and sequence number protocol
- ✅ All 7 event emission methods: connected, pattern_detected, signal:new, signal:executed, signal:rejected, portfolio:updated, campaign:updated
- ✅ Batch update support for high-volume scenarios (>10 events in 500ms)
- ✅ Graceful disconnect handling with connection cleanup
- ✅ Comprehensive unit tests (11 tests, all passing)
- ✅ MyPy strict type checking passed

**Frontend Implementation (Complete):**

- ✅ Created comprehensive WebSocketService with singleton pattern
- ✅ Implemented exponential backoff reconnection (1s, 2s, 4s, 8s, 16s, max 30s)
- ✅ Message buffering during reconnection
- ✅ REST API fallback for missed messages
- ✅ Deduplication via sequence number tracking
- ✅ Updated useWebSocket composable to wrap new service
- ✅ Created comprehensive TypeScript type definitions for all WebSocket messages
- ✅ Updated Pinia stores (websocketStore, signalStore, portfolioStore, patternStore)
- ✅ Created notificationService with PrimeVue Toast integration
- ✅ Implemented throttling (max 3 toasts per 10 seconds)
- ✅ Created ConnectionStatus component for navbar
- ✅ Wired up WebSocket in App.vue with auto-connect on mount

**Sequence Number Protocol:**

- Connected message: sequence_number = 0 (sent directly in connect())
- Subsequent messages: sequence_number increments starting at 1 (via send_message())
- Each connection tracks sequence independently

**Not Yet Implemented (Future Tasks):**

- ⏳ Integration with Pattern Engine, Signal Generator, Risk Management (backend event emission)
- ⏳ Optimistic updates pattern in frontend stores
- ⏳ Frontend unit tests for WebSocketService
- ⏳ Integration tests for WebSocket → Pinia store flow
- ⏳ E2E tests with Playwright
- ⏳ Performance testing (10 events/second handling)

### File List

**Backend Files Created:**

- `backend/src/api/websocket.py` - WebSocket endpoint and ConnectionManager implementation
- `backend/tests/unit/test_websocket.py` - Unit tests for WebSocket (11 tests)

**Backend Files Modified:**

- `backend/src/api/main.py` - Added WebSocket route at `/ws`

**Frontend Files Created:**

- `frontend/src/types/websocket.ts` - TypeScript interfaces for all WebSocket messages
- `frontend/src/services/notificationService.ts` - Toast notification service with throttling
- `frontend/src/stores/websocketStore.ts` - Pinia store for WebSocket connection metadata
- `frontend/src/components/ConnectionStatus.vue` - Connection status indicator component

**Frontend Files Modified:**

- `frontend/src/services/websocketService.ts` - Comprehensive WebSocket client with reconnection logic
- `frontend/src/composables/useWebSocket.ts` - Vue composable wrapping websocketService
- `frontend/src/stores/signalStore.ts` - Added signal:new, signal:executed, signal:rejected handlers
- `frontend/src/stores/portfolioStore.ts` - Added portfolio:updated, campaign:updated handlers
- `frontend/src/stores/patternStore.ts` - Added pattern_detected handler
- `frontend/src/App.vue` - Added Toast component, ConnectionStatus, WebSocket initialization

**Documentation Files Modified:**

- `docs/stories/epic-10/10.9.websocket-real-time-updates.md` - Updated status to "Ready for Review"

## QA Results
_To be populated by QA agent_
