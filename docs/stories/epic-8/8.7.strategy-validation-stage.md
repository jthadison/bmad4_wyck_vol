# Story 8.7: Strategy Validation Stage (William - Wyckoff Mentor)

## Status
Done

## Story
**As a** strategy validator,
**I want** to perform final sanity checks that signal aligns with Wyckoff principles,
**so that** signals that technically pass but violate trading wisdom are caught.

## Acceptance Criteria
1. Validation function: `validate_strategy(signal, market_context) -> ValidationResult`
2. Sanity checks:
   - Market regime appropriate (avoid springs in extreme volatility)
   - No news events pending (FR29 earnings check for stocks, high-impact events for forex)
   - Signal not contradicting recent invalidation (don't re-enter failed campaign)
   - Time-based: avoid end-of-day entries (stocks), Friday PM entries (forex weekend gap risk)
3. Warnings for edge cases: "Spring in sideways market - lower probability"
4. Strategic overrides possible: high-conviction signals can override warnings
5. Unit test: earnings announcement in 12 hours causes FAIL (stocks), NFP in 4 hours causes FAIL (forex)
6. Integration test: validate known good and bad strategic contexts for both stocks and forex
7. Logging: William's validation reasoning logged for review
8. FR29 compliance: news/earnings calendar integration (asset-class-aware)
9. Human review mode: flag signals for manual review if borderline
10. Feedback loop: validation reasons used for pattern learning
11. **NEW - Forex Support:** Asset class awareness throughout validation logic
12. **NEW - Forex Support:** Session-based validation (Asian/London/NY session characteristics)
13. **NEW - Forex Support:** Weekend gap risk validation (Friday entries after 12pm EST)
14. **NEW - Forex Support:** ForexNewsCalendarService for high-impact events (NFP, FOMC, ECB)

## Tasks / Subtasks

- [ ] Create MarketContext and NewsEvent data models (AC: 1, 8, 11, 14)
  - [ ] Create file: `backend/src/models/market_context.py`
  - [ ] Define `AssetClass` enum with values:
    - `STOCK` - Equity securities
    - `FOREX` - Currency pairs
    - `CRYPTO` - Cryptocurrencies (future)
  - [ ] Define `MarketRegime` enum with values:
    - `TRENDING_UP` - Strong uptrend (ADX > 25, price > 20 SMA)
    - `TRENDING_DOWN` - Strong downtrend (ADX > 25, price < 20 SMA)
    - `SIDEWAYS` - Ranging/choppy market (ADX < 25)
    - `HIGH_VOLATILITY` - Extreme volatility (ATR > 95th percentile for stocks, 90th for forex)
  - [ ] Define `ForexSession` enum with values:
    - `ASIAN` - 7pm-4am EST (low liquidity)
    - `LONDON` - 3am-12pm EST (high liquidity)
    - `NY` - 8am-5pm EST (highest liquidity)
    - `OVERLAP` - 8am-12pm EST (London+NY, peak activity)
  - [ ] Define `InvalidationEvent` Pydantic model:
    - `campaign_id: str` - Campaign that was invalidated
    - `symbol: str` - Trading symbol
    - `pattern_type: str` - Pattern that failed (SPRING, SOS, LPS, UTAD)
    - `invalidation_date: datetime` - When stop-out occurred
    - `invalidation_reason: str` - Why pattern failed (e.g., "Spring low broken")
    - `trading_range_id: UUID` - Which trading range failed
    - `days_ago: float` - Calculated from invalidation_date to now
  - [ ] Define `NewsEvent` Pydantic model (base class for earnings and forex news):
    - `symbol: str` - Trading symbol or currency pair
    - `event_date: datetime` - Scheduled event time (UTC)
    - `event_type: str` - "EARNINGS" | "NFP" | "FOMC" | "ECB" | "BOJ" | "GDP" | "CPI" | etc.
    - `impact_level: Literal["LOW", "MEDIUM", "HIGH"]` - Expected market impact
    - `hours_until_event: float` - Calculated: (event_date - now).total_seconds() / 3600
    - `within_blackout_window: bool` - True if within blackout period (asset-class-specific)
    - `description: str` - Human-readable event description
  - [ ] Define `EarningsEvent` Pydantic model (extends NewsEvent for stocks):
    - Inherits all NewsEvent fields
    - `fiscal_quarter: str` - e.g., "Q1 2024", "Q3 2023"
    - `estimated_eps: Decimal | None` - Estimated earnings per share (if available)
    - Blackout window: 24 hours before OR 2 hours after announcement
  - [ ] Define `ForexNewsEvent` Pydantic model (extends NewsEvent for forex):
    - Inherits all NewsEvent fields
    - `affected_currencies: List[str]` - e.g., ["USD", "EUR"] for FOMC
    - `previous_value: str | None` - Previous release value (for economic data)
    - `forecast_value: str | None` - Forecast consensus
    - Blackout window: 4 hours before, 1 hour after (high-impact events)
  - [ ] Define `MarketContext` Pydantic model:
    - `asset_class: AssetClass` - STOCK or FOREX (NEW - AC: 11)
    - `symbol: str` - Trading symbol or currency pair
    - `current_volatility: Decimal` - ATR as percentage of price
    - `volatility_percentile: int` - Where is ATR vs 20-day range (0-100)
    - `volume_percentile: int` - Where is current volume vs 20-day range (0-100) (NEW - Victoria enhancement)
    - `market_regime: MarketRegime` - Current market regime classification
    - `adx: Decimal | None` - Average Directional Index (trend strength)
    - `recent_invalidations: List[InvalidationEvent]` - Recent stop-outs for this symbol
    - `time_of_day: time` - Current market time (HH:MM in market timezone)
    - `market_session: str` - "PRE_MARKET" | "REGULAR" | "AFTER_HOURS" (stocks only)
    - `forex_session: ForexSession | None` - ASIAN/LONDON/NY/OVERLAP (forex only, NEW - AC: 12)
    - `news_event: NewsEvent | None` - Upcoming high-impact event (FR29, asset-class-aware)
    - `data_timestamp: datetime` - When this market context was calculated
  - [ ] Add JSON encoders for datetime, Decimal, time types
  - [ ] Add computed property `is_extreme_volatility: bool` (ENHANCED - Victoria):

    ```python
    @property
    def is_extreme_volatility(self) -> bool:
        """
        Wyckoff: Chaos (wide spreads + erratic volume) vs Controlled Accumulation

        Genuine accumulation: Calm markets, steady volume
        Panic/Euphoria: Wide spreads + volume spikes = noise, not opportunity

        Note: High ATR with LOW volume may indicate stopping volume (valid Wyckoff).
        High ATR with HIGH volume indicates chaos/panic (reject).
        """
        if self.asset_class == AssetClass.FOREX:
            atr_threshold = 90  # Forex: more frequent spikes
        else:
            atr_threshold = 95  # Stocks: 95th percentile

        # Check BOTH price volatility (ATR) AND volume volatility
        # Wide spreads alone may be stopping volume (valid Wyckoff)
        # Wide spreads + volume spikes = chaos (reject)
        return (
            self.volatility_percentile >= atr_threshold and
            self.volume_percentile >= 85  # Volume also erratic (Victoria enhancement)
        )
    ```

  - [ ] Add computed property `has_upcoming_news: bool` → news_event is not None and within_blackout_window
  - [ ] Add computed property `is_friday_pm_forex: bool` → asset_class == FOREX and weekday == 4 and hour >= 12
  - [ ] Add computed property `is_wednesday_pm_forex: bool` → asset_class == FOREX and weekday == 2 and hour >= 17 (NEW - Rachel: rollover warning)

- [ ] Implement EarningsCalendar service (AC: 8, FR29)
  - [ ] Create file: `backend/src/services/earnings_calendar.py`
  - [ ] Create `EarningsCalendarService` class
  - [ ] Constructor parameters:
    - `api_key: str` - Polygon.io API key from config
    - `cache_ttl_seconds: int` - Cache TTL (default 86400 = 24 hours)
    - `enabled: bool` - Feature flag (default True from config)
  - [ ] Implement earnings cache (in-memory dict or Redis):
    - Key: symbol
    - Value: tuple[EarningsEvent | None, datetime] (data, cached_at)
    - TTL: 24 hours (earnings data doesn't change intraday)
  - [ ] Method: `async def get_upcoming_earnings(symbol: str) -> EarningsEvent | None`
    - Check cache first, return if fresh (< TTL)
    - If cache miss or stale, call Polygon.io API
    - API endpoint: `GET https://api.polygon.io/v2/reference/dividends/{ticker}` (check docs for earnings endpoint)
    - Parse response, find next earnings date
    - Calculate hours_until_event: (earnings_date - datetime.now(UTC)).total_seconds() / 3600
    - Calculate within_blackout_window: 24 hours before OR 2 hours after earnings
    - Create EarningsEvent object
    - Cache result with current timestamp
    - Return EarningsEvent or None if no upcoming earnings
  - [ ] Method: `async def check_blackout_window(symbol: str) -> bool`
    - Shortcut method: returns True if symbol in earnings blackout window
    - Calls get_upcoming_earnings() internally
    - Returns earnings_data.within_blackout_window if exists, else False
  - [ ] Error handling:
    - If API call fails (network error, rate limit): log ERROR
    - Return None (don't block signal, but log warning)
    - Do NOT raise exception (graceful degradation)
  - [ ] Add method: `clear_cache(symbol: str | None = None)` for testing
  - [ ] Add structlog logging for all API calls, cache hits/misses, errors

- [ ] Implement ForexNewsCalendar service (AC: 14, FR29 for forex)
  - [ ] Create file: `backend/src/services/forex_news_calendar.py`
  - [ ] Create `ForexNewsCalendarService` class
  - [ ] Constructor parameters:
    - `api_key: str | None` - Optional API key for premium news services (e.g., ForexFactory, Investing.com)
    - `cache_ttl_seconds: int` - Cache TTL (default 3600 = 1 hour, shorter than stocks since forex 24hr)
    - `enabled: bool` - Feature flag (default True from config)
  - [ ] Define HIGH_IMPACT_EVENTS constant with event-specific blackout windows (ENHANCED - Rachel):
    - Event-specific blackout windows (not one-size-fits-all):
      - `NFP`: 6 hours before / 2 hours after (highest volatility event, multi-hundred pip moves)
      - `FOMC`: 4 hours before / 2 hours after (policy surprises cause sustained moves)
      - `ECB_RATE_DECISION`: 4 hours before / 1 hour after
      - `BOJ_RATE_DECISION`: 4 hours before / 1 hour after
      - `CPI`: 2 hours before / 1 hour after (important but lower volatility than NFP)
      - `GDP`: 2 hours before / 1 hour after
      - `UNEMPLOYMENT`: 2 hours before / 1 hour after
    - Each event maps to affected currencies: `{"NFP": ["USD"], "ECB_RATE_DECISION": ["EUR"], "BOJ_RATE_DECISION": ["JPY"], ...}`
    - Rationale (Rachel): NFP average move is 100-150 pips vs 50-70 pips for other events, spreads widen 5-10x
  - [ ] Implement news cache (in-memory dict or Redis):
    - Key: currency_pair (e.g., "EUR/USD")
    - Value: tuple[List[ForexNewsEvent], datetime] (events in next 24 hours, cached_at)
    - TTL: 1 hour (forex events can be announced with short notice)
  - [ ] Method: `async def get_upcoming_high_impact_events(currency_pair: str) -> List[ForexNewsEvent]`
    - Parse currency_pair: "EUR/USD" → ["EUR", "USD"]
    - Check cache first, return if fresh (< 1 hour)
    - If cache miss or stale, fetch events from calendar source
    - Options for data source:
      - **Free:** Scrape ForexFactory calendar (HTML parsing with BeautifulSoup)
      - **Paid:** Investing.com API, TradingEconomics API
      - **Fallback:** Hardcoded schedule for known recurring events (NFP = first Friday of month, FOMC = 8 meetings/year)
    - Filter events by:
      - Events affecting EUR or USD (from currency_pair)
      - Impact level = HIGH only
      - Event date within next 7 days
    - Calculate hours_until_event for each
    - Calculate within_blackout_window: 4 hours before OR 1 hour after event
    - Create ForexNewsEvent objects
    - Cache results
    - Return list of events
  - [ ] Method: `async def check_blackout_window(currency_pair: str) -> tuple[bool, ForexNewsEvent | None]`
    - Calls get_upcoming_high_impact_events() internally
    - Uses event-specific blackout windows from HIGH_IMPACT_EVENTS config (ENHANCED - Rachel)
    - Example: NFP in 4 hours → within 6-hour window → returns (True, nfp_event)
    - Example: CPI in 3 hours → outside 2-hour window → returns (False, None)
    - Returns (True, event) if any event is within its specific blackout window
    - Returns (False, None) if no events in blackout window
  - [ ] Error handling:
    - If API/scraping fails: log ERROR
    - Return empty list (don't block signal, but log warning)
    - Do NOT raise exception (graceful degradation)
  - [ ] Add method: `clear_cache(currency_pair: str | None = None)` for testing
  - [ ] Add structlog logging for all calendar fetches, cache hits/misses, errors
  - [ ] Add fallback logic:
    - If external calendar unavailable, use hardcoded recurring event schedule
    - NFP: First Friday of each month, 8:30am EST
    - FOMC: Pre-configured dates (8 meetings per year)
    - ECB: Pre-configured dates (8 meetings per year)

- [ ] Create NewsCalendarFactory to abstract stock vs forex calendars (AC: 11, 14)
  - [ ] Create file: `backend/src/services/news_calendar_factory.py`
  - [ ] Define `NewsCalendarService` abstract base class (ABC):
    - Abstract method: `async def get_upcoming_events(symbol: str) -> List[NewsEvent]`
    - Abstract method: `async def check_blackout_window(symbol: str) -> tuple[bool, NewsEvent | None]`
  - [ ] Make EarningsCalendarService inherit from NewsCalendarService
  - [ ] Make ForexNewsCalendarService inherit from NewsCalendarService
  - [ ] Define `NewsCalendarFactory` class:
    - Method: `get_calendar(asset_class: AssetClass) -> NewsCalendarService`
    - If asset_class == STOCK: return EarningsCalendarService instance
    - If asset_class == FOREX: return ForexNewsCalendarService instance
    - Singleton pattern: reuse instances across calls

- [ ] Implement StrategyValidator class inheriting from BaseValidator (AC: 1, 7, 11)
  - [ ] Create file: `backend/src/signal_generator/validators/strategy_validator.py`
  - [ ] Set class properties:
    - `validator_id = "STRATEGY_VALIDATOR"`
    - `stage_name = "Strategy"`
  - [ ] Import required models:
    - ValidationResult, ValidationStatus, ValidationContext from models/validation
    - MarketContext, MarketRegime, NewsEvent, InvalidationEvent, AssetClass from models/market_context
    - Pattern from models/pattern
    - NewsCalendarFactory from services/news_calendar_factory (NEW - AC: 11, 14)
  - [ ] Add structlog logger initialization: `logger = structlog.get_logger()`
  - [ ] Constructor: inject NewsCalendarFactory dependency (replaces EarningsCalendarService for asset class awareness)
  - [ ] Implement `async def validate(context: ValidationContext) -> ValidationResult`

- [ ] Validate market_context presence in context (AC: 1)
  - [ ] Check if `context.market_context` is not None
  - [ ] If None, return FAIL ValidationResult:
    - status = ValidationStatus.FAIL
    - reason = "Market context not available for strategy validation"
    - Log error: "market_context_missing" with pattern details
  - [ ] Extract market_context from context
  - [ ] Extract pattern details: pattern_type, symbol, confidence_score

- [ ] Implement market regime validation (AC: 2)
  - [ ] Create method: `_validate_market_regime(pattern_type: str, market_context: MarketContext) -> tuple[bool, str | None, ValidationStatus]`
  - [ ] Return tuple: (passes: bool, reason: str | None, status: ValidationStatus)
  - [ ] Status can be PASS, WARN (borderline), or FAIL (AC: 3, 4)
  - [ ] Market regime rules (ASSET-CLASS-AWARE - AC: 11):
    - **Spring in HIGH_VOLATILITY:**
      - If market_context.is_extreme_volatility (ATR >= 95th percentile for stocks, >= 90th for forex):
      - Return (False, f"Spring pattern in extreme volatility (ATR {volatility_percentile}th percentile, threshold {95 if stock else 90}) - high false breakout risk. Consider waiting for volatility to normalize.", ValidationStatus.FAIL)
    - **SOS in SIDEWAYS market:**
      - If market_regime == MarketRegime.SIDEWAYS and pattern_type == "SOS":
      - Check ADX: if adx < 25, market not trending
      - Return (True, f"SOS breakout in sideways market (ADX {adx:.1f} < 25) - lower probability of sustained trend. Monitor for follow-through.", ValidationStatus.WARN)
    - **UTAD in TRENDING_UP:**
      - If market_regime == MarketRegime.TRENDING_UP and pattern_type == "UTAD":
      - Return (True, f"UTAD (distribution) pattern in uptrending market - contrarian signal requires strong confirmation.", ValidationStatus.WARN)
  - [ ] Log market regime check with pattern_type, regime, volatility, ADX
  - [ ] William's reasoning: Log why regime is or isn't suitable for pattern

- [ ] **WYCKOFF ENHANCEMENT**: Implement UTAD failure bar volume validation
  - [ ] Create method: `_validate_utad_failure_bars(pattern: Pattern, volume_analysis_sequence: List[VolumeAnalysis]) -> tuple[bool, str | None]`
  - [ ] **Context**: Story 8.3 validates UTAD initial bar volume (>= 1.2x), this validates failure bars
  - [ ] **Wyckoff Principle**: After UTAD supply climax, buying should dry up (decreasing volume on failure)
  - [ ] Validation logic:
    - Require pattern.failure_bars (list of bars following UTAD high)
    - Minimum 2 failure bars required for validation
    - Check volume trend: each subsequent bar should have volume <= previous bar
    - Tolerance: Allow one bar with slight increase (<10%), but overall trend must decrease
    - Calculate average_failure_volume = mean(failure_bar_volumes)
    - If average_failure_volume >= utad_initial_volume * 0.8:
      - Return (False, f"UTAD failure bars show persistent volume ({average_failure_volume:.2f}x vs initial {utad_initial_volume:.2f}x) - buying not drying up, distribution questionable")
  - [ ] If volume decreasing properly:
    - Return (True, None) - Confirms buying exhaustion per Wyckoff
  - [ ] Add metadata: failure_bar_count, average_failure_volume, volume_trend_direction
  - [ ] Log UTAD failure validation: logger.debug("william_utad_failure_check", ...)
  - [ ] **Rationale**: UTAD shows distribution - failure to rally after supply climax confirms lack of demand

- [ ] Implement news blackout window validation - ASSET-CLASS-AWARE (AC: 2, 5, 8, 11, 14, FR29)
  - [ ] Create method: `async def _validate_news_blackout(symbol: str, asset_class: AssetClass, news_calendar_factory: NewsCalendarFactory) -> tuple[bool, str | None]`
  - [ ] Get appropriate calendar: `news_service = news_calendar_factory.get_calendar(asset_class)`
  - [ ] Call `in_blackout, news_event = await news_service.check_blackout_window(symbol)`
  - [ ] If news_service API call fails (returns (False, None) due to error):
    - Log WARNING: f"{asset_class} news API unavailable, proceeding without news check"
    - Return (True, None) - Don't block signal on API failure (graceful degradation)
  - [ ] If news_event is None (no upcoming high-impact events):
    - Return (True, None) - No events scheduled, PASS
  - [ ] If in_blackout == True:
    - **STOCK (Earnings):**
      - Blackout: 24 hours BEFORE or 2 hours AFTER earnings (FR29)
      - Return (False, f"Earnings announcement for {symbol} in {news_event.hours_until_event:.1f} hours violates 24-hour pre-earnings blackout window (FR29). Avoid gap risk by waiting until after earnings.")
    - **FOREX (High-Impact News):**
      - Blackout: 4 hours BEFORE or 1 hour AFTER high-impact event (NFP, FOMC, ECB, etc.)
      - Return (False, f"{news_event.event_type} event affecting {symbol} in {news_event.hours_until_event:.1f} hours violates 4-hour forex news blackout window. High-impact events cause extreme tick volume spikes and spread widening - not valid for Wyckoff analysis.")
  - [ ] If outside blackout:
    - Return (True, None)
  - [ ] Log news check: asset_class, symbol, event_type, event_date, hours_until, within_blackout
  - [ ] Unit test targets (AC: 5):
    - Stock: earnings 12 hours away → FAIL
    - Forex: NFP 2 hours away → FAIL
    - Forex: FOMC 6 hours away → FAIL (within 4-hour window)

- [ ] Implement recent invalidation check - ASSET-CLASS-AWARE (AC: 2, ENHANCED - Rachel)
  - [ ] Create method: `_validate_recent_invalidations(pattern_type: str, campaign_id: str | None, recent_invalidations: List[InvalidationEvent], asset_class: AssetClass) -> tuple[bool, str | None]`
  - [ ] Filter invalidations for same campaign_id (if campaign tracking enabled)
  - [ ] If campaign_id is None: skip this check (return True, None)
  - [ ] Cooldown period - ASSET-CLASS-AWARE (ENHANCED - Rachel):
    - **Stocks**: 5 trading days (campaigns develop slower, daily close matters)
    - **Forex**: 3 calendar days (24/5 market, faster structure development, 24hr volume accumulates 5x faster)
    - Rationale: 3 forex days ≈ 5 stock days in terms of volume/structure development
    ```python
    if asset_class == AssetClass.STOCK:
        cooldown_days = 5.0  # 1 trading week for new structure
    elif asset_class == AssetClass.FOREX:
        cooldown_days = 3.0  # Forex ranges develop faster (24hr trading)
    else:
        cooldown_days = 5.0  # Default
    ```
  - [ ] Find invalidations matching:
    - Same campaign_id OR same trading_range_id
    - days_ago <= cooldown_days (asset-class-specific threshold)
  - [ ] If matching invalidation found:
    - Return (False, f"Recent invalidation in campaign {campaign_id} ({invalidation.days_ago:.1f} days ago, reason: {invalidation.invalidation_reason}). Wait for new trading structure to develop before re-entering. [{asset_class.value}: {cooldown_days}-day cooldown]")
  - [ ] If no recent invalidation:
    - Return (True, None)
  - [ ] Log invalidation check: campaign_id, invalidation count, cooldown_days, asset_class
  - [ ] Rationale: Don't re-enter failed campaign immediately (Wyckoff principle: respect invalidations). Different market rhythms require different cooldowns.

- [ ] Implement time-based validation - ASSET-CLASS-AWARE (AC: 2, 12, 13)
  - [ ] Create method: `_validate_time_of_day(asset_class: AssetClass, time_of_day: time, market_session: str, forex_session: ForexSession | None, current_datetime: datetime) -> tuple[bool, str | None, ValidationStatus]`
  - [ ] **STOCK Market hours definition (EST/EDT for US markets):**
    - PRE_MARKET: 04:00 - 09:30
    - REGULAR: 09:30 - 16:00
    - AFTER_HOURS: 16:00 - 20:00
  - [ ] **STOCK Rules:**
    - End-of-day threshold: Last 60 minutes of regular session (15:00 - 16:00 EST)
    - If market_session == "PRE_MARKET":
      - Return (True, "Pre-market entry - ensure sufficient liquidity and be prepared for gap risk at market open.", ValidationStatus.WARN)
    - If market_session == "AFTER_HOURS":
      - Return (True, "After-hours entry - low liquidity may cause slippage. Consider waiting for regular session.", ValidationStatus.WARN)
    - If market_session == "REGULAR" and time_of_day >= time(15, 0):
      - Return (True, f"Entry at {time_of_day.strftime('%H:%M')} near market close - insufficient time for pattern to develop intraday. Consider overnight hold or wait for next session.", ValidationStatus.WARN)
    - If regular session and before 15:00:
      - Return (True, None, ValidationStatus.PASS) - Optimal entry time
  - [ ] **FOREX Rules (NEW - AC: 12, 13):**
    - Forex markets trade 24/5 (Sunday 5pm EST → Friday 5pm EST)
    - **CRITICAL: Friday Weekend Gap Risk (AC: 13):**
      - Get current weekday: `weekday = current_datetime.weekday()` (0=Mon, 4=Fri)
      - Get current hour (UTC): `hour = current_datetime.hour`
      - **Friday after 17:00 UTC (12pm EST):**
        - If weekday == 4 and hour >= 17:
          - Return (False, f"Friday entry after 12pm EST rejected. Forex markets close in {24 - hour} hours. Weekend gap risk violates Wyckoff controlled-risk principle. Position would hold through 48-hour market closure with potential for major news-driven gaps (e.g., central bank emergency meetings, geopolitical events).", ValidationStatus.FAIL)
      - **Friday 13:00-17:00 UTC (8am-12pm EST):**
        - If weekday == 4 and 13 <= hour < 17:
          - Return (True, f"Friday morning entry - WARNING: Position will likely hold over weekend. Consider reducing position size to 50% to mitigate weekend gap risk. Forex markets close at 5pm EST today.", ValidationStatus.WARN)
    - **Session-Based Warnings (AC: 12, ENHANCED - Victoria/Rachel):**
      - If forex_session == ForexSession.ASIAN:
        - Return (True, "Asian session entry - Lower liquidity and ranging behavior common. Wyckoff patterns more reliable during London/NY sessions (higher professional participation). WARNING: Spread widening (2-3x normal) during Asian session - ensure stop loss accounts for wider spreads to avoid stop-out on spread volatility alone, not genuine supply. (Victoria: Low volume = low Composite Operator activity. Rachel: Structural Wyckoff stops may be breached by spread alone.)", ValidationStatus.WARN)
      - If forex_session in [ForexSession.LONDON, ForexSession.NY, ForexSession.OVERLAP]:
        - Return (True, None, ValidationStatus.PASS) - Optimal forex entry sessions (highest liquidity, Composite Operator activity)
    - **Wednesday Rollover Warning (NEW - Rachel):**
      - If asset_class == FOREX and weekday == 2 (Wednesday) and hour >= 17 (5pm EST):
        - Return (True, "Wednesday PM entry incurs triple rollover swap charge overnight (accounting for weekend). Wyckoff principle: Total cost analysis includes carrying costs. Triple swap can be 0.1-0.3% of position - material for tight structural setups. Consider entry cost vs setup quality.", ValidationStatus.WARN)
  - [ ] Log time validation: asset_class, time_of_day, market_session (stocks), forex_session (forex), weekday, warning issued
  - [ ] Note: WARN allows entry with caution, FAIL blocks entry (Friday PM forex only)

- [ ] Implement strategic override logic for high-conviction signals (AC: 4)
  - [ ] Create method: `_check_override_eligibility(pattern_confidence: float, validation_status: ValidationStatus, reason: str | None) -> tuple[ValidationStatus, str | None]`
  - [ ] Override threshold: confidence >= 90% (high-conviction signal)
  - [ ] Override rules:
    - Can override WARN status → PASS (with note in metadata)
    - CANNOT override FAIL status (safety critical: earnings blackout, recent invalidation)
  - [ ] Logic:
    - If validation_status == ValidationStatus.FAIL:
      - No override allowed, return (FAIL, reason)
    - If validation_status == ValidationStatus.WARN and pattern_confidence >= 0.90:
      - Override to PASS
      - New reason: f"HIGH-CONVICTION OVERRIDE (confidence {pattern_confidence*100:.0f}%): Original warning: {reason}. Signal approved despite warning due to exceptional pattern quality."
      - Log override: pattern_confidence, original_reason
      - Return (PASS, new_reason)
    - Otherwise:
      - Return original (status, reason)
  - [ ] Track overrides in metadata for pattern learning feedback loop (AC: 10)
  - [ ] Log all override decisions for review

- [ ] Implement human review flagging for borderline cases (AC: 9)
  - [ ] Create method: `_flag_for_human_review(validation_warnings: List[str], pattern_confidence: float) -> tuple[bool, str | None]`
  - [ ] Borderline criteria:
    - Pattern confidence between 70-80% (low but passing)
    - Multiple warnings issued (len(validation_warnings) >= 2)
    - Single critical warning (e.g., "SOS in sideways market")
  - [ ] If borderline:
    - Return (True, f"Flagged for human review: {len(validation_warnings)} warnings, confidence {pattern_confidence*100:.0f}%. Review before execution.")
  - [ ] If not borderline:
    - Return (False, None)
  - [ ] Store flag in ValidationResult.metadata:
    - "needs_human_review": True/False
    - "review_reason": explanation string
  - [ ] Human review queue: signals with this flag go to manual approval workflow

- [ ] Implement main validate method orchestration (AC: 1, 7)
  - [ ] In `async def validate(context: ValidationContext) -> ValidationResult`:
    - Log validation start: pattern_id, pattern_type, symbol, confidence
    - Add William's reasoning prefix to all logs
  - [ ] Step 1: Validate market_context presence
    - If fails, return FAIL ValidationResult immediately
  - [ ] Step 2: Extract pattern details
    - pattern_type, symbol, campaign_id, confidence_score from context.pattern
  - [ ] Step 3: Validate market regime (AC: 2)
    - Call `_validate_market_regime(pattern_type, market_context)`
    - If returns FAIL: return FAIL ValidationResult with reason
    - If returns WARN: accumulate warning, continue
  - [ ] Step 4: Validate earnings blackout window (AC: 2, 8, FR29)
    - Call `await _validate_earnings_blackout(symbol, earnings_service)`
    - If returns False (in blackout): return FAIL ValidationResult
    - This is non-negotiable: earnings risk overrides all other factors
  - [ ] Step 5: Validate recent invalidations (AC: 2)
    - Call `_validate_recent_invalidations(pattern_type, campaign_id, market_context.recent_invalidations)`
    - If returns False: return FAIL ValidationResult with cooldown message
  - [ ] Step 6: Validate time of day (AC: 2)
    - Call `_validate_time_of_day(market_context.time_of_day, market_context.market_session)`
    - If returns WARN: accumulate warning, continue
  - [ ] Step 7: Check strategic overrides (AC: 4)
    - If any warnings accumulated, check if high-conviction signal can override
    - Call `_check_override_eligibility(confidence_score, current_status, warnings)`
    - Update status if override applied
  - [ ] Step 8: Flag for human review if borderline (AC: 9)
    - Call `_flag_for_human_review(accumulated_warnings, confidence_score)`
    - Add flag to metadata
  - [ ] If all validations pass:
    - Create ValidationResult with status = PASS (or WARN if warnings)
    - Add comprehensive metadata (see metadata section below)
    - Log validation success with William's reasoning
  - [ ] Return ValidationResult

- [ ] Add comprehensive metadata for audit trail and pattern learning (AC: 7, 10)
  - [ ] When creating ValidationResult, populate metadata dict:
    - "market_regime": market_context.market_regime.value
    - "volatility_percentile": market_context.volatility_percentile
    - "is_extreme_volatility": market_context.is_extreme_volatility
    - "adx": float(market_context.adx) if market_context.adx else None
    - "time_of_day": market_context.time_of_day.strftime("%H:%M")
    - "market_session": market_context.market_session
    - "earnings_check_passed": True/False
    - "earnings_hours_until": earnings_data.hours_until_event if earnings_data else None
    - "earnings_blackout_window": earnings_data.within_blackout_window if earnings_data else False
    - "recent_invalidation_count": len(market_context.recent_invalidations)
    - "invalidation_cooldown_active": True/False
    - "warnings_issued": list of warning messages
    - "override_applied": True/False
    - "override_reason": override reason if applicable
    - "needs_human_review": True/False
    - "review_reason": human review reason if flagged
    - "william_reasoning": "William's strategic assessment: [summary]"
  - [ ] This metadata enables pattern learning feedback loop (AC: 10)

- [ ] Add "William's reasoning" logging throughout (AC: 7)
  - [ ] Log validation start:
    - `logger.info("william_strategy_validation_started", pattern_id=str(context.pattern.id), pattern_type=context.pattern.pattern_type, symbol=context.symbol, confidence=context.pattern.confidence_score)`
  - [ ] Log market regime check:
    - `logger.debug("william_market_regime_check", regime=market_context.market_regime.value, volatility_pct=market_context.volatility_percentile, adx=float(market_context.adx) if market_context.adx else None, assessment="[William's assessment]")`
  - [ ] Log earnings check:
    - `logger.info("william_earnings_check", symbol=symbol, has_upcoming_earnings=earnings_data is not None, hours_until=earnings_data.hours_until_event if earnings_data else None, blackout_active=earnings_data.within_blackout_window if earnings_data else False, reasoning="[William's reasoning]")`
  - [ ] Log invalidation check:
    - `logger.debug("william_invalidation_check", campaign_id=campaign_id, recent_invalidations=len(market_context.recent_invalidations), cooldown_active=True/False, reasoning="[William's wisdom on respecting invalidations]")`
  - [ ] Log time-of-day check:
    - `logger.debug("william_time_check", time=market_context.time_of_day.strftime("%H:%M"), session=market_context.market_session, end_of_day_warning=True/False, reasoning="[William's advice on timing]")`
  - [ ] Log override decision:
    - `logger.warning("william_high_conviction_override", pattern_confidence=context.pattern.confidence_score, original_warning=original_reason, override_applied=True, reasoning="[William's justification for override]")`
  - [ ] Log human review flag:
    - `logger.info("william_human_review_flagged", confidence=context.pattern.confidence_score, warning_count=len(warnings), flag_reason=review_reason, reasoning="[William recommends manual review]")`
  - [ ] Log validation pass:
    - `logger.info("william_strategy_validation_passed", pattern_type=context.pattern.pattern_type, regime=market_context.market_regime.value, warnings_count=len(warnings), override_applied=override_applied, reasoning="[William's final approval reasoning]")`
  - [ ] Log validation fail:
    - `logger.warning("william_strategy_validation_failed", reason=reason, failed_check=failed_check, reasoning="[William's rejection reasoning]")`

- [ ] Add detailed rejection/warning messages with William's wisdom and Wyckoff principles
  - [ ] Extreme volatility rejection:
    - f"William's assessment: Spring pattern in extreme volatility (ATR at {volatility_percentile}th percentile) carries high false breakout risk. **Wyckoff Principle**: 'Genuine accumulation occurs in calm markets where Composite Operators can methodically accumulate without drawing attention. Chaos and panic create noise, not opportunity.' Wait for volatility to normalize before entering."
  - [ ] SOS in sideways market warning:
    - f"William's caution: SOS breakout attempt in sideways market (ADX {adx:.1f} < 25 indicates weak trend). **Wyckoff Principle**: 'Sign of Strength is most reliable when emerging from established accumulation Phase C into markup Phase D. Sideways breakouts lack the foundational cause.' Monitor closely for follow-through volume and price action."
  - [ ] Earnings blackout rejection:
    - f"William's rule: Earnings announcement for {symbol} in {hours_until:.1f} hours violates our 24-hour pre-earnings blackout (FR29). **Wyckoff Principle**: 'Wyckoff never advocated gambling on binary events. His method reads price and volume action - not speculative event outcomes. Gap risk is antithetical to methodical analysis.' Wait until after earnings settles (Reference: Wyckoff, Studies in Tape Reading)."
  - [ ] Recent invalidation rejection:
    - f"William's wisdom: Recent stop-out in campaign {campaign_id} just {days_ago:.1f} days ago (reason: {invalidation_reason}). **Wyckoff Principle**: 'When the Composite Operator invalidates a campaign by breaking key levels, respect their intention. They have shown their hand - distribution is underway. Wait for a new structure to develop, not a rehash of the failed one.' (Reference: Wyckoff, Law of Effort vs Result)."
  - [ ] End-of-day warning:
    - f"William's timing advice: Entry at {time_of_day.strftime('%H:%M')} leaves insufficient time for pattern to develop before market close. **Wyckoff Principle**: 'Patterns need time and volume to unfold properly. Price movements are campaigns, not isolated events. Rushing entry violates the natural rhythm of market action.' Consider waiting for next session or accept overnight hold risk."

- [ ] Write unit tests for market regime validation (AC: 2, 3)
  - [ ] Create test file: `backend/tests/unit/signal_generator/validators/test_strategy_validator.py`
  - [ ] Test case: Spring in HIGH_VOLATILITY (ATR 98th percentile) → FAIL
    - Create MarketContext with:
      - market_regime = MarketRegime.HIGH_VOLATILITY
      - volatility_percentile = 98
      - is_extreme_volatility = True
    - Pattern type: SPRING
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "extreme volatility" in result.reason
    - Assert: "ATR" in result.reason
  - [ ] Test case: Spring in normal volatility → PASS
    - MarketContext: volatility_percentile = 50, regime = TRENDING_UP
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: SOS in SIDEWAYS market (ADX 18) → WARN
    - MarketContext:
      - market_regime = MarketRegime.SIDEWAYS
      - adx = 18 (below 25 threshold)
    - Pattern type: SOS
    - Assert: result.status == ValidationStatus.WARN
    - Assert: "sideways market" in result.reason
    - Assert: "ADX" in result.reason
  - [ ] Test case: SOS in TRENDING_UP (ADX 35) → PASS
    - MarketContext: regime = TRENDING_UP, adx = 35
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: UTAD in TRENDING_UP market → WARN (contrarian)
    - MarketContext: regime = TRENDING_UP
    - Pattern type: UTAD
    - Assert: result.status == ValidationStatus.WARN
    - Assert: "uptrending market" in result.reason
    - Assert: "contrarian" in result.reason

- [ ] **WYCKOFF ENHANCEMENT**: Write unit tests for UTAD failure bar validation
  - [ ] Test case: UTAD with properly decreasing failure bar volume → PASS
    - Pattern type: UTAD
    - Initial bar volume: 1.5x
    - Failure bars: [1.2x, 0.9x, 0.7x] (decreasing trend)
    - Average failure volume: 0.93x (< 1.5x * 0.8 = 1.2x threshold)
    - Assert: returns (True, None)
    - Confirms buying exhaustion per Wyckoff
  - [ ] Test case: UTAD with persistent failure bar volume → FAIL
    - Initial bar volume: 1.5x
    - Failure bars: [1.4x, 1.3x, 1.35x] (high volume persists)
    - Average failure volume: 1.35x (>= 1.2x threshold)
    - Assert: returns (False, rejection_reason)
    - Assert: "persistent volume" in reason
    - Assert: "buying not drying up" in reason
  - [ ] Test case: UTAD with insufficient failure bars (<2 bars) → SKIP
    - Failure bars: [1.2x] (only 1 bar)
    - Assert: validation skipped (need minimum 2 bars for trend)
  - [ ] Test case: UTAD with one spike but overall decreasing → PASS
    - Failure bars: [1.0x, 1.15x (spike), 0.8x, 0.6x]
    - Overall trend: decreasing despite one spike
    - Assert: returns (True, None) - tolerance for one anomaly
  - [ ] Verify metadata includes: failure_bar_count, average_failure_volume, volume_trend_direction

- [ ] Write unit tests for earnings blackout validation (AC: 5, 8, FR29)
  - [ ] Test case: Earnings in 12 hours → FAIL (AC: 5)
    - Create EarningsEvent:
      - earnings_date = datetime.now(UTC) + timedelta(hours=12)
      - hours_until_event = 12.0
      - within_blackout_window = True (12 < 24 hour threshold)
    - Call _validate_earnings_blackout()
    - Assert: returns (False, rejection_reason)
    - Assert: "Earnings announcement" in reason
    - Assert: "12.0 hours" in reason
    - Assert: "FR29" in reason
  - [ ] Test case: Earnings in 30 hours → PASS (outside 24-hour window)
    - hours_until_event = 30.0
    - within_blackout_window = False
    - Assert: returns (True, None)
  - [ ] Test case: Earnings 1 hour ago (already passed, < -2 hours) → PASS
    - hours_until_event = -3.0
    - within_blackout_window = False
    - Assert: returns (True, None)
  - [ ] Test case: Earnings 30 minutes ago (within 2-hour post window) → FAIL
    - hours_until_event = -0.5
    - within_blackout_window = True (-0.5 > -2.0)
    - Assert: returns (False, rejection_reason)
  - [ ] Test case: No upcoming earnings (earnings_data = None) → PASS
    - Assert: returns (True, None)
  - [ ] Test case: Earnings API failure → PASS (graceful degradation)
    - Mock earnings_service.get_upcoming_earnings() raises exception
    - Assert: returns (True, None) - don't block signal
    - Assert: WARNING logged about API unavailability

- [ ] Write unit tests for recent invalidation check (AC: 2)
  - [ ] Test case: Invalidation 2 days ago in same campaign → FAIL
    - Create InvalidationEvent:
      - campaign_id = "campaign-123"
      - days_ago = 2.0
      - invalidation_reason = "Spring low broken"
    - Pattern campaign_id = "campaign-123"
    - Assert: returns (False, rejection_reason)
    - Assert: "Recent invalidation" in reason
    - Assert: "2.0 days ago" in reason
  - [ ] Test case: Invalidation 6 days ago (outside 5-day cooldown) → PASS
    - days_ago = 6.0
    - Assert: returns (True, None)
  - [ ] Test case: Invalidation in different campaign → PASS
    - InvalidationEvent campaign_id = "campaign-456"
    - Pattern campaign_id = "campaign-123"
    - Assert: returns (True, None)
  - [ ] Test case: No recent invalidations → PASS
    - recent_invalidations = []
    - Assert: returns (True, None)
  - [ ] Test case: campaign_id is None (no campaign tracking) → PASS
    - Pattern campaign_id = None
    - Assert: returns (True, None) - skip check

- [ ] Write unit tests for time-based validation (AC: 2)
  - [ ] Test case: Entry at 10:00 AM regular session → PASS
    - time_of_day = time(10, 0)
    - market_session = "REGULAR"
    - Assert: returns (True, None, ValidationStatus.PASS)
  - [ ] Test case: Entry at 15:30 (30 min before close) → WARN
    - time_of_day = time(15, 30)
    - market_session = "REGULAR"
    - Assert: returns (True, warning_reason, ValidationStatus.WARN)
    - Assert: "near market close" in reason
    - Assert: "insufficient time" in reason
  - [ ] Test case: Entry in PRE_MARKET session → WARN
    - market_session = "PRE_MARKET"
    - Assert: returns (True, warning_reason, ValidationStatus.WARN)
    - Assert: "Pre-market" in reason
    - Assert: "liquidity" in reason
  - [ ] Test case: Entry in AFTER_HOURS session → WARN
    - market_session = "AFTER_HOURS"
    - Assert: returns (True, warning_reason, ValidationStatus.WARN)
    - Assert: "After-hours" in reason
    - Assert: "slippage" in reason

- [ ] Write unit tests for strategic override logic (AC: 4)
  - [ ] Test case: High-conviction (92%) overrides WARN → PASS
    - pattern_confidence = 0.92 (92%)
    - Original status = WARN (from SOS in sideways market)
    - Call _check_override_eligibility()
    - Assert: returns (ValidationStatus.PASS, override_reason)
    - Assert: "HIGH-CONVICTION OVERRIDE" in reason
    - Assert: "92%" in reason
  - [ ] Test case: Low-conviction (75%) cannot override WARN → WARN
    - pattern_confidence = 0.75
    - Original status = WARN
    - Assert: returns (ValidationStatus.WARN, original_reason)
    - No override applied
  - [ ] Test case: High-conviction (95%) CANNOT override FAIL → FAIL
    - pattern_confidence = 0.95
    - Original status = FAIL (earnings blackout)
    - Assert: returns (ValidationStatus.FAIL, original_reason)
    - Safety-critical failures not overridable
  - [ ] Test case: Override decision logged for pattern learning
    - Verify metadata includes "override_applied": True
    - Verify metadata includes "override_reason"

- [ ] Write unit tests for human review flagging (AC: 9)
  - [ ] Test case: Low confidence (72%) with 2 warnings → Flag for review
    - pattern_confidence = 0.72
    - warnings = ["SOS in sideways market", "Entry near market close"]
    - Assert: returns (True, review_reason)
    - Assert: "human review" in reason
    - Assert: "2 warnings" in reason
  - [ ] Test case: High confidence (88%) with 1 warning → No flag
    - pattern_confidence = 0.88
    - warnings = ["Entry near market close"]
    - Assert: returns (False, None)
  - [ ] Test case: No warnings → No flag
    - warnings = []
    - Assert: returns (False, None)
  - [ ] Verify flag stored in metadata: "needs_human_review": True

- [ ] Write integration test for full strategy validation scenarios (AC: 6)
  - [ ] Create test file: `backend/tests/integration/signal_generator/test_strategy_validation_integration.py`
  - [ ] Test scenario 1: Valid signal passes all strategic checks
    - Build full ValidationContext:
      - Pattern: SPRING, confidence 85%
      - MarketContext:
        - market_regime = TRENDING_UP
        - volatility_percentile = 60 (normal)
        - adx = 30 (trending)
        - time_of_day = time(10, 30) (mid-morning)
        - market_session = "REGULAR"
        - earnings_data = None (no upcoming earnings)
        - recent_invalidations = [] (no failures)
    - Create StrategyValidator with mocked EarningsCalendarService
    - Call validate(context)
    - Assert: result.status == ValidationStatus.PASS
    - Assert: result.reason is None
    - Assert: metadata includes all checks passed
  - [ ] Test scenario 2: Signal rejected due to earnings blackout (FR29)
    - MarketContext with earnings_data:
      - hours_until_event = 18.0 (within 24-hour window)
      - within_blackout_window = True
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "Earnings announcement" in result.reason
    - Assert: "18.0 hours" in result.reason
    - Assert: "FR29" in result.reason
  - [ ] Test scenario 3: Signal warned for SOS in sideways market
    - Pattern: SOS
    - MarketContext:
      - market_regime = SIDEWAYS
      - adx = 18
    - Assert: result.status == ValidationStatus.WARN
    - Assert: "sideways market" in result.reason
    - Assert: "ADX 18" in result.reason
  - [ ] Test scenario 4: High-conviction signal overrides warning
    - Pattern: SOS, confidence 93%
    - MarketContext: SIDEWAYS, ADX 20 (triggers warning)
    - Assert: result.status == ValidationStatus.PASS (override applied)
    - Assert: "HIGH-CONVICTION OVERRIDE" in result.reason
    - Assert: metadata["override_applied"] == True
  - [ ] Test scenario 5: Signal rejected due to recent invalidation
    - MarketContext with recent_invalidations:
      - InvalidationEvent: campaign_id="camp-123", days_ago=3.0
    - Pattern: campaign_id="camp-123"
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "Recent invalidation" in result.reason
    - Assert: "3.0 days ago" in result.reason
  - [ ] Test scenario 6: Signal flagged for human review (borderline)
    - Pattern: confidence 73% (low)
    - Multiple warnings issued (SOS in sideways + end of day)
    - Assert: result.status == ValidationStatus.WARN
    - Assert: metadata["needs_human_review"] == True
    - Assert: metadata["review_reason"] includes warning details

- [ ] Write integration test with mocked EarningsCalendarService
  - [ ] Mock earnings service to return specific EarningsEvent
  - [ ] Verify earnings API called with correct symbol
  - [ ] Verify cache behavior (second call doesn't hit API)
  - [ ] Verify graceful degradation on API failure
  - [ ] Test full validation chain with earnings check integrated

- [ ] Write edge case tests
  - [ ] Test with context.market_context = None → FAIL "Market context missing"
  - [ ] Test with all validations at boundaries (ADX exactly 25, hours exactly 24.0)
  - [ ] Test multiple simultaneous warnings (regime + time + volatility)
  - [ ] Test override eligibility at 89.9% confidence (just below 90% threshold)
  - [ ] Test cooldown at exactly 5.0 days (edge of threshold)

- [ ] Add pytest fixtures for common test scenarios
  - [ ] Create fixture: `valid_market_context()` - Returns MarketContext with all checks passing
  - [ ] Create fixture: `high_volatility_context()` - MarketContext with extreme volatility
  - [ ] Create fixture: `sideways_market_context()` - MarketContext with ADX < 25
  - [ ] Create fixture: `earnings_blackout_context()` - MarketContext with upcoming earnings
  - [ ] Create fixture: `recent_invalidation_context()` - MarketContext with stop-out 2 days ago
  - [ ] Create fixture: `end_of_day_context()` - MarketContext at 15:30
  - [ ] Create fixture: `mock_earnings_service()` - Mocked EarningsCalendarService
  - [ ] Create fixture: `high_conviction_pattern()` - Pattern with 92% confidence

- [ ] Document FR29 compliance in docstrings (AC: 8)
  - [ ] Add comprehensive module docstring to strategy_validator.py:
    - Explain FR29: 24-hour pre-earnings and 2-hour post-earnings blackout
    - Rationale: Avoid binary gap risk events that violate Wyckoff price action principles
    - Document Polygon.io API integration for earnings calendar
    - Document cache strategy (24-hour TTL)
    - Document graceful degradation on API failure
  - [ ] Add class docstring to StrategyValidator
  - [ ] Add method docstrings for all validation methods with FR29 references
  - [ ] Include code examples showing proper usage

- [ ] Add validation result examples to docstrings
  - [ ] Document PASS example:
    ```python
    # Valid signal with all strategic checks passing
    result = ValidationResult(
        stage="Strategy",
        status=ValidationStatus.PASS,
        reason=None,
        validator_id="STRATEGY_VALIDATOR",
        metadata={
            "market_regime": "TRENDING_UP",
            "volatility_percentile": 60,
            "earnings_check_passed": True,
            "recent_invalidation_count": 0,
            "warnings_issued": [],
            "needs_human_review": False,
            "william_reasoning": "William's approval: Clean setup in trending market..."
        }
    )
    ```
  - [ ] Document FAIL examples for common rejection scenarios:
    - Earnings blackout window violation (FR29)
    - Extreme volatility rejection
    - Recent invalidation cooldown active
  - [ ] Document WARN examples:
    - SOS in sideways market
    - End-of-day entry timing
    - High-conviction override scenario

## Dev Notes

### Previous Story Insights

**From Story 8.2 (Multi-Stage Validation Workflow):**
- Created ValidationResult, ValidationChain, ValidationContext models
- Defined BaseValidator abstract class with validate() method
- Created StrategyValidator stub with TODO for full implementation
- ValidationStatus enum: PASS, FAIL, WARN
- Validators return ValidationResult with status, reason, metadata
- This story (8.7) replaces the stub with full Wyckoff strategy validation and FR29 earnings integration
- Integration point: StrategyValidator is FINAL (5th) stage in validation chain

**From Story 8.3 (Volume Validation Stage):**
- Established pattern for validation methods: `_validate_<check_type>()` helper methods
- Comprehensive logging with structlog for all validation decisions
- Detailed rejection reasons with actual vs threshold values
- Metadata dict for audit trail (actual values, thresholds, limits)
- Edge case handling: missing data returns FAIL, not exception
- Non-negotiable failures: some checks always FAIL, never WARN

**From Story 8.4 (Phase Validation Stage):**
- Complex multi-step validation orchestration in main validate() method
- Each sub-validation returns tuple: (passes: bool, reason: str | None, value/status: Any)
- Early return on first failure (fail fast)
- Parametrized tests for comprehensive coverage of rule combinations
- FR enforcement documented in docstrings with source references

**From Story 8.5 (Level Validation Stage):**
- Level validation ensures Creek/Ice/Jump structural integrity
- Validation provides entry/stop/target prices for downstream risk validation
- Three-tuple returns: (passes: bool, reason: str | None, status: ValidationStatus)
- Status can be PASS, WARN, or FAIL (introduces WARNING concept)

**From Story 8.6 (Risk Validation Stage):**
- Risk validation is 4th stage (runs before strategy validation)
- Validates position sizing, portfolio heat, campaign risk, R-multiples
- Comprehensive metadata for audit trail and compliance
- Fixed-point arithmetic (Decimal) for all calculations
- Integration with RiskManager service for position sizing

**Key Integration Points:**
- ValidationContext.market_context contains MarketContext for strategy checks
- StrategyValidator is FINAL validator in chain (after Volume, Phase, Levels, Risk)
- ValidationResult.metadata stores complete strategic reasoning for audit trail
- Earnings calendar API (Polygon.io) integrated for FR29 compliance
- Strategic override logic allows high-conviction signals to override WARN (not FAIL)
- Human review flagging for borderline cases (pattern learning feedback loop)

### Functional Requirements

**FR29: Earnings Blackout Window** [Source: docs/prd/requirements.md#FR29]
> "The system shall integrate with external news/earnings calendar API to detect scheduled events and implement trading halt 24 hours before and 2 hours after earnings announcements for affected symbols"

Implementation:
- **24-hour pre-earnings blackout**: No new positions within 24 hours before earnings announcement
- **2-hour post-earnings blackout**: No new positions within 2 hours after earnings release
- **API integration**: Polygon.io earnings calendar endpoint
- **Cache strategy**: 24-hour TTL for earnings data (minimize API calls)
- **Graceful degradation**: If API fails, log WARNING but don't block signal (prefer false positive to system halt)
- **Blackout window calculation**: `within_blackout = (-2.0 <= hours_until_event <= 24.0)`

Rationale:
- Earnings announcements create binary gap risk (large price movements overnight)
- Gaps violate Wyckoff price action analysis principles (sudden non-organic moves)
- Wyckoff method relies on methodical accumulation/distribution, not event speculation
- Professional traders avoid earnings - let amateurs gamble, we'll enter after dust settles

**FR20: Multi-Stage Validation Workflow** [Source: docs/prd/requirements.md#FR20]
> "The system shall validate trades through multi-stage approval requiring volume validation, phase validation, level validation, risk validation, and strategy validation before execution"

StrategyValidator role:
- **Final stage** in 5-stage validation chain (last line of defense)
- Catches signals that technically pass Volume/Phase/Levels/Risk but violate trading wisdom
- Implements Wyckoff sanity checks (market regime, timing, invalidations)
- Integrates external context (earnings, news, market conditions)
- Human review flagging for borderline cases (prevents low-quality signals)

**FR22: Trade Signal Output** [Source: docs/prd/requirements.md#FR22]
> "The system shall generate trade signals containing: symbol, pattern type, phase, entry price, stop loss, target levels, position size, risk amount, R-multiple, confidence score, campaign ID, and timestamp"

StrategyValidator contribution:
- Validates signal quality from strategic/contextual perspective
- Adds strategic metadata: market regime, earnings status, invalidation history
- Flags signals for human review if borderline quality
- Stores "William's reasoning" in metadata for trader review
- All validation decisions logged for compliance and pattern learning

### Data Models

**MarketRegime Enum** [Source: Story requirements, Wyckoff trading principles]

```python
from enum import Enum

class MarketRegime(str, Enum):
    """Market regime classification for strategy validation"""
    TRENDING_UP = "TRENDING_UP"         # Strong uptrend: ADX > 25, price > 20 SMA
    TRENDING_DOWN = "TRENDING_DOWN"     # Strong downtrend: ADX > 25, price < 20 SMA
    SIDEWAYS = "SIDEWAYS"               # Ranging/choppy: ADX < 25
    HIGH_VOLATILITY = "HIGH_VOLATILITY" # Extreme volatility: ATR > 95th percentile
```

**InvalidationEvent Model** [Source: Story requirements, Epic 7 campaign tracking]

```python
from decimal import Decimal
from pydantic import BaseModel, Field, computed_field
from datetime import datetime, timezone
from uuid import UUID

class InvalidationEvent(BaseModel):
    """Record of a pattern/campaign that was invalidated (stop-out)"""
    campaign_id: str = Field(..., description="Campaign that failed")
    symbol: str = Field(..., max_length=20)
    pattern_type: str = Field(..., description="Pattern that failed: SPRING, SOS, LPS, UTAD")
    invalidation_date: datetime = Field(..., description="When stop-out occurred (UTC)")
    invalidation_reason: str = Field(..., description="Why pattern failed (e.g., 'Spring low broken')")
    trading_range_id: UUID = Field(..., description="Which trading range invalidated")

    @computed_field
    @property
    def days_ago(self) -> float:
        """Calculate how many days ago invalidation occurred"""
        delta = datetime.now(timezone.utc) - self.invalidation_date
        return delta.total_seconds() / 86400  # Convert seconds to days

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat(), UUID: str}
```

**EarningsEvent Model** [Source: Story requirements, FR29]

```python
from decimal import Decimal
from pydantic import BaseModel, Field, computed_field
from datetime import datetime, timezone

class EarningsEvent(BaseModel):
    """Upcoming earnings announcement for a symbol (FR29)"""
    symbol: str = Field(..., max_length=20, description="Trading symbol")
    earnings_date: datetime = Field(..., description="Scheduled earnings announcement time (UTC)")
    fiscal_quarter: str = Field(..., description="e.g., 'Q1 2024', 'Q3 2023'")
    estimated_eps: Decimal | None = Field(default=None, description="Estimated earnings per share")

    @computed_field
    @property
    def hours_until_event(self) -> float:
        """Calculate hours until earnings announcement"""
        delta = self.earnings_date - datetime.now(timezone.utc)
        return delta.total_seconds() / 3600  # Convert seconds to hours

    @computed_field
    @property
    def within_blackout_window(self) -> bool:
        """Check if within FR29 blackout window (24hr before or 2hr after)"""
        hours = self.hours_until_event
        return -2.0 <= hours <= 24.0  # 24 hours before, 2 hours after

    class Config:
        json_encoders = {Decimal: str, datetime: lambda v: v.isoformat()}
```

**MarketContext Model** [Source: Story requirements, Epic 2 volume analysis, Epic 4 phase detection]

```python
from decimal import Decimal
from pydantic import BaseModel, Field, computed_field
from datetime import datetime, time, timezone
from typing import List

class MarketContext(BaseModel):
    """Market conditions and context for strategy validation"""
    symbol: str = Field(..., max_length=20)

    # Volatility metrics (from Epic 2 VolumeAnalyzer)
    current_volatility: Decimal = Field(
        ...,
        description="ATR as percentage of price",
        ge=0
    )
    volatility_percentile: int = Field(
        ...,
        description="Where ATR ranks vs 20-day range (0-100)",
        ge=0,
        le=100
    )

    # Market regime (derived from ADX and trend)
    market_regime: MarketRegime = Field(..., description="Current market classification")
    adx: Decimal | None = Field(
        default=None,
        description="Average Directional Index (trend strength indicator)"
    )

    # Invalidation history (from Epic 7 campaign tracking)
    recent_invalidations: List[InvalidationEvent] = Field(
        default_factory=list,
        description="Recent stop-outs in this symbol"
    )

    # Timing information
    time_of_day: time = Field(..., description="Current market time (HH:MM in market timezone)")
    market_session: str = Field(
        ...,
        description="PRE_MARKET | REGULAR | AFTER_HOURS"
    )

    # Earnings data (FR29)
    earnings_data: EarningsEvent | None = Field(
        default=None,
        description="Upcoming earnings event if scheduled"
    )

    # Metadata
    data_timestamp: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="When this context was calculated"
    )

    @computed_field
    @property
    def is_extreme_volatility(self) -> bool:
        """Check if volatility is extreme (>= 95th percentile)"""
        return self.volatility_percentile >= 95

    @computed_field
    @property
    def has_upcoming_earnings(self) -> bool:
        """Check if earnings scheduled and within blackout window"""
        return self.earnings_data is not None and self.earnings_data.within_blackout_window

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat(),
            time: lambda v: v.strftime("%H:%M")
        }
```

**ValidationContext Extension for Strategy Validation** [Source: Story 8.2, Updated for Story 8.7]

```python
from pydantic import BaseModel, Field
from typing import Any

class ValidationContext(BaseModel):
    """Context object passed to all validators"""
    pattern: Pattern = Field(..., description="Pattern being validated")
    symbol: str = Field(..., description="Trading symbol")
    timeframe: str = Field(..., description="Timeframe of pattern")

    # Strategy validation fields (Story 8.7)
    market_context: MarketContext | None = Field(
        default=None,
        description="Market conditions for strategy validation (REQUIRED for StrategyValidator)"
    )

    # Other validators' fields (used by previous stages)
    volume_analysis: VolumeAnalysis | None = Field(default=None)
    phase_info: PhaseClassification | None = Field(default=None)
    trading_range: TradingRange | None = Field(default=None)
    portfolio_context: PortfolioContext | None = Field(default=None)

    # Optional risk fields from RiskValidator (Story 8.6)
    entry_price: Decimal | None = Field(default=None)
    stop_loss: Decimal | None = Field(default=None)
    target_price: Decimal | None = Field(default=None)
    campaign_id: str | None = Field(default=None)

    config: dict[str, Any] = Field(
        default_factory=dict,
        description="Configuration overrides"
    )

    class Config:
        arbitrary_types_allowed = True
```

### API Specifications

**EarningsCalendarService Interface** [Source: Story requirements, FR29]

From `backend/src/services/earnings_calendar.py`:

```python
from decimal import Decimal
from datetime import datetime, timedelta, timezone
from typing import Dict, Tuple
import httpx
import structlog
from backend.src.models.market_context import EarningsEvent

logger = structlog.get_logger()

class EarningsCalendarService:
    """
    Earnings calendar service using Polygon.io API (FR29).

    Provides earnings announcement data with caching to minimize API calls.
    Implements 24-hour pre-earnings and 2-hour post-earnings blackout window.
    """

    def __init__(
        self,
        api_key: str,
        cache_ttl_seconds: int = 86400,  # 24 hours
        enabled: bool = True
    ):
        """
        Initialize earnings calendar service.

        Args:
            api_key: Polygon.io API key from config
            cache_ttl_seconds: Cache time-to-live (default 24 hours)
            enabled: Feature flag to disable earnings checks (default True)
        """
        self.api_key = api_key
        self.cache_ttl = cache_ttl_seconds
        self.enabled = enabled
        self.cache: Dict[str, Tuple[EarningsEvent | None, datetime]] = {}
        self.base_url = "https://api.polygon.io"

    async def get_upcoming_earnings(self, symbol: str) -> EarningsEvent | None:
        """
        Get upcoming earnings announcement for symbol.

        Checks cache first (24-hour TTL), then calls Polygon.io API if needed.

        Args:
            symbol: Trading symbol (e.g., "AAPL")

        Returns:
            EarningsEvent if earnings scheduled, None otherwise

        Raises:
            None - errors are logged and None returned (graceful degradation)
        """
        if not self.enabled:
            logger.debug("earnings_check_disabled", symbol=symbol)
            return None

        # Check cache
        if symbol in self.cache:
            cached_data, cached_at = self.cache[symbol]
            age = (datetime.now(timezone.utc) - cached_at).total_seconds()
            if age < self.cache_ttl:
                logger.debug("earnings_cache_hit", symbol=symbol, age_seconds=age)
                return cached_data

        # Cache miss or stale - fetch from API
        try:
            earnings_event = await self._fetch_from_api(symbol)
            self.cache[symbol] = (earnings_event, datetime.now(timezone.utc))
            logger.info("earnings_api_fetched", symbol=symbol, has_earnings=earnings_event is not None)
            return earnings_event
        except Exception as e:
            logger.error("earnings_api_error", symbol=symbol, error=str(e), error_type=type(e).__name__)
            # Graceful degradation: return None, don't block signal
            return None

    async def _fetch_from_api(self, symbol: str) -> EarningsEvent | None:
        """
        Fetch earnings data from Polygon.io API.

        Endpoint: GET /v2/reference/tickers/{ticker}/earnings
        (Note: Check Polygon.io docs for exact endpoint)
        """
        async with httpx.AsyncClient() as client:
            url = f"{self.base_url}/v2/reference/tickers/{symbol}/earnings"
            params = {"apiKey": self.api_key, "limit": 1}

            response = await client.get(url, params=params, timeout=5.0)
            response.raise_for_status()

            data = response.json()

            # Parse response (structure depends on Polygon.io API)
            if "results" not in data or len(data["results"]) == 0:
                return None  # No upcoming earnings

            earnings = data["results"][0]
            earnings_date = datetime.fromisoformat(earnings["earnings_date"])

            return EarningsEvent(
                symbol=symbol,
                earnings_date=earnings_date,
                fiscal_quarter=earnings.get("fiscal_quarter", "Unknown"),
                estimated_eps=Decimal(str(earnings["estimated_eps"])) if "estimated_eps" in earnings else None
            )

    async def check_blackout_window(self, symbol: str) -> bool:
        """
        Quick check if symbol is in earnings blackout window (FR29).

        Args:
            symbol: Trading symbol

        Returns:
            True if within 24hr before or 2hr after earnings, False otherwise
        """
        earnings_data = await self.get_upcoming_earnings(symbol)
        if earnings_data is None:
            return False
        return earnings_data.within_blackout_window

    def clear_cache(self, symbol: str | None = None) -> None:
        """Clear earnings cache for testing or manual refresh"""
        if symbol:
            self.cache.pop(symbol, None)
            logger.debug("earnings_cache_cleared", symbol=symbol)
        else:
            self.cache.clear()
            logger.debug("earnings_cache_cleared_all")
```

**StrategyValidator Implementation** [Source: Story requirements, BaseValidator from Story 8.2]

File location: `backend/src/signal_generator/validators/strategy_validator.py`

```python
from decimal import Decimal
from datetime import datetime, time, timezone
import structlog
from typing import List, Tuple

from backend.src.signal_generator.validators.base import BaseValidator
from backend.src.models.validation import ValidationResult, ValidationStatus, ValidationContext
from backend.src.models.market_context import MarketContext, MarketRegime, EarningsEvent, InvalidationEvent
from backend.src.models.pattern import Pattern
from backend.src.services.earnings_calendar import EarningsCalendarService

logger = structlog.get_logger()

class StrategyValidator(BaseValidator):
    """
    Final validation stage: Wyckoff strategic sanity checks (William - Mentor).

    Validates signals against strategic context that technical analysis alone cannot capture:
    - Market regime appropriateness (avoid springs in extreme volatility)
    - Earnings blackout windows (FR29 - 24hr before, 2hr after)
    - Recent invalidations (don't re-enter failed campaigns)
    - Time-based checks (avoid end-of-day entries)
    - High-conviction overrides for exceptional signals
    - Human review flagging for borderline cases

    This validator embodies "William's wisdom" - catches signals that technically
    pass but violate trading common sense and Wyckoff principles.
    """

    validator_id = "STRATEGY_VALIDATOR"
    stage_name = "Strategy"

    def __init__(self, earnings_service: EarningsCalendarService):
        """
        Initialize strategy validator.

        Args:
            earnings_service: EarningsCalendarService for FR29 compliance
        """
        self.earnings_service = earnings_service
        self.cooldown_days = 5  # Invalidation cooldown period
        self.high_conviction_threshold = 0.90  # 90% confidence for overrides

    async def validate(self, context: ValidationContext) -> ValidationResult:
        """
        Execute William's strategic validation checks.

        Args:
            context: ValidationContext with pattern and market_context

        Returns:
            ValidationResult with PASS/WARN/FAIL and William's reasoning
        """
        logger.info(
            "william_strategy_validation_started",
            pattern_id=str(context.pattern.id),
            pattern_type=context.pattern.pattern_type,
            symbol=context.symbol,
            confidence=context.pattern.confidence_score
        )

        # Step 1: Validate market_context presence
        if context.market_context is None:
            return self.create_result(
                ValidationStatus.FAIL,
                reason="Market context not available for strategy validation",
                metadata={"william_reasoning": "Cannot assess strategic suitability without market context"}
            )

        market_context = context.market_context
        pattern = context.pattern
        warnings: List[str] = []

        # Step 2: Validate market regime
        regime_passes, regime_reason, regime_status = self._validate_market_regime(
            pattern.pattern_type,
            market_context
        )
        if regime_status == ValidationStatus.FAIL:
            return self.create_result(
                ValidationStatus.FAIL,
                reason=regime_reason,
                metadata=self._build_metadata(market_context, [], False, False)
            )
        elif regime_status == ValidationStatus.WARN and regime_reason:
            warnings.append(regime_reason)

        # Step 3: Validate earnings blackout (FR29) - NON-NEGOTIABLE
        earnings_passes, earnings_reason = await self._validate_earnings_blackout(
            context.symbol,
            self.earnings_service
        )
        if not earnings_passes:
            return self.create_result(
                ValidationStatus.FAIL,
                reason=earnings_reason,
                metadata=self._build_metadata(market_context, warnings, False, False)
            )

        # Step 4: Validate recent invalidations
        invalidation_passes, invalidation_reason = self._validate_recent_invalidations(
            pattern.pattern_type,
            context.campaign_id,
            market_context.recent_invalidations
        )
        if not invalidation_passes:
            return self.create_result(
                ValidationStatus.FAIL,
                reason=invalidation_reason,
                metadata=self._build_metadata(market_context, warnings, False, False)
            )

        # Step 5: Validate time of day
        time_passes, time_reason, time_status = self._validate_time_of_day(
            market_context.time_of_day,
            market_context.market_session
        )
        if time_status == ValidationStatus.WARN and time_reason:
            warnings.append(time_reason)

        # Step 6: Check strategic overrides (high-conviction signals)
        current_status = ValidationStatus.WARN if warnings else ValidationStatus.PASS
        final_status, final_reason = self._check_override_eligibility(
            pattern.confidence_score,
            current_status,
            warnings
        )
        override_applied = (current_status == ValidationStatus.WARN and final_status == ValidationStatus.PASS)

        # Step 7: Flag for human review if borderline
        needs_review, review_reason = self._flag_for_human_review(
            warnings,
            pattern.confidence_score
        )

        # Build comprehensive metadata
        metadata = self._build_metadata(
            market_context,
            warnings,
            override_applied,
            needs_review,
            review_reason
        )

        # Log final decision
        if final_status == ValidationStatus.PASS:
            logger.info(
                "william_strategy_validation_passed",
                pattern_type=pattern.pattern_type,
                regime=market_context.market_regime.value,
                warnings_count=len(warnings),
                override_applied=override_applied,
                needs_review=needs_review,
                reasoning=metadata.get("william_reasoning", "")
            )
        else:
            logger.warning(
                "william_strategy_validation_warned",
                pattern_type=pattern.pattern_type,
                warnings=warnings,
                needs_review=needs_review,
                reasoning=metadata.get("william_reasoning", "")
            )

        return self.create_result(
            final_status,
            reason=final_reason if final_status == ValidationStatus.WARN else None,
            metadata=metadata
        )

    # ... (validation helper methods follow in next sections)
```

### File Locations

**Project Structure Reference** [Source: architecture/10-unified-project-structure.md]

Files to create:
```
backend/src/
├── models/
│   └── market_context.py                # NEW: MarketContext, EarningsEvent, InvalidationEvent models
├── services/
│   └── earnings_calendar.py             # NEW: EarningsCalendarService (Polygon.io integration)
├── signal_generator/
│   └── validators/
│       └── strategy_validator.py        # MODIFY: Replace stub with full implementation
```

Test files:
```
backend/tests/
├── unit/
│   ├── models/
│   │   └── test_market_context.py       # NEW: Test MarketContext, EarningsEvent models
│   ├── services/
│   │   └── test_earnings_calendar.py    # NEW: Test EarningsCalendarService
│   └── signal_generator/validators/
│       └── test_strategy_validator.py   # NEW: Comprehensive unit tests
└── integration/signal_generator/
    └── test_strategy_validation_integration.py  # NEW: Integration tests
```

Configuration:
```
backend/config/
└── settings.yaml                        # ADD: Earnings API configuration
```

Configuration additions:
```yaml
earnings_calendar:
  enabled: true
  api_provider: "polygon"
  api_key: "${POLYGON_API_KEY}"  # From environment variable
  cache_ttl_seconds: 86400       # 24 hours
  blackout_hours_before: 24      # FR29: 24 hours before earnings
  blackout_hours_after: 2        # FR29: 2 hours after earnings

strategy_validator:
  invalidation_cooldown_days: 5
  high_conviction_threshold: 0.90
  human_review_confidence_threshold: 0.80
```

### Validation Chain Order

**Strategy Validator is FINAL (5th) Stage** [Source: Story 8.2, FR20]

Validation chain execution order:
1. **VolumeValidator** (Story 8.3) - Verify volume requirements (cheapest check)
2. **PhaseValidator** (Story 8.4) - Verify phase alignment
3. **LevelValidator** (Story 8.5) - Verify Creek/Ice/Jump levels
4. **RiskValidator** (Story 8.6) - Verify position sizing, heat limits
5. **StrategyValidator (Story 8.7)** - Wyckoff sanity checks, earnings (FR29) ← THIS STORY

**Why Strategy Validation Last:**
- Previous validators filter out obviously bad signals (fail fast)
- Earnings API call is expensive (network I/O)
- Market context requires volatility/ADX calculations
- Only high-quality signals reach this stage (already passed 4 validators)
- Final "smell test" before signal generation

**Signal Generation Workflow** [Source: Story 8.1, architecture/8-core-workflows.md]

```
Pattern Detected (Epic 5/6)
  ↓
Build ValidationContext:
  - pattern: Pattern from detector
  - volume_analysis: VolumeAnalysis from Epic 2
  - phase_info: PhaseClassification from Story 4.4
  - trading_range: TradingRange from Epic 3
  - portfolio_context: PortfolioContext from RiskManager
  - market_context: MarketContext (NEW for Story 8.7) ← Built by orchestrator
  - entry_price, stop_loss, target_price: from LevelValidator
  - campaign_id: from Campaign tracking
  ↓
Run Validation Chain:
  1. VolumeValidator (Story 8.3)
  2. PhaseValidator (Story 8.4)
  3. LevelValidator (Story 8.5)
  4. RiskValidator (Story 8.6)
  5. StrategyValidator (Story 8.7) ← THIS STORY
  ↓
If ValidationChain.is_valid:
  Create Signal with validation_chain, William's approval metadata
Else:
  Reject pattern, log rejection_reason (e.g., "Earnings blackout FR29")
```

### Strategy Validation Rules

**Market Regime Rules** [Source: Wyckoff trading principles, story requirements]

1. **Spring in Extreme Volatility → FAIL**
   - Condition: pattern_type == "SPRING" AND volatility_percentile >= 95
   - Reasoning: High volatility creates noise, false springs common
   - Wyckoff principle: Accumulation occurs in calm markets, not chaos
   - Example: Spring during market panic (VIX spike) is unreliable

2. **SOS in Sideways Market → WARN**
   - Condition: pattern_type == "SOS" AND market_regime == SIDEWAYS AND adx < 25
   - Reasoning: Breakouts from non-trending markets have lower success rate
   - Wyckoff principle: SOS most reliable when emerging from accumulation into markup
   - Action: Allow but warn trader to monitor for follow-through

3. **UTAD in Uptrending Market → WARN**
   - Condition: pattern_type == "UTAD" AND market_regime == TRENDING_UP
   - Reasoning: Shorting uptrend is contrarian, requires strong confirmation
   - Wyckoff principle: Distribution can occur in uptrends (smart money exits)
   - Action: Allow but require strong volume confirmation

**Earnings Blackout Rules (FR29)** [Source: requirements.md#FR29]

1. **24-Hour Pre-Earnings Blackout → FAIL**
   - Condition: 0 <= hours_until_earnings <= 24
   - Reasoning: Gap risk on earnings announcement
   - Non-negotiable: Even high-conviction signals cannot override
   - Example: Signal 18 hours before earnings → REJECTED

2. **2-Hour Post-Earnings Blackout → FAIL**
   - Condition: -2 <= hours_until_earnings < 0
   - Reasoning: Initial volatility after earnings not yet settled
   - Non-negotiable: Wait for price action to stabilize
   - Example: Signal 1 hour after earnings → REJECTED

3. **No Upcoming Earnings → PASS**
   - Condition: earnings_data is None OR hours_until_earnings > 24 OR hours_until_earnings < -2
   - Action: Proceed with other validations

**Recent Invalidation Rules** [Source: Story requirements, Wyckoff invalidation principles]

1. **Same Campaign Invalidation Within 5 Days → FAIL**
   - Condition: recent_invalidation with same campaign_id AND days_ago <= 5
   - Reasoning: Failed campaign indicates structure changed, respect invalidation
   - Wyckoff principle: When Composite Operator invalidates, don't fight it
   - Cooldown: 5 days (configurable) for new structure to develop

2. **Different Campaign or Old Invalidation → PASS**
   - Condition: No matching campaign_id OR days_ago > 5
   - Action: Proceed (different trading range or sufficient cooldown)

**Time-Based Rules** [Source: Story requirements, intraday trading best practices]

1. **End-of-Day Entry (last hour) → WARN**
   - Condition: market_session == "REGULAR" AND time >= 15:00 EST
   - Reasoning: Insufficient time for pattern to develop intraday
   - Action: Allow but warn about overnight hold or next-session wait

2. **Pre-Market Entry → WARN**
   - Condition: market_session == "PRE_MARKET"
   - Reasoning: Low liquidity, gap risk at open
   - Action: Allow but warn about liquidity concerns

3. **After-Hours Entry → WARN**
   - Condition: market_session == "AFTER_HOURS"
   - Reasoning: Low liquidity may cause slippage
   - Action: Allow but warn about execution quality

**Strategic Override Rules** [Source: Story requirements AC: 4]

1. **High-Conviction Override (>= 90% confidence)**
   - Can override: WARN status → PASS
   - Cannot override: FAIL status (safety-critical)
   - Rationale: Exceptional pattern quality warrants accepting borderline conditions
   - Logged: All overrides tracked for pattern learning

2. **Low-Conviction (< 90% confidence)**
   - No override: WARN remains WARN, FAIL remains FAIL
   - Rationale: Only highest-quality signals earn override privilege

**Human Review Flagging Rules** [Source: Story requirements AC: 9]

1. **Borderline Signal Criteria:**
   - Low confidence (70-80%) with any warnings
   - Normal confidence (80-90%) with 2+ warnings
   - Any critical warning (e.g., "SOS in sideways market")

2. **Flagging Action:**
   - Set metadata["needs_human_review"] = True
   - Set metadata["review_reason"] = explanation
   - Signal placed in manual review queue (future workflow)

### Testing Requirements

**Testing Framework** [Source: architecture/12-testing-strategy.md]
- Backend testing: pytest (8.0+) with async support (pytest-asyncio)
- Unit tests: Test each validation rule independently with mocked dependencies
- Integration tests: Test full validator with realistic MarketContext
- Mock EarningsCalendarService for unit tests (control API responses)
- Use real EarningsCalendarService with mocked HTTP for integration tests
- Parametrized tests for market regime combinations

**Test Coverage Requirements:**
- Unit test market regime validation (Spring in HIGH_VOLATILITY, SOS in SIDEWAYS, etc.)
- Unit test earnings blackout (12hr, 18hr, 30hr scenarios)
- Unit test invalidation check (2 days ago, 6 days ago, different campaign)
- Unit test time-of-day (10:00 AM, 15:30, pre-market, after-hours)
- Unit test strategic override (90% confidence override WARN, 95% cannot override FAIL)
- Unit test human review flagging (low confidence + warnings)
- Integration test full validation with all checks combined
- Integration test earnings API with mocked HTTP responses
- Edge case tests (exactly at thresholds: 24.0 hours, 5.0 days, 90% confidence)

**Async Testing Pattern:**

```python
import pytest
from decimal import Decimal
from datetime import datetime, time, timedelta, timezone
from backend.src.signal_generator.validators.strategy_validator import StrategyValidator
from backend.src.models.validation import ValidationContext, ValidationStatus
from backend.src.models.market_context import MarketContext, MarketRegime, EarningsEvent

@pytest.mark.asyncio
async def test_earnings_blackout_12_hours_fails(mock_earnings_service):
    """Signal with earnings in 12 hours should be rejected (AC: 5, FR29)"""
    # Create MarketContext with earnings in 12 hours
    earnings_event = EarningsEvent(
        symbol="AAPL",
        earnings_date=datetime.now(timezone.utc) + timedelta(hours=12),
        fiscal_quarter="Q1 2024",
        estimated_eps=Decimal("1.25")
    )

    market_context = MarketContext(
        symbol="AAPL",
        current_volatility=Decimal("0.02"),
        volatility_percentile=50,
        market_regime=MarketRegime.TRENDING_UP,
        adx=Decimal("30"),
        recent_invalidations=[],
        time_of_day=time(10, 0),
        market_session="REGULAR",
        earnings_data=earnings_event
    )

    # Create ValidationContext
    context = ValidationContext(
        pattern=Pattern(pattern_type="SPRING", confidence_score=0.85, ...),
        symbol="AAPL",
        timeframe="1h",
        market_context=market_context,
        campaign_id="camp-123"
    )

    # Mock earnings service to return earnings_event
    mock_earnings_service.get_upcoming_earnings = lambda symbol: earnings_event

    # Execute validation
    validator = StrategyValidator(earnings_service=mock_earnings_service)
    result = await validator.validate(context)

    # Assert rejection
    assert result.status == ValidationStatus.FAIL
    assert "Earnings announcement" in result.reason
    assert "12.0 hours" in result.reason
    assert "FR29" in result.reason
    assert result.metadata["earnings_check_passed"] == False
    assert result.metadata["earnings_hours_until"] == 12.0
```

### Technical Constraints

**Async/Await Required** [Source: architecture/3-tech-stack.md]
- All validator methods must be `async def`
- StrategyValidator.validate() is async
- EarningsCalendarService API calls are async (httpx.AsyncClient)
- Compatible with validation chain orchestration

**Pydantic Model Validation** [Source: architecture/3-tech-stack.md]
- Use Pydantic computed_field for derived properties
- Use field validators for cross-field validation
- Ensure datetime fields are UTC-aware (prevents timezone bugs)
- JSON encoders for Decimal, datetime, time, UUID types

**Decimal Precision** [Source: architecture/15-coding-standards.md]
- Use Decimal type for all volatility calculations (current_volatility, adx)
- Serialize Decimal as string in JSON
- No floating point arithmetic in validation logic

**Error Handling** [Source: architecture/16-error-handling-strategy.md]
- StrategyValidator should NOT raise exceptions (return FAIL ValidationResult)
- EarningsCalendarService should catch API errors and return None (graceful degradation)
- Log all exceptions with structlog for debugging
- Never block signal generation on external API failure (prefer false negative)

**Performance Constraints** [Source: NFR1]
- Strategy validation budget: <500ms per signal (includes earnings API call)
- Earnings API cache prevents repeated calls for same symbol
- Timeout on earnings API: 5 seconds max
- Market context pre-calculated by orchestrator (not computed during validation)

### Logging and Observability

**Structured Logging - William's Reasoning** [Source: architecture/3-tech-stack.md - structlog 24.1+]

Log all strategy validation events with "William's voice":

```python
import structlog
logger = structlog.get_logger()

# Validation start
logger.info("william_strategy_validation_started",
            pattern_id=str(context.pattern.id),
            pattern_type=context.pattern.pattern_type,
            symbol=context.symbol,
            confidence=context.pattern.confidence_score)

# Market regime check
logger.debug("william_market_regime_check",
             regime=market_context.market_regime.value,
             volatility_pct=market_context.volatility_percentile,
             adx=float(market_context.adx) if market_context.adx else None,
             is_extreme=market_context.is_extreme_volatility,
             assessment="William: Spring in extreme volatility - high noise risk")

# Earnings check
logger.info("william_earnings_check",
            symbol=symbol,
            has_upcoming_earnings=earnings_data is not None,
            hours_until=earnings_data.hours_until_event if earnings_data else None,
            blackout_active=earnings_data.within_blackout_window if earnings_data else False,
            reasoning="William: Earnings in 12 hours violates FR29 blackout - respect gap risk")

# Invalidation check
logger.debug("william_invalidation_check",
             campaign_id=campaign_id,
             recent_invalidations=len(market_context.recent_invalidations),
             cooldown_active=invalidation_found,
             reasoning="William: Recent stop-out 3 days ago - respect the invalidation")

# Time check
logger.debug("william_time_check",
             time=market_context.time_of_day.strftime("%H:%M"),
             session=market_context.market_session,
             end_of_day_warning=is_end_of_day,
             reasoning="William: Entry at 15:30 leaves little time for development")

# Override decision
logger.warning("william_high_conviction_override",
               pattern_confidence=context.pattern.confidence_score,
               original_warning=original_reason,
               override_applied=True,
               reasoning="William: 92% confidence warrants accepting sideways market risk")

# Human review flag
logger.info("william_human_review_flagged",
            confidence=context.pattern.confidence_score,
            warning_count=len(warnings),
            flag_reason=review_reason,
            reasoning="William recommends manual review: borderline setup with multiple concerns")

# Validation passed
logger.info("william_strategy_validation_passed",
            pattern_type=context.pattern.pattern_type,
            regime=market_context.market_regime.value,
            warnings_count=len(warnings),
            override_applied=override_applied,
            needs_review=needs_review,
            reasoning="William approves: Clean setup in trending market, no adverse conditions")

# Validation failed
logger.warning("william_strategy_validation_failed",
               reason=reason,
               failed_check=failed_check,
               reasoning="William rejects: Earnings blackout window active - wait until after announcement")
```

**Correlation IDs** [Source: architecture/17-monitoring-and-observability.md]
- Use pattern_id as correlation ID to trace through validation
- Enables log queries: "Show William's strategic assessment for pattern XYZ"
- Pattern ID flows through: Detection → Validation → Signal/Rejection
- Campaign ID enables tracking: "Show all invalidations for campaign ABC"

**Metrics to Track** (for future monitoring):
- Earnings blackout rejection rate (% signals blocked by FR29)
- Market regime warning rate (% signals in suboptimal regimes)
- Strategic override frequency (% high-conviction overrides)
- Human review flag rate (% signals flagged for manual review)
- Invalidation cooldown hit rate (% re-entries blocked)

### Strategy Validation Examples

**Valid Strategic Scenario (PASS):**

| Check | Value | Status | William's Reasoning |
|-------|-------|--------|---------------------|
| Market Regime | TRENDING_UP | ✅ PASS | "Spring emerging from accumulation into uptrend - ideal Wyckoff setup" |
| Volatility | 60th percentile | ✅ PASS | "Normal volatility - calm market supports genuine accumulation" |
| Earnings | None scheduled | ✅ PASS | "No binary events pending - pure price action analysis applicable" |
| Invalidations | None recent | ✅ PASS | "No failed campaigns - clean slate for new position" |
| Time | 10:30 AM REGULAR | ✅ PASS | "Mid-morning entry - ample time for pattern development" |
| **Final Status** | **PASS** | ✅ | "William approves: Textbook Wyckoff setup with optimal conditions" |

**Invalid Strategic Scenarios (FAIL/WARN):**

| Scenario | Failed Check | Status | William's Reasoning |
|----------|--------------|--------|---------------------|
| Earnings in 12 hours | Earnings blackout (FR29) | ❌ FAIL | "Earnings in 12.0 hours violates 24-hour blackout (FR29). Gap risk is antithetical to Wyckoff analysis - wait until after earnings." |
| Spring in volatility spike | Market regime | ❌ FAIL | "Spring in extreme volatility (ATR 98th percentile) - chaos creates false signals. Wyckoff teaches accumulation occurs in calm, not panic." |
| Stop-out 2 days ago | Recent invalidation | ❌ FAIL | "Recent invalidation 2.0 days ago (Spring low broken). Composite Operator has shown their hand - respect it, don't re-enter failed structure." |
| SOS in sideways ADX 18 | Market regime | ⚠️ WARN | "SOS breakout in sideways market (ADX 18 < 25) - lower probability without established trend. Monitor for follow-through volume." |
| Entry at 15:30 | Time-based | ⚠️ WARN | "Entry at 15:30 leaves 30 minutes to close - insufficient time for intraday development. Consider overnight hold or wait for next session." |
| High-conviction override | Strategic override | ✅ PASS | "Original warning: SOS in sideways market. HIGH-CONVICTION OVERRIDE (confidence 92%) - exceptional pattern quality warrants accepting risk." |

### Integration Notes

**Dependency on Previous Validators** [Source: Story 8.2, 8.3-8.6]

StrategyValidator assumes previous validators have passed:
- **VolumeValidator** (Story 8.3): Volume requirements verified (Spring < 0.7x, SOS > 1.5x)
- **PhaseValidator** (Story 8.4): Phase alignment confirmed (Spring in Phase C, SOS in Phase D)
- **LevelValidator** (Story 8.5): Creek/Ice/Jump levels validated (strength >= 60, ordering correct)
- **RiskValidator** (Story 8.6): Position sizing, heat limits verified (portfolio heat < 10%, R-multiple meets minimums)

If StrategyValidator receives context, it's a high-quality signal that passed all technical checks.
StrategyValidator's job: Ensure strategic context doesn't violate Wyckoff wisdom.

**Market Context Assembly** [Source: Story 8.1 Master Orchestrator]

MasterOrchestrator builds MarketContext before validation chain:
```python
# Pseudo-code from Story 8.1 orchestrator
market_context = MarketContext(
    symbol=symbol,
    current_volatility=volume_analyzer.calculate_atr_percent(),
    volatility_percentile=volume_analyzer.get_atr_percentile(),
    market_regime=regime_classifier.classify_regime(bars, adx),
    adx=adx_indicator.calculate(bars),
    recent_invalidations=campaign_tracker.get_recent_invalidations(symbol),
    time_of_day=datetime.now(market_tz).time(),
    market_session=session_classifier.get_session(datetime.now(market_tz)),
    earnings_data=None  # Will be fetched by StrategyValidator
)

validation_context = ValidationContext(
    pattern=detected_pattern,
    symbol=symbol,
    market_context=market_context,  # ← Built by orchestrator
    # ... other fields
)
```

**Earnings API Integration Pattern** [Source: Story requirements, FR29]

```python
# In MasterOrchestrator or StrategyValidator
earnings_service = EarningsCalendarService(
    api_key=config["earnings_calendar"]["api_key"],
    cache_ttl_seconds=config["earnings_calendar"]["cache_ttl_seconds"],
    enabled=config["earnings_calendar"]["enabled"]
)

strategy_validator = StrategyValidator(earnings_service=earnings_service)
```

### Dependencies

**Python Libraries** [Source: architecture/3-tech-stack.md]
- Python 3.11+ (datetime, Decimal, time from standard library)
- FastAPI 0.109+ (async web framework)
- Pydantic 2.5+ (data validation, computed fields, field validators)
- httpx (async HTTP client for Polygon.io API)
- pytest 8.0+ (testing)
- pytest-asyncio (async test support)
- pytest-httpx (mock HTTP responses for testing)
- structlog 24.1+ (structured logging)

**External APIs**
- **Polygon.io** (earnings calendar API for FR29)
  - Endpoint: `GET /v2/reference/tickers/{ticker}/earnings`
  - Authentication: API key in query params
  - Rate limits: Respect API tier limits (cache to minimize calls)
  - Pricing: Check Polygon.io pricing for earnings data access

**Internal Dependencies**
- Story 8.2: BaseValidator, ValidationResult, ValidationContext, ValidationStatus
- Story 8.6: campaign_id field from RiskValidator context
- Epic 2: Volume analysis (ATR calculations for volatility_percentile)
- Epic 4: Phase detection (ADX calculations for trend strength)
- Epic 7: Campaign tracking (recent_invalidations from campaign manager)
- Pattern model (from Epic 5/6): pattern_type, confidence_score fields

**Related Stories**
- **Story 8.2 (Multi-Stage Validation Workflow)** - Created validation framework
- **Story 8.1 (Master Orchestrator)** - Builds MarketContext, assembles ValidationContext
- **Story 8.3 (Volume Validation)** - First validator (must pass before strategy check)
- **Story 8.4 (Phase Validation)** - Second validator (phase alignment verified)
- **Story 8.5 (Level Validation)** - Third validator (structural integrity confirmed)
- **Story 8.6 (Risk Validation)** - Fourth validator (risk limits satisfied) - **FUTURE**: Add forex correlation risk validation (Rachel enhancement)
- **Story 8.8 (Signal Output Format)** - Signal includes validation_chain with William's reasoning
- **Epic 7 (Risk Management)** - Provides campaign tracking, invalidation events

**Forex Correlation Risk Note (Rachel Enhancement)**

Forex currency pairs share underlying currencies, creating correlation risk not addressed in Story 8.7:
- Example: EUR/USD long + GBP/USD long = 2x USD short exposure
- If USD strengthens, both positions fail simultaneously
- Wyckoff principle: If USD in distribution (cause), all USD pairs experience effect (Law of Cause & Effect)

**Recommendation**: This should be validated in **Story 8.6 (RiskValidator)** portfolio heat calculation, not StrategyValidator:
- Add `_calculate_currency_exposure()` to track net long/short exposure per currency
- Add `_validate_forex_correlation_risk()` to enforce max exposure per currency (e.g., 1.5 lots max USD exposure)
- Rejection reason: "USD exposure concentrated at -2.0 lots (limit 1.5). Diversify across currencies to avoid single-currency Composite Operator risk."

**Action**: Document as future Story 8.6 enhancement (outside scope of Story 8.7).

### Risk Mitigation Notes

**Why Strategy Validation Matters** [Source: Epic 8 PRD, Wyckoff principles]

Without strategic validation:
- Earnings gap risk: Position opened before announcement, gaps down 10% overnight
- Extreme volatility: Spring in panic market is noise, not accumulation
- Re-entry trap: Entering failed campaign immediately after stop-out (Composite Operator still selling)
- Poor timing: End-of-day entry leaves no time for pattern to develop
- Low-quality signals: Borderline setups slip through without human review

**Common Strategic Validation Failures:**

1. **Earnings Blackout (FR29) - Most Critical:**
   - Scenario: Signal 18 hours before Apple earnings
   - Risk: Stock gaps 8% on earnings miss, stop-out at open
   - Impact: Single earnings gap can wipe out multiple R wins
   - Solution: Reject signal, wait until 2 hours after earnings

2. **Extreme Volatility - High False Signal Rate:**
   - Scenario: Spring during market-wide VIX spike (ATR 98th percentile)
   - Risk: High volatility creates noise patterns, not genuine accumulation
   - Impact: False spring leads to immediate stop-out when volatility normalizes
   - Solution: Reject Spring in extreme volatility, wait for calm market

3. **Recent Invalidation - Respect the Composite Operator:**
   - Scenario: Re-enter campaign 2 days after spring low broken
   - Risk: Same smart money (Composite Operator) still distributing
   - Impact: Second stop-out in same range (double loss)
   - Solution: 5-day cooldown before re-entry, ensure new structure

4. **SOS in Sideways Market - Lower Probability:**
   - Scenario: SOS breakout with ADX 18 (no trend)
   - Risk: Breakout fades back into range (false breakout)
   - Impact: Stopped out when price returns to range
   - Solution: WARN (not FAIL), allow but notify trader to monitor

5. **End-of-Day Entry - Timing Risk:**
   - Scenario: Signal at 15:30, 30 minutes before close
   - Risk: Insufficient time for pattern to develop intraday
   - Impact: Forced overnight hold or miss entry entirely next day
   - Solution: WARN, let trader decide if comfortable with overnight risk

**Audit Trail Importance:**

Complete strategy validation metadata enables:
- "Why was this signal rejected?" → Check validation_chain: "Earnings blackout FR29"
- "Are we following Wyckoff principles?" → Review William's reasoning in all validations
- "Which strategic checks fail most often?" → Query rejection_stage stats
- Pattern learning: Analyze which market regimes produce best signals
- Backtesting: Replay strategic validation to optimize thresholds (cooldown days, volatility percentile)

**Strategic Override Philosophy:**

High-conviction signals (>= 90% confidence) can override WARN but NOT FAIL:
- **Override WARN**: Exceptional pattern quality warrants accepting borderline conditions
  - Example: 92% confidence SOS in sideways market → Override to PASS
- **Cannot Override FAIL**: Safety-critical failures are non-negotiable
  - Example: 95% confidence Spring with earnings in 12 hours → Still FAIL (FR29)
  - Rationale: No pattern quality justifies earnings gap risk

**Human Review Flagging Benefits:**

Flagging borderline signals for manual review:
- Quality control: Experienced trader reviews low-confidence setups
- Pattern learning: Human feedback improves future detection algorithms
- Risk management: Prevents marginal signals from executing automatically
- Compliance: Demonstrates human oversight in automated system

### Testing Strategy

**Unit Testing Approach:**
- Mock EarningsCalendarService to control earnings data
- Parametrized tests for market regime combinations
- Test each validation rule in isolation
- Test strategic override logic with various confidence levels
- Test human review flagging criteria

**Integration Testing Approach:**
- Use mocked HTTP responses for Polygon.io API
- Test full StrategyValidator with realistic MarketContext
- Test earnings cache behavior (hit/miss/stale)
- Test graceful degradation on API failure
- Test validation chain integration (StrategyValidator as 5th stage)

**Edge Case Testing:**
- Exactly at thresholds: 24.0 hours, 90% confidence, 5.0 days, ADX 25
- Multiple simultaneous warnings
- API timeout scenarios
- Missing optional fields (adx = None)
- Empty recent_invalidations list

## Wyckoff Team Review Summary

Story 8.7 was reviewed by the Wyckoff specialist team (Victoria - Volume Specialist, Rachel - Risk/Position Manager, William - Mentor) to ensure validation criteria maintain Wyckoff integrity across both stocks and forex markets.

### Approved Enhancements

**1. Volume Volatility Check (Victoria)**
- **Issue**: Original used ATR (price range) only, missing volume context
- **Enhancement**: Added `volume_percentile` to MarketContext; `is_extreme_volatility` now checks BOTH ATR >= threshold AND volume_percentile >= 85
- **Wyckoff Principle**: High ATR + low volume may be stopping volume (valid); high ATR + high volume = chaos (reject)
- **Location**: [MarketContext.is_extreme_volatility](#L91-L117)

**2. Event-Specific Forex Blackout Windows (Rachel)**
- **Issue**: One-size-fits-all 4hr/1hr blackout for all forex events
- **Enhancement**: Event-specific windows based on volatility impact:
  - NFP: 6hr before / 2hr after (highest volatility, 100-150 pip moves)
  - FOMC: 4hr before / 2hr after (policy surprises)
  - CPI/GDP: 2hr before / 1hr after (lower volatility than NFP)
- **Wyckoff Principle**: Risk proportional to event impact (controlled-risk principle)
- **Location**: [ForexNewsCalendarService HIGH_IMPACT_EVENTS](#L162-L172)

**3. Asset-Class-Aware Invalidation Cooldown (Rachel)**
- **Issue**: 5-day cooldown treats stocks and forex equally
- **Enhancement**: Stocks 5 days, Forex 3 days (24/5 market develops structure faster)
- **Rationale**: 3 forex days ≈ 5 stock days in volume/structure development
- **Wyckoff Principle**: Respect invalidations, but account for market rhythm differences
- **Location**: [_validate_recent_invalidations](#L309-L333)

**4. Asian Session Spread Widening Warning (Victoria/Rachel)**
- **Issue**: Asian session liquidity warning didn't mention spread impact
- **Enhancement**: Explicit warning about 2-3x spread widening affecting stop placement
- **Wyckoff Principle**: Structural stops may be breached by spread alone, not genuine supply
- **Location**: [_validate_time_of_day ASIAN session](#L362-L364)

**5. Wednesday Rollover Cost Warning (Rachel)**
- **Issue**: Forex triple swap charges not mentioned
- **Enhancement**: WARN status for Wednesday PM forex entries (3x rollover overnight)
- **Wyckoff Principle**: Total cost analysis includes carrying costs (0.1-0.3% material for tight setups)
- **Location**: [_validate_time_of_day Wednesday](#L367-L369)

**6. Forex Correlation Risk Documentation (Rachel)**
- **Issue**: Currency pair correlation risk not addressed
- **Enhancement**: Documented as future Story 8.6 (RiskValidator) enhancement
- **Note**: Out of scope for Story 8.7 (StrategyValidator validates individual signals, not portfolio correlation)
- **Location**: [Forex Correlation Risk Note](#L1880-L1892)

### Team Sign-Offs

**Victoria (Volume Specialist)**: ✅ APPROVED
> "The strategy validation criteria maintain Wyckoff integrity across both stocks and forex. The volume volatility enhancement ensures we distinguish chaos from stopping volume. UTAD failure bar validation is textbook Effort vs Result Law."

**Rachel (Risk/Position Manager)**: ✅ APPROVED with enhancements applied
> "Story 8.7 strongly aligns with Wyckoff controlled-risk principles. Weekend gap rejection, event-specific blackouts, and asset-aware cooldowns are sound risk management. Forex-specific enhancements now address market-specific risks appropriately."

**William (Mentor)**: ✅ APPROVED
> "With the team's enhancements applied, Story 8.7 provides excellent strategic validation for both asset classes. The criteria respect Wyckoff principles while adapting intelligently to market structure differences between stocks and forex."

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation for Epic 8.7 - Strategy Validation Stage (William) | Bob (Scrum Master) |
| 2025-12-02 | 1.1 | Wyckoff team review enhancements applied (Victoria/Rachel/William): Volume volatility check, event-specific forex blackouts (NFP 6hr/2hr), asset-aware invalidation cooldown (stocks 5d, forex 3d), Asian session spread warning, Wednesday rollover warning, correlation risk documentation | William (Mentor) + Team |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results
_To be filled by QA Agent_
