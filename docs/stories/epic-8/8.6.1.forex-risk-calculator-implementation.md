# Story 8.6.1: Forex Risk Calculator Implementation

**Epic:** 8 - Master Orchestrator & Multi-Stage Validation Pipeline
**Story:** 8.6.1 - Forex Risk Calculator Implementation (Extension of 8.6)
**Status:** Draft
**Owner:** Rachel (Risk/Position Manager) + Dev Team
**Created:** 2025-12-01
**Dependencies:** Story 8.6 (Risk Validation Stage)

---

## Story Overview

Implement forex-specific risk calculator to handle lot-based position sizing, pip value calculations, leverage tracking, and session-based adjustments. This extends Story 8.6 (Risk Validation Stage) with asset-class-aware risk calculations.

**Rachel's Assessment:** "Forex risk management is fundamentally different from stocks. A 50:1 leveraged position can hit your daily loss limit in MINUTES during volatile sessions. We need stricter risk limits, lot-based sizing, pip value calculations, and weekend gap protection. This is about preserving capital in a market that never sleeps."

---

## Business Context

### Why This Story Exists

Stock risk calculations assume:
- Position sizing in integer shares
- 1:1 leverage (you pay full price)
- No weekend gap risk (markets closed)
- Fixed market hours (9:30am-4pm ET)

**None of these assumptions hold for forex:**
- Fractional lots (0.01 = 1 micro lot)
- 50:1+ leverage (2% account risk = 100% notional exposure)
- Weekend gap risk (markets close Fri 5pm → Sun 5pm)
- 24-hour trading across sessions with different liquidity

**Without forex-specific risk calculations:**
- ❌ Position sizing will be wrong (trying to buy "100 shares" of EUR/USD)
- ❌ Risk per trade will be miscalculated (ignoring leverage amplification)
- ❌ Notional exposure will exceed safe limits (3x equity trap)
- ❌ Friday entries will expose portfolio to uncontrolled weekend gaps

---

## Wyckoff Methodology Validation

**William (Wyckoff Mentor) Sign-Off:**

✅ **Controlled Risk Principle:** Forex leverage amplifies losses. Stricter limits (1.5% per trade vs 2%) align with Wyckoff's emphasis on "never risk more than you can afford to lose."

✅ **Friday Weekend Adjustment:** Reducing position size by 50% for Friday entries after 8am EST honors the principle of "avoid uncontrolled conditions." Weekend gaps violate the core requirement of being able to exit when price moves against you.

✅ **Session-Based Sizing:** Asian session has lower liquidity (70% size adjustment) vs London/NY (100%). This reflects Wyckoff's "Effort vs Result" law—thinner volume means wider spreads and slippage risk.

✅ **Leverage Awareness:** Tracking notional value and margin requirements makes the TRUE risk visible. A 50:1 leveraged position that looks like "2% risk" is actually 100% notional exposure.

**Verdict:** These adjustments are ESSENTIAL for applying Wyckoff principles to forex markets. Without them, traders would violate the controlled-risk principle by unknowingly taking on excessive leverage.

---

## Acceptance Criteria

### AC1: ForexRiskCalculator Class Creation
**GIVEN** a forex symbol (e.g., "EUR/USD")
**WHEN** the risk calculator is instantiated
**THEN** it should:
- Detect forex asset class (symbol contains "/")
- Load currency-pair-specific pip values
- Support standard/mini/micro lot calculations
- Track leverage and margin requirements

### AC2: Lot-Based Position Sizing
**GIVEN** a risk amount ($100) and stop distance (50 pips)
**WHEN** `calculate_position_size()` is called
**THEN** it should:
- Calculate lot size (not shares): `risk_amount / (stop_pips * pip_value)`
- Return position size in lots (Decimal, e.g., 0.15 lots)
- Set position_size_unit = "LOTS"
- Calculate notional value: `lot_size * 100000 * current_price`

**Example:**
```python
# Risk $100, stop at 50 pips, EUR/USD @ 1.1000, pip value = $10
# Position size = $100 / (50 * $10) = 0.20 lots (2 mini lots)
# Notional value = 0.20 * 100000 * 1.1000 = $22,000
```

### AC3: Pip Value Calculations (Currency-Pair-Specific)
**GIVEN** different forex pairs
**WHEN** calculating pip values
**THEN** it should use correct formulas:

**For XXX/USD pairs (EUR/USD, GBP/USD):**
```python
pip_value = (0.0001 / current_price) * lot_size * 100000
# EUR/USD @ 1.1000, 1 standard lot:
# pip_value = (0.0001 / 1.1000) * 1.0 * 100000 = $9.09 per pip
```

**For USD/XXX pairs (USD/JPY, USD/CHF):**
```python
pip_value = 0.0001 * lot_size * 100000
# USD/JPY @ 110.00, 1 standard lot:
# pip_value = 0.0001 * 1.0 * 100000 = $10.00 per pip (JPY uses 0.01 pip)
```

**For XXX/YYY pairs (EUR/GBP, GBP/JPY):**
```python
pip_value = (0.0001 / current_price) * lot_size * 100000 * conversion_rate
# Requires YYY/USD conversion rate
```

### AC4: Session-Based Position Size Adjustments
**GIVEN** a calculated position size
**WHEN** validating against current forex session
**THEN** apply session multipliers:

| Session | Hours (UTC) | Liquidity | Multiplier |
|---------|-------------|-----------|------------|
| ASIAN   | 00:00-08:00 | Low       | 0.70       |
| LONDON  | 08:00-17:00 | High      | 1.00       |
| NY      | 13:00-22:00 | High      | 1.00       |
| OVERLAP | 13:00-17:00 | Highest   | 1.00       |

**Example:**
```python
# Base position size: 0.20 lots
# Asian session detected (low liquidity)
adjusted_size = 0.20 * 0.70 = 0.14 lots  # Reduced by 30%
```

### AC5: Friday Weekend Gap Adjustment
**GIVEN** a signal generated on Friday
**WHEN** calculating position size
**THEN** apply time-based multipliers:

| Time (UTC) | Time (EST) | Multiplier | Reason |
|------------|-----------|------------|--------|
| Before 13:00 | Before 8am | 1.00 | Full week ahead |
| 13:00-17:00 | 8am-12pm | 0.50 | Weekend gap risk |
| After 17:00 | After 12pm | 0.00 | FAIL validation (Story 8.7) |

**Example:**
```python
# Friday 10:00am EST (15:00 UTC)
# Base position size: 0.20 lots
adjusted_size = 0.20 * 0.50 = 0.10 lots  # Cut in half
reason = "Friday entry: reduced to 50% due to weekend gap risk"
```

### AC6: Notional Exposure Limit Validation
**GIVEN** open forex positions
**WHEN** calculating total notional exposure
**THEN** enforce 3x equity limit:

```python
total_forex_notional = sum(
    position.notional_value
    for position in open_positions
    if position.asset_class == "FOREX"
)

max_allowed_notional = portfolio_equity * 3.0

if total_forex_notional >= max_allowed_notional:
    return ValidationResult(
        status="FAIL",
        reason=f"Forex notional exposure ${total_forex_notional:,.0f} "
               f"exceeds 3x equity limit ${max_allowed_notional:,.0f}. "
               f"This violates controlled-risk principle."
    )
```

### AC7: Margin Requirement Calculation
**GIVEN** a position size in lots and leverage
**WHEN** `calculate_margin_requirement()` is called
**THEN** return required margin:

```python
notional_value = lot_size * 100000 * current_price
margin_required = notional_value / leverage

# Example: 0.20 lots EUR/USD @ 1.1000, 50:1 leverage
# Notional = 0.20 * 100000 * 1.1000 = $22,000
# Margin = $22,000 / 50 = $440
```

**Validation:**
```python
if margin_required > (portfolio_equity * 0.10):
    # Single position requires >10% of equity as margin
    return ValidationResult(
        status="FAIL",
        reason=f"Margin requirement ${margin_required:,.0f} exceeds 10% of equity"
    )
```

### AC8: Stricter Risk Limits for Forex
**GIVEN** a forex signal
**WHEN** validating risk parameters
**THEN** enforce forex-specific limits:

| Parameter | Stock Limit | Forex Limit | Reason |
|-----------|-------------|-------------|--------|
| Risk per trade | 2.0% | 1.5% | Leverage amplifies speed of loss |
| Daily loss limit | 3.0% | 2.0% | Faster market, more volatility |
| Max drawdown | 15.0% | 15.0% | Universal (already strict) |
| Notional exposure | N/A | 3x equity | Prevent over-leveraging trap |
| Margin per position | N/A | 10% equity | Prevent margin calls |

### AC9: Lot Type Support (Standard/Mini/Micro)
**GIVEN** different broker lot types
**WHEN** calculating position sizes
**THEN** support all three types:

| Lot Type | Units | Example |
|----------|-------|---------|
| Standard | 100,000 | 1.00 lot = 100,000 EUR |
| Mini     | 10,000  | 0.10 lot = 10,000 EUR |
| Micro    | 1,000   | 0.01 lot = 1,000 EUR |

**Position size should be quantized to broker minimums:**
```python
# Broker supports mini lots (0.10 minimum)
calculated_size = 0.17 lots
quantized_size = round_down_to_nearest(0.17, 0.10) = 0.10 lots

# Broker supports micro lots (0.01 minimum)
calculated_size = 0.17 lots
quantized_size = round_down_to_nearest(0.17, 0.01) = 0.17 lots
```

### AC10: Integration with Story 8.6 (Risk Validation Stage)
**GIVEN** the RiskValidationStage from Story 8.6
**WHEN** a forex signal is validated
**THEN** it should:
- Detect asset_class == "FOREX"
- Instantiate ForexRiskCalculator instead of StockRiskCalculator
- Pass forex-specific parameters (leverage, session, day-of-week)
- Return position size in LOTS with notional_value and margin_requirement

### AC11: Comprehensive Error Handling
**GIVEN** various edge cases
**WHEN** calculating forex risk
**THEN** handle errors gracefully:

```python
# Unknown currency pair
if currency_pair not in SUPPORTED_PAIRS:
    raise ValueError(f"Unsupported currency pair: {currency_pair}")

# Invalid lot size
if lot_size <= 0:
    raise ValueError(f"Lot size must be positive: {lot_size}")

# Insufficient margin
if available_margin < margin_required:
    return ValidationResult(
        status="FAIL",
        reason=f"Insufficient margin: ${available_margin:,.0f} available, "
               f"${margin_required:,.0f} required"
    )

# Extreme leverage
if leverage > 100:
    logger.warning(f"Extreme leverage detected: {leverage}:1. "
                   f"Risk of margin call is HIGH.")
```

---

## Technical Implementation

### File Structure

```
backend/src/risk_management/
├── risk_calculator.py              # Abstract base class (exists)
├── stock_risk_calculator.py        # Stock implementation (exists)
├── forex_risk_calculator.py        # NEW - Forex implementation
└── risk_calculator_factory.py      # NEW - Factory pattern

backend/config/
└── forex_pairs.yaml                # NEW - Currency pair configurations

backend/tests/unit/risk_management/
└── test_forex_risk_calculator.py   # NEW - Unit tests

backend/tests/integration/risk_management/
└── test_forex_risk_integration.py  # NEW - Integration tests
```

### Class Design

```python
# backend/src/risk_management/forex_risk_calculator.py

from decimal import Decimal
from datetime import datetime
from enum import Enum
from dataclasses import dataclass
from typing import Literal

from .risk_calculator import RiskCalculator, PositionSizeResult
from ..models.forex_session import ForexSession


class LotType(str, Enum):
    STANDARD = "STANDARD"  # 100,000 units
    MINI = "MINI"          # 10,000 units
    MICRO = "MICRO"        # 1,000 units


@dataclass
class ForexPairConfig:
    """Configuration for a specific currency pair."""
    symbol: str
    pip_size: Decimal  # 0.0001 for most, 0.01 for JPY pairs
    base_currency: str  # e.g., "EUR" in EUR/USD
    quote_currency: str  # e.g., "USD" in EUR/USD
    min_lot_size: Decimal  # Broker minimum (e.g., 0.01 for micro)
    lot_type: LotType

    @property
    def is_xxx_usd(self) -> bool:
        """True if quote currency is USD (e.g., EUR/USD)."""
        return self.quote_currency == "USD"

    @property
    def is_usd_xxx(self) -> bool:
        """True if base currency is USD (e.g., USD/JPY)."""
        return self.base_currency == "USD"


class ForexRiskCalculator(RiskCalculator):
    """
    Forex-specific risk calculator with lot-based sizing, leverage tracking,
    and session-based adjustments.

    Usage:
        calculator = ForexRiskCalculator(
            symbol="EUR/USD",
            leverage=Decimal("50.0"),
            lot_type=LotType.MINI
        )

        result = calculator.calculate_position_size(
            risk_amount=Decimal("100.0"),
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),
            portfolio_equity=Decimal("10000.0"),
            forex_session=ForexSession.LONDON,
            current_time=datetime.now()
        )

        print(f"Position size: {result.position_size} lots")
        print(f"Notional value: ${result.notional_value:,.0f}")
        print(f"Margin required: ${result.margin_requirement:,.0f}")
    """

    # Risk limits (stricter than stocks)
    MAX_RISK_PER_TRADE = Decimal("0.015")  # 1.5%
    DAILY_LOSS_LIMIT = Decimal("0.02")     # 2.0%
    MAX_NOTIONAL_MULTIPLIER = Decimal("3.0")  # 3x equity
    MAX_MARGIN_PER_POSITION = Decimal("0.10")  # 10% equity

    # Session multipliers (liquidity-based)
    SESSION_MULTIPLIERS = {
        ForexSession.ASIAN: Decimal("0.70"),    # Low liquidity
        ForexSession.LONDON: Decimal("1.00"),   # High liquidity
        ForexSession.NY: Decimal("1.00"),       # High liquidity
        ForexSession.OVERLAP: Decimal("1.00"),  # Highest liquidity
    }

    def __init__(
        self,
        symbol: str,
        leverage: Decimal,
        lot_type: LotType = LotType.MINI,
        pair_config: ForexPairConfig | None = None
    ):
        self.symbol = symbol
        self.leverage = leverage
        self.lot_type = lot_type
        self.pair_config = pair_config or self._load_pair_config(symbol)

    def calculate_position_size(
        self,
        risk_amount: Decimal,
        entry_price: Decimal,
        stop_price: Decimal,
        portfolio_equity: Decimal,
        forex_session: ForexSession,
        current_time: datetime | None = None
    ) -> PositionSizeResult:
        """
        Calculate position size in lots with forex-specific adjustments.

        Steps:
        1. Calculate stop distance in pips
        2. Calculate pip value for this pair
        3. Calculate base lot size: risk_amount / (stop_pips * pip_value)
        4. Apply session multiplier (Asian 70%, others 100%)
        5. Apply Friday weekend adjustment if applicable
        6. Quantize to broker minimum lot size
        7. Calculate notional value and margin requirement
        8. Validate against risk limits

        Returns:
            PositionSizeResult with:
            - position_size: Decimal (in lots)
            - position_size_unit: "LOTS"
            - notional_value: Decimal
            - margin_requirement: Decimal
            - leverage: Decimal
            - adjustments: list[str] (reasons for adjustments)
        """
        # Step 1: Calculate stop distance in pips
        stop_distance_pips = self._calculate_stop_pips(entry_price, stop_price)

        # Step 2: Calculate pip value
        pip_value = self._calculate_pip_value(entry_price)

        # Step 3: Calculate base lot size
        base_lot_size = risk_amount / (stop_distance_pips * pip_value)

        # Step 4: Apply session multiplier
        session_multiplier = self.SESSION_MULTIPLIERS[forex_session]
        adjusted_lot_size = base_lot_size * session_multiplier
        adjustments = []
        if session_multiplier < Decimal("1.0"):
            adjustments.append(
                f"{forex_session.value} session: reduced to "
                f"{session_multiplier*100:.0f}% due to lower liquidity"
            )

        # Step 5: Apply Friday weekend adjustment
        if current_time:
            friday_multiplier = self._get_friday_multiplier(current_time)
            if friday_multiplier < Decimal("1.0"):
                adjusted_lot_size *= friday_multiplier
                adjustments.append(
                    f"Friday entry: reduced to {friday_multiplier*100:.0f}% "
                    f"due to weekend gap risk"
                )

        # Step 6: Quantize to broker minimum
        final_lot_size = self._quantize_lot_size(adjusted_lot_size)
        if final_lot_size != adjusted_lot_size:
            adjustments.append(
                f"Quantized to broker minimum: {self.pair_config.min_lot_size} lots"
            )

        # Step 7: Calculate notional value and margin
        notional_value = self._calculate_notional_value(
            final_lot_size, entry_price
        )
        margin_requirement = notional_value / self.leverage

        # Step 8: Validate risk limits
        self._validate_risk_limits(
            final_lot_size,
            notional_value,
            margin_requirement,
            portfolio_equity
        )

        return PositionSizeResult(
            position_size=final_lot_size,
            position_size_unit="LOTS",
            notional_value=notional_value,
            margin_requirement=margin_requirement,
            leverage=self.leverage,
            adjustments=adjustments
        )

    def _calculate_stop_pips(
        self, entry_price: Decimal, stop_price: Decimal
    ) -> Decimal:
        """Calculate stop distance in pips."""
        price_distance = abs(entry_price - stop_price)
        stop_pips = price_distance / self.pair_config.pip_size
        return stop_pips

    def _calculate_pip_value(self, current_price: Decimal) -> Decimal:
        """
        Calculate pip value per standard lot (100,000 units).

        Formula depends on currency pair type:
        - XXX/USD: pip_value = (0.0001 / current_price) * 100000
        - USD/XXX: pip_value = 0.0001 * 100000
        - XXX/YYY: pip_value = (0.0001 / current_price) * 100000 * conversion_rate
        """
        if self.pair_config.is_xxx_usd:
            # Quote currency is USD (e.g., EUR/USD)
            pip_value = (self.pair_config.pip_size / current_price) * Decimal("100000")
        elif self.pair_config.is_usd_xxx:
            # Base currency is USD (e.g., USD/JPY)
            pip_value = self.pair_config.pip_size * Decimal("100000")
        else:
            # Cross pair (e.g., EUR/GBP) - requires conversion rate
            # For now, raise NotImplementedError
            raise NotImplementedError(
                f"Cross pairs not yet supported: {self.symbol}. "
                f"Requires {self.pair_config.quote_currency}/USD conversion rate."
            )

        return pip_value

    def _get_friday_multiplier(self, current_time: datetime) -> Decimal:
        """
        Return position size multiplier based on Friday timing.

        - Before 13:00 UTC (8am EST): 1.00 (full week ahead)
        - 13:00-17:00 UTC (8am-12pm EST): 0.50 (weekend gap risk)
        - After 17:00 UTC (12pm EST): 0.00 (should FAIL in Story 8.7)
        """
        if current_time.weekday() != 4:  # Not Friday
            return Decimal("1.0")

        hour = current_time.hour  # UTC
        if hour < 13:
            return Decimal("1.0")  # Full week ahead
        elif 13 <= hour < 17:
            return Decimal("0.50")  # Cut in half
        else:
            # Should be caught by Story 8.7 validation
            return Decimal("0.0")

    def _quantize_lot_size(self, lot_size: Decimal) -> Decimal:
        """Round down to broker minimum lot size."""
        min_lot = self.pair_config.min_lot_size
        quantized = (lot_size // min_lot) * min_lot
        return max(quantized, min_lot)  # At least min_lot

    def _calculate_notional_value(
        self, lot_size: Decimal, entry_price: Decimal
    ) -> Decimal:
        """Calculate total notional value of position."""
        return lot_size * Decimal("100000") * entry_price

    def _validate_risk_limits(
        self,
        lot_size: Decimal,
        notional_value: Decimal,
        margin_requirement: Decimal,
        portfolio_equity: Decimal
    ) -> None:
        """
        Validate position against forex risk limits.

        Raises:
            ValueError: If position violates risk limits
        """
        # Check margin requirement (max 10% of equity per position)
        max_margin = portfolio_equity * self.MAX_MARGIN_PER_POSITION
        if margin_requirement > max_margin:
            raise ValueError(
                f"Margin requirement ${margin_requirement:,.0f} exceeds "
                f"10% of equity (${max_margin:,.0f})"
            )

        # Note: Notional exposure limit is checked in Story 8.9 (Emergency Exits)
        # across ALL open positions, not per-position

    def _load_pair_config(self, symbol: str) -> ForexPairConfig:
        """Load currency pair configuration (from config file or defaults)."""
        # TODO: Load from backend/config/forex_pairs.yaml
        # For now, return hardcoded EUR/USD config
        if symbol == "EUR/USD":
            return ForexPairConfig(
                symbol="EUR/USD",
                pip_size=Decimal("0.0001"),
                base_currency="EUR",
                quote_currency="USD",
                min_lot_size=Decimal("0.01"),  # Micro lots
                lot_type=LotType.MICRO
            )
        else:
            raise ValueError(f"Unsupported currency pair: {symbol}")


# backend/src/risk_management/risk_calculator_factory.py

class RiskCalculatorFactory:
    """Factory for creating asset-class-specific risk calculators."""

    @staticmethod
    def create(
        asset_class: Literal["STOCK", "FOREX", "CRYPTO"],
        symbol: str,
        **kwargs
    ) -> RiskCalculator:
        """
        Create appropriate risk calculator for asset class.

        Usage:
            calculator = RiskCalculatorFactory.create(
                asset_class="FOREX",
                symbol="EUR/USD",
                leverage=Decimal("50.0")
            )
        """
        if asset_class == "STOCK":
            from .stock_risk_calculator import StockRiskCalculator
            return StockRiskCalculator(symbol=symbol, **kwargs)
        elif asset_class == "FOREX":
            from .forex_risk_calculator import ForexRiskCalculator
            return ForexRiskCalculator(symbol=symbol, **kwargs)
        elif asset_class == "CRYPTO":
            raise NotImplementedError("Crypto risk calculator not yet implemented")
        else:
            raise ValueError(f"Unknown asset class: {asset_class}")
```

### Configuration File

```yaml
# backend/config/forex_pairs.yaml

# Major pairs (most liquid)
major_pairs:
  EUR/USD:
    pip_size: 0.0001
    base_currency: EUR
    quote_currency: USD
    min_lot_size: 0.01  # Micro lots
    typical_spread_pips: 1.5

  GBP/USD:
    pip_size: 0.0001
    base_currency: GBP
    quote_currency: USD
    min_lot_size: 0.01
    typical_spread_pips: 2.0

  USD/JPY:
    pip_size: 0.01     # JPY pairs use 0.01 pip
    base_currency: USD
    quote_currency: JPY
    min_lot_size: 0.01
    typical_spread_pips: 1.5

  USD/CHF:
    pip_size: 0.0001
    base_currency: USD
    quote_currency: CHF
    min_lot_size: 0.01
    typical_spread_pips: 2.5

# Minor pairs (cross pairs)
minor_pairs:
  EUR/GBP:
    pip_size: 0.0001
    base_currency: EUR
    quote_currency: GBP
    min_lot_size: 0.01
    typical_spread_pips: 3.0
    requires_conversion: true
    conversion_pair: GBP/USD

  EUR/JPY:
    pip_size: 0.01
    base_currency: EUR
    quote_currency: JPY
    min_lot_size: 0.01
    typical_spread_pips: 2.5
    requires_conversion: true
    conversion_pair: JPY/USD
```

---

## Testing Requirements

### Unit Tests (20+ tests)

```python
# backend/tests/unit/risk_management/test_forex_risk_calculator.py

import pytest
from decimal import Decimal
from datetime import datetime, timezone

from backend.src.risk_management.forex_risk_calculator import (
    ForexRiskCalculator,
    ForexPairConfig,
    LotType
)
from backend.src.models.forex_session import ForexSession


class TestForexRiskCalculator:
    """Unit tests for ForexRiskCalculator."""

    @pytest.fixture
    def eur_usd_config(self):
        return ForexPairConfig(
            symbol="EUR/USD",
            pip_size=Decimal("0.0001"),
            base_currency="EUR",
            quote_currency="USD",
            min_lot_size=Decimal("0.01"),
            lot_type=LotType.MICRO
        )

    @pytest.fixture
    def calculator(self, eur_usd_config):
        return ForexRiskCalculator(
            symbol="EUR/USD",
            leverage=Decimal("50.0"),
            pair_config=eur_usd_config
        )

    # Pip calculation tests
    def test_calculate_stop_pips_basic(self, calculator):
        """Test basic pip calculation."""
        entry = Decimal("1.1000")
        stop = Decimal("1.0950")

        pips = calculator._calculate_stop_pips(entry, stop)

        assert pips == Decimal("50")  # 0.0050 / 0.0001 = 50 pips

    def test_calculate_pip_value_xxx_usd(self, calculator):
        """Test pip value for XXX/USD pairs."""
        current_price = Decimal("1.1000")

        pip_value = calculator._calculate_pip_value(current_price)

        # (0.0001 / 1.1000) * 100000 ≈ $9.09 per pip per standard lot
        assert abs(pip_value - Decimal("9.09")) < Decimal("0.01")

    # Position sizing tests
    def test_calculate_position_size_basic(self, calculator):
        """Test basic position size calculation."""
        result = calculator.calculate_position_size(
            risk_amount=Decimal("100.0"),
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),  # 50 pips
            portfolio_equity=Decimal("10000.0"),
            forex_session=ForexSession.LONDON,
            current_time=datetime(2025, 6, 16, 10, 0, tzinfo=timezone.utc)  # Monday
        )

        # Risk $100, stop 50 pips, pip value ≈$9.09
        # Position size = $100 / (50 * $9.09) ≈ 0.22 lots
        assert result.position_size == Decimal("0.22")
        assert result.position_size_unit == "LOTS"
        assert result.leverage == Decimal("50.0")

    def test_session_multiplier_asian(self, calculator):
        """Test Asian session reduces position size by 30%."""
        result = calculator.calculate_position_size(
            risk_amount=Decimal("100.0"),
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),
            portfolio_equity=Decimal("10000.0"),
            forex_session=ForexSession.ASIAN,  # 70% multiplier
            current_time=datetime(2025, 6, 16, 5, 0, tzinfo=timezone.utc)
        )

        # Base size ≈0.22 * 0.70 = 0.15 lots
        assert result.position_size == Decimal("0.15")
        assert "ASIAN session: reduced to 70%" in result.adjustments[0]

    def test_friday_weekend_adjustment(self, calculator):
        """Test Friday after 8am EST cuts position size in half."""
        result = calculator.calculate_position_size(
            risk_amount=Decimal("100.0"),
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),
            portfolio_equity=Decimal("10000.0"),
            forex_session=ForexSession.NY,
            current_time=datetime(2025, 6, 20, 15, 0, tzinfo=timezone.utc)  # Friday 10am EST
        )

        # Base size ≈0.22 * 0.50 = 0.11 lots
        assert result.position_size == Decimal("0.11")
        assert "Friday entry: reduced to 50%" in result.adjustments[1]

    def test_lot_size_quantization(self, calculator):
        """Test position size rounds down to broker minimum."""
        # Create calculator with 0.10 lot minimum (mini lots)
        config = ForexPairConfig(
            symbol="EUR/USD",
            pip_size=Decimal("0.0001"),
            base_currency="EUR",
            quote_currency="USD",
            min_lot_size=Decimal("0.10"),  # Mini lots
            lot_type=LotType.MINI
        )
        calc_mini = ForexRiskCalculator(
            symbol="EUR/USD",
            leverage=Decimal("50.0"),
            pair_config=config
        )

        # Calculated size would be 0.17 lots
        # Should quantize to 0.10 lots (round down)
        quantized = calc_mini._quantize_lot_size(Decimal("0.17"))

        assert quantized == Decimal("0.10")

    # Notional value and margin tests
    def test_calculate_notional_value(self, calculator):
        """Test notional value calculation."""
        lot_size = Decimal("0.20")
        entry_price = Decimal("1.1000")

        notional = calculator._calculate_notional_value(lot_size, entry_price)

        # 0.20 * 100,000 * 1.1000 = $22,000
        assert notional == Decimal("22000.0")

    def test_margin_requirement_validation(self, calculator):
        """Test margin requirement must be <10% of equity."""
        with pytest.raises(ValueError, match="Margin requirement.*exceeds 10% of equity"):
            calculator.calculate_position_size(
                risk_amount=Decimal("1000.0"),  # Large risk
                entry_price=Decimal("1.1000"),
                stop_price=Decimal("1.0950"),
                portfolio_equity=Decimal("5000.0"),  # Small equity
                forex_session=ForexSession.LONDON,
                current_time=datetime(2025, 6, 16, 10, 0, tzinfo=timezone.utc)
            )

    # Edge cases
    def test_unsupported_currency_pair(self):
        """Test unsupported currency pair raises error."""
        with pytest.raises(ValueError, match="Unsupported currency pair"):
            ForexRiskCalculator(
                symbol="XYZ/ABC",
                leverage=Decimal("50.0")
            )

    def test_cross_pair_not_implemented(self):
        """Test cross pairs raise NotImplementedError."""
        config = ForexPairConfig(
            symbol="EUR/GBP",
            pip_size=Decimal("0.0001"),
            base_currency="EUR",
            quote_currency="GBP",
            min_lot_size=Decimal("0.01"),
            lot_type=LotType.MICRO
        )
        calc = ForexRiskCalculator(
            symbol="EUR/GBP",
            leverage=Decimal("50.0"),
            pair_config=config
        )

        with pytest.raises(NotImplementedError, match="Cross pairs not yet supported"):
            calc._calculate_pip_value(Decimal("0.8500"))


class TestRiskCalculatorFactory:
    """Unit tests for RiskCalculatorFactory."""

    def test_create_stock_calculator(self):
        """Test factory creates StockRiskCalculator for stocks."""
        from backend.src.risk_management.risk_calculator_factory import RiskCalculatorFactory
        from backend.src.risk_management.stock_risk_calculator import StockRiskCalculator

        calculator = RiskCalculatorFactory.create(
            asset_class="STOCK",
            symbol="AAPL"
        )

        assert isinstance(calculator, StockRiskCalculator)

    def test_create_forex_calculator(self):
        """Test factory creates ForexRiskCalculator for forex."""
        from backend.src.risk_management.risk_calculator_factory import RiskCalculatorFactory
        from backend.src.risk_management.forex_risk_calculator import ForexRiskCalculator

        calculator = RiskCalculatorFactory.create(
            asset_class="FOREX",
            symbol="EUR/USD",
            leverage=Decimal("50.0")
        )

        assert isinstance(calculator, ForexRiskCalculator)

    def test_create_crypto_not_implemented(self):
        """Test crypto raises NotImplementedError."""
        from backend.src.risk_management.risk_calculator_factory import RiskCalculatorFactory

        with pytest.raises(NotImplementedError, match="Crypto risk calculator"):
            RiskCalculatorFactory.create(
                asset_class="CRYPTO",
                symbol="BTC/USD"
            )
```

### Integration Tests (8+ tests)

```python
# backend/tests/integration/risk_management/test_forex_risk_integration.py

import pytest
from decimal import Decimal
from datetime import datetime, timezone

from backend.src.orchestrator.master_orchestrator import MasterOrchestrator
from backend.src.models.pattern import Pattern, PatternType
from backend.src.models.trading_range import TradingRange
from backend.src.models.forex_session import ForexSession


class TestForexRiskIntegration:
    """Integration tests for forex risk calculations in full pipeline."""

    @pytest.fixture
    def eur_usd_spring_pattern(self):
        """Create EUR/USD spring pattern for testing."""
        return Pattern(
            pattern_type=PatternType.SPRING,
            symbol="EUR/USD",
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),
            target_price=Decimal("1.1200"),
            confidence_score=85,
            asset_class="FOREX",
            detected_at=datetime(2025, 6, 16, 10, 0, tzinfo=timezone.utc)  # Monday London
        )

    def test_forex_signal_generation_london_session(
        self, eur_usd_spring_pattern, orchestrator
    ):
        """Test forex signal generation during London session."""
        result = orchestrator.validate_and_generate_signal(
            pattern=eur_usd_spring_pattern,
            forex_session=ForexSession.LONDON,
            leverage=Decimal("50.0")
        )

        assert result.status == "PASS"
        signal = result.trade_signal

        # Verify forex-specific fields
        assert signal.asset_class == "FOREX"
        assert signal.position_size_unit == "LOTS"
        assert signal.leverage == Decimal("50.0")
        assert signal.notional_value > 0
        assert signal.margin_requirement > 0

        # Verify position size is reasonable (0.1-1.0 lots typical)
        assert Decimal("0.01") <= signal.position_size <= Decimal("1.0")

    def test_forex_signal_reduced_asian_session(
        self, eur_usd_spring_pattern, orchestrator
    ):
        """Test forex position size reduced 30% during Asian session."""
        # London session result
        london_result = orchestrator.validate_and_generate_signal(
            pattern=eur_usd_spring_pattern,
            forex_session=ForexSession.LONDON
        )
        london_size = london_result.trade_signal.position_size

        # Asian session result (same pattern)
        asian_pattern = eur_usd_spring_pattern.copy()
        asian_pattern.detected_at = datetime(2025, 6, 16, 5, 0, tzinfo=timezone.utc)

        asian_result = orchestrator.validate_and_generate_signal(
            pattern=asian_pattern,
            forex_session=ForexSession.ASIAN
        )
        asian_size = asian_result.trade_signal.position_size

        # Asian should be ~70% of London
        assert asian_size < london_size
        assert abs(asian_size / london_size - Decimal("0.70")) < Decimal("0.05")

    def test_forex_friday_afternoon_reduced_50_percent(
        self, eur_usd_spring_pattern, orchestrator
    ):
        """Test forex position size cut in half on Friday afternoon."""
        # Monday result
        monday_result = orchestrator.validate_and_generate_signal(
            pattern=eur_usd_spring_pattern,
            forex_session=ForexSession.NY
        )
        monday_size = monday_result.trade_signal.position_size

        # Friday afternoon result (same pattern)
        friday_pattern = eur_usd_spring_pattern.copy()
        friday_pattern.detected_at = datetime(2025, 6, 20, 15, 0, tzinfo=timezone.utc)  # Friday 10am EST

        friday_result = orchestrator.validate_and_generate_signal(
            pattern=friday_pattern,
            forex_session=ForexSession.NY,
            current_time=friday_pattern.detected_at
        )

        if friday_result.status == "PASS":
            friday_size = friday_result.trade_signal.position_size

            # Friday should be ~50% of Monday
            assert friday_size < monday_size
            assert abs(friday_size / monday_size - Decimal("0.50")) < Decimal("0.05")

    def test_forex_notional_exposure_limit_enforced(self, orchestrator):
        """Test notional exposure limit prevents over-leveraging."""
        # Create 3 open forex positions near 3x equity limit
        portfolio_equity = Decimal("10000.0")

        # Position 1: 0.50 lots EUR/USD @ 1.1000 = $55,000 notional
        # Position 2: 0.40 lots GBP/USD @ 1.3000 = $52,000 notional
        # Total: $107,000 notional (10.7x equity with 50:1 leverage)
        # But only $2,140 margin used ($107k / 50 = $2,140)

        # Attempt to open 4th position - should FAIL
        new_pattern = Pattern(
            pattern_type=PatternType.SPRING,
            symbol="EUR/USD",
            entry_price=Decimal("1.1000"),
            stop_price=Decimal("1.0950"),
            target_price=Decimal("1.1200"),
            confidence_score=85,
            asset_class="FOREX"
        )

        result = orchestrator.validate_and_generate_signal(
            pattern=new_pattern,
            forex_session=ForexSession.LONDON,
            open_positions=[...]  # Mock positions
        )

        # Should FAIL due to notional exposure limit (3x equity = $30k)
        assert result.status == "FAIL"
        assert "notional exposure" in result.reason.lower()
```

---

## Documentation Requirements

1. **User Guide: Forex Risk Management**
   - Lot sizing explained (standard/mini/micro)
   - Leverage and margin requirements
   - Session-based adjustments
   - Friday weekend gap protection
   - Real-world examples with calculations

2. **Developer Guide: Forex Risk Calculator**
   - API documentation for ForexRiskCalculator
   - How to add new currency pairs
   - Pip value calculation formulas
   - Integration with Story 8.6

3. **Configuration Guide: forex_pairs.yaml**
   - How to configure new pairs
   - Pip size specifications
   - Broker minimum lot sizes
   - Spread and slippage estimates

---

## Story Sizing

**Complexity:** High
**Effort:** 8 story points
**Risk:** Medium

**High Complexity Factors:**
- Currency-pair-specific pip value calculations
- Session-based and day-of-week adjustments
- Integration with existing RiskValidationStage
- Comprehensive testing (28+ tests)

**Medium Risk Factors:**
- Pip value formulas are well-documented (low risk)
- Leverage calculations are straightforward
- Main risk is edge cases (cross pairs, exotic pairs)

---

## Definition of Done

- [ ] ForexRiskCalculator class implemented with all methods
- [ ] RiskCalculatorFactory created for asset-class routing
- [ ] forex_pairs.yaml configuration file created
- [ ] All 11 acceptance criteria met and tested
- [ ] 20+ unit tests passing (pytest)
- [ ] 8+ integration tests passing
- [ ] Code passes mypy --strict (0 errors)
- [ ] Code passes flake8 (0 errors)
- [ ] Integration with Story 8.6 (RiskValidationStage) verified
- [ ] User guide and developer docs written
- [ ] Code review approved by Rachel (Risk Manager)
- [ ] Wyckoff methodology sign-off by William (Mentor)

---

## Related Stories

- **Story 8.6:** Risk Validation Stage (parent story)
- **Story 8.3.1:** Forex Volume Validation Adjustments (sibling story)
- **Story 8.7:** Strategy Validation Stage (uses forex session detection)
- **Story 8.8:** Trade Signal Output Format (receives forex fields)
- **Story 8.9:** Emergency Exit Conditions (uses notional exposure limit)
- **Story 8.10:** Master Orchestrator Integration (routes to ForexRiskCalculator)

---

## Notes

**Rachel's Final Comments:**

"This story is the HEART of forex risk management. Without proper lot sizing, leverage tracking, and session-based adjustments, traders will unknowingly over-leverage and blow up their accounts. The 3x notional exposure limit and Friday weekend adjustments are non-negotiable—these are the guard rails that prevent catastrophic losses.

Remember: Forex leverage is seductive. A 50:1 leveraged position FEELS like 2% risk, but it's actually 100% notional exposure. If price moves 2% against you, you've lost your entire margin. That's why we need stricter limits (1.5% per trade, 2% daily loss) and constant notional exposure monitoring."

**William's Methodology Validation:**

"These adjustments honor Wyckoff's core principles in a 24-hour, leveraged market. The session-based sizing (70% Asian) reflects 'Effort vs Result'—thinner volume means less reliable signals. The Friday weekend adjustment (50% size) embodies 'controlled risk'—you can't control weekend news. And the notional exposure cap prevents the over-leveraging trap that violates 'never risk more than you can afford to lose.'

This is authentic Wyckoff methodology adapted for modern forex markets."

---

**Story Status:** Draft - Ready for Review
**Next Step:** Team review, then implementation in feature/story-8.6.1 branch
