# Story 8.4: Phase Validation Stage

## Status
Ready for Review

## Story
**As a** phase validator,
**I want** to validate that pattern-phase alignment is correct (FR15),
**so that** Springs in Phase A and SOS in Phase B are rejected.

## Acceptance Criteria
1. Validation function: `validate_phase(signal, phase_info) -> ValidationResult`
2. Phase-pattern rules (FR15):
   - Spring: only Phase C allowed
   - SOS: Phase D primary, late Phase C if confidence 85+
   - UTAD: Distribution Phase C only
3. Phase confidence check: must be ≥70% (FR3)
4. Early phase rejection (FR14): Phase A or Phase B duration <10 bars → FAIL
5. Detailed rejection: "Spring not valid in Phase B - wait for Phase C"
6. Unit test: Spring in Phase A rejected, Phase C accepted
7. Unit test: SOS in Phase D accepted, Phase B rejected
8. Integration test: phase misalignments correctly caught
9. FR14/FR15 compliance: phase validation enforces alignment rules
10. Logging: phase validation results with phase confidence scores

## Tasks / Subtasks

- [ ] Implement PhaseValidator class inheriting from BaseValidator (AC: 1)
  - [ ] Update file: `backend/src/signal_generator/validators/phase_validator.py`
  - [ ] Remove TODO comment and placeholder implementation from Story 8.2
  - [ ] Set class properties:
    - `validator_id = "PHASE_VALIDATOR"`
    - `stage_name = "Phase"`
  - [ ] Import required models:
    - ValidationResult, ValidationStatus, ValidationContext from models/validation
    - PhaseClassification, WyckoffPhase from models/phase_classification
    - Pattern from models/pattern
  - [ ] Add structlog logger initialization
  - [ ] Implement `async def validate(context: ValidationContext) -> ValidationResult`

- [ ] Validate phase_info presence in context (AC: 1)
  - [ ] Check if `context.phase_info` is not None
  - [ ] If None, return FAIL ValidationResult:
    - status = ValidationStatus.FAIL
    - reason = "Phase information not available for validation"
    - Log error: "phase_info_missing" with pattern details
  - [ ] Extract phase_classification from context.phase_info
  - [ ] Extract pattern_type from context.pattern.pattern_type

- [ ] Implement phase confidence validation (AC: 3, FR3)
  - [ ] Create method: `_validate_phase_confidence(phase_classification: PhaseClassification) -> tuple[bool, str | None]`
  - [ ] Check phase confidence >= 70% (FR3 minimum requirement)
  - [ ] If confidence < 70:
    - Return (False, f"Phase confidence {phase_classification.confidence}% below 70% minimum (FR3)")
  - [ ] If confidence >= 70:
    - Return (True, None)
  - [ ] Log confidence check result with actual confidence value

- [ ] Implement FR14 early phase rejection logic (AC: 4)
  - [ ] Create method: `_validate_fr14_early_phase(phase_classification: PhaseClassification) -> tuple[bool, str | None]`
  - [ ] Check if phase is Phase A:
    - Reject all patterns: "Phase A not allowed for trading - stopping action phase (FR14)"
  - [ ] Check if phase is Phase B with duration <10 bars:
    - Reject all patterns: f"Early Phase B ({phase_classification.duration} bars) not allowed - minimum 10 bars required for adequate cause (FR14)"
  - [ ] If phase is Phase B with duration >=10 bars, or Phase C/D/E:
    - Return (True, None) - FR14 validation passed
  - [ ] Log FR14 validation result

- [ ] Implement FR15 phase-pattern alignment rules (AC: 2)
  - [ ] Create method: `_validate_fr15_phase_pattern_alignment(pattern_type: str, phase: WyckoffPhase, phase_confidence: int) -> tuple[bool, str | None]`
  - [ ] **Spring Pattern Rules (AC: 2):**
    - IF pattern_type == "SPRING":
      - MUST be in Phase C only
      - If phase != WyckoffPhase.C:
        - Return (False, f"Spring patterns only valid in Phase C, currently in Phase {phase.value} (FR15)")
      - If phase == WyckoffPhase.C:
        - Return (True, None)
  - [ ] **SOS Pattern Rules (AC: 2):**
    - IF pattern_type == "SOS":
      - PRIMARY: Phase D (ideal)
      - ACCEPTABLE: Late Phase C if confidence >= 85%
      - If phase == WyckoffPhase.D:
        - Return (True, None) - ideal phase
      - If phase == WyckoffPhase.C and phase_confidence >= 85:
        - Return (True, None) - acceptable with high confidence
      - If phase == WyckoffPhase.C and phase_confidence < 85:
        - Return (False, f"SOS in late Phase C requires ≥85% confidence, currently {phase_confidence}% (FR15)")
      - If phase not in [C, D]:
        - Return (False, f"SOS patterns valid in Phase D (or late Phase C with 85+ confidence), currently in Phase {phase.value} (FR15)")
  - [ ] **LPS Pattern Rules (AC: 2):**
    - IF pattern_type == "LPS":
      - VALID: Phase D or Phase E
      - If phase in [WyckoffPhase.D, WyckoffPhase.E]:
        - Return (True, None)
      - Else:
        - Return (False, f"LPS patterns only valid in Phase D or E, currently in Phase {phase.value} (FR15)")
  - [ ] **UTAD Pattern Rules (AC: 2):**
    - IF pattern_type == "UTAD":
      - MUST be in Distribution Phase C only
      - If phase == WyckoffPhase.C:
        - Return (True, None)
      - Else:
        - Return (False, f"UTAD patterns only valid in Distribution Phase C, currently in Phase {phase.value} (FR15)")
  - [ ] **Unknown Pattern Type:**
    - Log warning: "unknown_pattern_type" with pattern_type
    - Return (True, None) - don't block unknown patterns at phase validation stage
  - [ ] Log FR15 validation result with pattern_type, phase, and outcome

- [ ] Implement main validate method orchestration (AC: 1)
  - [ ] In `async def validate(context: ValidationContext) -> ValidationResult`:
    - Log validation start: pattern_id, pattern_type, current_phase
  - [ ] Step 1: Validate phase_info presence
    - If fails, return FAIL ValidationResult immediately
  - [ ] Step 2: Validate phase confidence >= 70% (FR3)
    - Call `_validate_phase_confidence(context.phase_info)`
    - If fails, return FAIL ValidationResult with reason
  - [ ] Step 3: Validate FR14 early phase rejection
    - Call `_validate_fr14_early_phase(context.phase_info)`
    - If fails, return FAIL ValidationResult with reason
  - [ ] Step 4: Validate FR15 phase-pattern alignment
    - Call `_validate_fr15_phase_pattern_alignment(pattern_type, phase, confidence)`
    - If fails, return FAIL ValidationResult with reason
  - [ ] If all validations pass:
    - Create ValidationResult with status = PASS
    - Add metadata: {phase: phase.value, confidence: confidence, pattern_type: pattern_type}
    - Log validation success
  - [ ] Return ValidationResult

- [ ] Add comprehensive logging throughout (AC: 10)
  - [ ] Log validation start:
    - `logger.info("phase_validation_started", pattern_id=str(context.pattern.id), pattern_type=context.pattern.pattern_type, current_phase=phase.value)`
  - [ ] Log phase confidence check:
    - `logger.debug("phase_confidence_check", phase=phase.value, confidence=confidence, minimum_required=70, passes=passes)`
  - [ ] Log FR14 validation:
    - `logger.debug("fr14_early_phase_check", phase=phase.value, duration=phase_classification.duration, trading_allowed=phase_classification.trading_allowed)`
  - [ ] Log FR15 alignment check:
    - `logger.debug("fr15_alignment_check", pattern_type=pattern_type, required_phase=required_phase, actual_phase=phase.value, valid=valid)`
  - [ ] Log validation pass:
    - `logger.info("phase_validation_passed", pattern_type=pattern_type, phase=phase.value, confidence=confidence)`
  - [ ] Log validation fail:
    - `logger.warning("phase_validation_failed", pattern_type=pattern_type, phase=phase.value, reason=reason)`

- [ ] Add detailed rejection messages (AC: 5)
  - [ ] Phase A rejection:
    - "Phase A (Stopping Action) - no patterns tradable until Phase B with adequate cause (FR14)"
  - [ ] Early Phase B rejection:
    - f"Phase B duration {duration} bars < 10 bars minimum - insufficient cause built, wait for adequate accumulation (FR14)"
  - [ ] Spring-Phase mismatch:
    - f"Spring pattern detected in Phase {phase.value} - Springs only valid in Phase C after adequate cause building (FR15)"
  - [ ] SOS-Phase mismatch:
    - f"SOS pattern detected in Phase {phase.value} - SOS primarily valid in Phase D (or late Phase C with 85+ confidence) (FR15)"
  - [ ] LPS-Phase mismatch:
    - f"LPS pattern detected in Phase {phase.value} - LPS only valid in Phase D or Phase E markup (FR15)"
  - [ ] UTAD-Phase mismatch:
    - f"UTAD pattern detected in Phase {phase.value} - UTAD only valid in Distribution Phase C (FR15)"
  - [ ] Low confidence:
    - f"Phase {phase.value} confidence {confidence}% below 70% minimum requirement (FR3)"

- [ ] Add validation metadata for audit trail
  - [ ] When creating ValidationResult, populate metadata dict:
    - "phase": phase.value (e.g., "C")
    - "phase_confidence": confidence (e.g., 85)
    - "pattern_type": pattern_type (e.g., "SPRING")
    - "phase_duration": phase_classification.duration
    - "trading_allowed": phase_classification.trading_allowed
    - "fr14_check": "PASS" or "FAIL"
    - "fr15_check": "PASS" or "FAIL"
    - "fr3_confidence_check": "PASS" or "FAIL"
  - [ ] This metadata provides complete audit trail for compliance

- [ ] Write unit tests for phase confidence validation (AC: 3, 6)
  - [ ] Create/update test file: `backend/tests/unit/signal_generator/validators/test_phase_validator.py`
  - [ ] Test case: Phase confidence 85% (above 70%) → PASS
    - Create ValidationContext with PhaseClassification(confidence=85)
    - Create PhaseValidator instance
    - Call validate(context)
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: Phase confidence 65% (below 70%) → FAIL
    - Create ValidationContext with PhaseClassification(confidence=65)
    - Call validate(context)
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "below 70% minimum" in result.reason
  - [ ] Test case: Phase confidence exactly 70% (edge case) → PASS
    - Assert: result.status == ValidationStatus.PASS

- [ ] Write unit tests for FR14 early phase rejection (AC: 4, 6, 7)
  - [ ] Test case: Phase A with any pattern → FAIL
    - Create ValidationContext: pattern_type="SPRING", phase=WyckoffPhase.A
    - Call validate(context)
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "Phase A" in result.reason
    - Assert: "FR14" in result.reason
  - [ ] Test case: Phase B duration 5 bars (early) → FAIL
    - Create ValidationContext: phase=WyckoffPhase.B, duration=5
    - Call validate(context)
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "Early Phase B" in result.reason
    - Assert: "10 bars required" in result.reason
  - [ ] Test case: Phase B duration 10 bars (adequate) → PASS (if FR15 satisfied)
    - Create ValidationContext: phase=WyckoffPhase.B, duration=10
    - Should pass FR14 check (move to FR15 check)
  - [ ] Test case: Phase B duration 15 bars (adequate) → PASS (if FR15 satisfied)
    - Assert: FR14 check passes

- [ ] Write unit tests for FR15 Spring alignment (AC: 2, 6)
  - [ ] Test case: Spring in Phase C → PASS
    - Create ValidationContext: pattern_type="SPRING", phase=WyckoffPhase.C, confidence=80
    - Call validate(context)
    - Assert: result.status == ValidationStatus.PASS
    - Assert: result.metadata["fr15_check"] == "PASS"
  - [ ] Test case: Spring in Phase A → FAIL
    - Create ValidationContext: pattern_type="SPRING", phase=WyckoffPhase.A
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "only valid in Phase C" in result.reason
  - [ ] Test case: Spring in Phase B → FAIL
    - Create ValidationContext: pattern_type="SPRING", phase=WyckoffPhase.B, duration=15
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "only valid in Phase C" in result.reason
  - [ ] Test case: Spring in Phase D → FAIL
    - Assert: result.status == ValidationStatus.FAIL

- [ ] Write unit tests for FR15 SOS alignment (AC: 2, 7)
  - [ ] Test case: SOS in Phase D → PASS
    - Create ValidationContext: pattern_type="SOS", phase=WyckoffPhase.D, confidence=80
    - Call validate(context)
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: SOS in late Phase C with 85% confidence → PASS
    - Create ValidationContext: pattern_type="SOS", phase=WyckoffPhase.C, confidence=85
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: SOS in late Phase C with 84% confidence → FAIL
    - Create ValidationContext: pattern_type="SOS", phase=WyckoffPhase.C, confidence=84
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "requires ≥85% confidence" in result.reason
  - [ ] Test case: SOS in Phase B → FAIL
    - Create ValidationContext: pattern_type="SOS", phase=WyckoffPhase.B, duration=15
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "valid in Phase D" in result.reason

- [ ] Write unit tests for FR15 LPS alignment (AC: 2)
  - [ ] Test case: LPS in Phase D → PASS
    - Create ValidationContext: pattern_type="LPS", phase=WyckoffPhase.D
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: LPS in Phase E → PASS
    - Create ValidationContext: pattern_type="LPS", phase=WyckoffPhase.E
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: LPS in Phase C → FAIL
    - Create ValidationContext: pattern_type="LPS", phase=WyckoffPhase.C
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "only valid in Phase D or E" in result.reason

- [ ] Write unit tests for FR15 UTAD alignment (AC: 2)
  - [ ] Test case: UTAD in Distribution Phase C → PASS
    - Create ValidationContext: pattern_type="UTAD", phase=WyckoffPhase.C
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test case: UTAD in other phases → FAIL
    - Test each phase: A, B, D, E
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "only valid in Distribution Phase C" in result.reason

- [ ] Write unit test for missing phase_info (AC: 1)
  - [ ] Test case: context.phase_info is None → FAIL
    - Create ValidationContext with phase_info=None
    - Call validate(context)
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: "Phase information not available" in result.reason

- [ ] Write integration test for full phase validation scenarios (AC: 8)
  - [ ] Create test file: `backend/tests/integration/signal_generator/test_phase_validation_integration.py`
  - [ ] Test scenario 1: Valid Spring in Phase C
    - Build full ValidationContext:
      - Pattern with pattern_type="SPRING"
      - PhaseClassification: phase=C, confidence=85, duration=15
      - VolumeAnalysis with valid spring volume (0.4x)
      - TradingRange with Creek/Ice levels
    - Create PhaseValidator instance
    - Call validate(context)
    - Assert: result.status == ValidationStatus.PASS
    - Assert: result.metadata includes phase, confidence, pattern_type
  - [ ] Test scenario 2: Invalid Spring in Phase A
    - Build ValidationContext with phase=A
    - Call validate(context)
    - Assert: result.status == ValidationStatus.FAIL
    - Assert: rejection reason clear and actionable
  - [ ] Test scenario 3: SOS in Phase D with high confidence
    - Build ValidationContext: pattern_type="SOS", phase=D, confidence=88
    - Assert: result.status == ValidationStatus.PASS
  - [ ] Test scenario 4: SOS in Phase B (early, insufficient cause)
    - Build ValidationContext: phase=B, duration=8
    - Assert: result.status == ValidationStatus.FAIL (FR14 early phase)
  - [ ] Test scenario 5: Low confidence phase (65%)
    - Build ValidationContext with confidence=65
    - Assert: result.status == ValidationStatus.FAIL (FR3 violation)

- [ ] Write integration test for phase misalignment edge cases (AC: 8)
  - [ ] Test: Spring at exact Phase B→C transition
    - Simulate Spring detection at moment of phase transition
    - Ensure validation uses correct phase (Phase C)
  - [ ] Test: SOS at exact 85% confidence threshold
    - Phase C with exactly 85% confidence
    - Assert: PASS (meets threshold)
  - [ ] Test: SOS at 84.9% confidence (below threshold)
    - Assert: FAIL (doesn't meet 85% requirement)
  - [ ] Test: Phase B at exactly 10 bar duration
    - Assert: PASS for FR14 (meets minimum)

- [ ] Add pytest fixtures for common test scenarios
  - [ ] Create fixture: `valid_spring_phase_c_context()`
    - Returns ValidationContext with Spring in Phase C, all validations passing
  - [ ] Create fixture: `invalid_spring_phase_a_context()`
    - Returns ValidationContext with Spring in Phase A (should fail)
  - [ ] Create fixture: `valid_sos_phase_d_context()`
    - Returns ValidationContext with SOS in Phase D
  - [ ] Create fixture: `sos_late_phase_c_high_confidence_context()`
    - Returns ValidationContext with SOS in Phase C, 85% confidence
  - [ ] Create fixture: `early_phase_b_context(duration=5)`
    - Returns ValidationContext with Phase B, duration <10 bars

- [ ] Add parametrized tests for all pattern-phase combinations
  - [ ] Use pytest.mark.parametrize for comprehensive coverage:
    ```python
    @pytest.mark.parametrize("pattern_type,phase,confidence,expected_status,expected_reason_fragment", [
        ("SPRING", WyckoffPhase.A, 80, ValidationStatus.FAIL, "Phase A"),
        ("SPRING", WyckoffPhase.B, 80, ValidationStatus.FAIL, "only valid in Phase C"),
        ("SPRING", WyckoffPhase.C, 80, ValidationStatus.PASS, None),
        ("SPRING", WyckoffPhase.D, 80, ValidationStatus.FAIL, "only valid in Phase C"),
        ("SOS", WyckoffPhase.B, 80, ValidationStatus.FAIL, "Early Phase B"),
        ("SOS", WyckoffPhase.C, 84, ValidationStatus.FAIL, "requires ≥85%"),
        ("SOS", WyckoffPhase.C, 85, ValidationStatus.PASS, None),
        ("SOS", WyckoffPhase.D, 75, ValidationStatus.PASS, None),
        # ... more combinations
    ])
    async def test_phase_pattern_combinations(pattern_type, phase, confidence, expected_status, expected_reason_fragment):
        # Test implementation
    ```

- [ ] Document FR14 and FR15 enforcement in docstrings
  - [ ] Add comprehensive module docstring to phase_validator.py:
    - Explain FR14: early phase rejection
    - Explain FR15: phase-pattern alignment
    - Provide examples of valid and invalid combinations
  - [ ] Add class docstring to PhaseValidator
  - [ ] Add method docstrings for all validation methods
  - [ ] Include code examples showing proper usage

- [ ] Add validation result examples to docstrings
  - [ ] Document PASS example:
    ```python
    # Spring in Phase C with 85% confidence
    result = ValidationResult(
        stage="Phase",
        status=ValidationStatus.PASS,
        reason=None,
        validator_id="PHASE_VALIDATOR",
        metadata={
            "phase": "C",
            "phase_confidence": 85,
            "pattern_type": "SPRING",
            "fr14_check": "PASS",
            "fr15_check": "PASS",
            "fr3_confidence_check": "PASS"
        }
    )
    ```
  - [ ] Document FAIL examples for common rejection scenarios

## Dev Notes

### Previous Story Insights

**From Story 8.2 (Multi-Stage Validation Workflow):**
- Created ValidationResult, ValidationChain, ValidationContext models
- Defined BaseValidator abstract class with validate() method
- Created validator stub in phase_validator.py with TODO for full implementation
- ValidationStatus enum: PASS, FAIL, WARN
- Validators return ValidationResult with status, reason, metadata
- This story (8.4) replaces the stub with full FR14/FR15 enforcement logic
- Integration point: PhaseValidator is second stage in validation chain (after VolumeValidator)

**From Story 4.4 (Phase Classification Logic):**
- PhaseClassification model provides:
  - `phase: WyckoffPhase` (enum: A, B, C, D, E)
  - `confidence: int` (0-100 score)
  - `duration: int` (bars since phase began)
  - `trading_allowed: bool` (FR14 enforcement)
  - `rejection_reason: str | None` (why trading not allowed)
- WyckoffPhase enum values: A, B, C, D, E
- Phase confidence calculated based on event quality
- FR14 logic already in PhaseClassification.trading_allowed
- This story validates patterns against phase requirements

**From Epic 4 (Phase Identification System):**
- Phase A: SC + AR (stopping action) - trading NOT allowed
- Phase B <10 bars: early phase - trading NOT allowed
- Phase B ≥10 bars: adequate cause - trading allowed
- Phase C: Spring detected - trading allowed
- Phase D: SOS breakout - trading allowed
- Phase E: Sustained markup - trading allowed
- Phase confidence minimum: 70% (FR3)

**Key Integration Points:**
- ValidationContext.phase_info contains PhaseClassification from Story 4.4
- ValidationContext.pattern contains pattern_type (SPRING, SOS, LPS, UTAD)
- PhaseValidator executes after VolumeValidator in validation chain
- ValidationResult.metadata stores complete phase validation details for audit

### Functional Requirements

**FR3: Confidence Minimum** [Source: docs/prd/requirements.md]
> "The system shall assign confidence scores (70-95%) to all detected patterns, rejecting any pattern below 70% confidence threshold"

Applied to phase validation:
- Phase confidence must be ≥70%
- If phase_classification.confidence < 70: FAIL
- Ensures phase classification is reliable before pattern validation

**FR14: Early Phase Rejection** [Source: docs/prd/requirements.md]
> "The system shall reject trades in Phase A or early Phase B (duration <10 bars) as too early for entry"

Implementation:
- Phase A: Always reject (stopping action, accumulation not established)
- Phase B duration <10 bars: Reject (insufficient cause)
- Phase B duration ≥10 bars: Allow (adequate cause built)
- Phases C, D, E: Allow (accumulation complete, markup beginning)

**FR15: Phase-Pattern Alignment** [Source: docs/prd/requirements.md]
> "The system shall validate phase-pattern alignment: Springs only in Phase C, SOS primarily in Phase D, UTAD in Distribution Phase C"

Pattern-specific rules:
- **Spring**: MUST be Phase C (after adequate cause building)
- **SOS**: PRIMARY Phase D, ACCEPTABLE late Phase C if confidence ≥85%
- **LPS**: MUST be Phase D or Phase E (markup phase)
- **UTAD**: MUST be Distribution Phase C (distribution pattern)

Rationale:
- Spring too early (Phase A/B): False signal, breakdown risk
- SOS too early (Phase B): Insufficient cause, failed breakout risk
- LPS before markup: No trend established to pull back to
- UTAD outside Distribution C: Not a valid distribution top

### Data Models

**PhaseClassification Model** [Source: Story 4.4]

From `backend/src/models/phase_classification.py`:

```python
from enum import Enum
from pydantic import BaseModel, Field
from datetime import datetime

class WyckoffPhase(str, Enum):
    A = "A"  # Stopping Action
    B = "B"  # Building Cause
    C = "C"  # Test
    D = "D"  # Sign of Strength
    E = "E"  # Markup

class PhaseClassification(BaseModel):
    phase: WyckoffPhase = Field(..., description="Current Wyckoff phase")
    confidence: int = Field(..., ge=0, le=100, description="Phase confidence 0-100")
    duration: int = Field(..., ge=0, description="Bars since phase began")
    events_detected: PhaseEvents = Field(..., description="Events supporting this phase")
    trading_allowed: bool = Field(..., description="FR14: trading allowed in this phase")
    rejection_reason: str | None = Field(default=None, description="Why trading not allowed")
    phase_start_index: int = Field(..., ge=0)
    phase_start_timestamp: datetime
    last_updated: datetime

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

**ValidationContext Model** [Source: Story 8.2]

From `backend/src/models/validation.py`:

```python
class ValidationContext(BaseModel):
    pattern: Pattern = Field(..., description="Pattern being validated")
    symbol: str
    timeframe: str
    volume_analysis: VolumeAnalysis | None = None
    phase_info: PhaseClassification | None = None  # Used by PhaseValidator
    trading_range: TradingRange | None = None
    portfolio_context: PortfolioContext | None = None
    market_context: MarketContext | None = None
    config: dict[str, Any] = Field(default_factory=dict)
```

**ValidationResult Model** [Source: Story 8.2]

```python
class ValidationResult(BaseModel):
    stage: str = Field(..., description="e.g., 'Phase'")
    status: ValidationStatus = Field(..., description="PASS/FAIL/WARN")
    reason: str | None = Field(default=None, description="Required if FAIL/WARN")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    validator_id: str = Field(..., description="e.g., 'PHASE_VALIDATOR'")
    metadata: dict[str, Any] | None = Field(default=None, description="Phase details")

    class Config:
        json_encoders = {datetime: lambda v: v.isoformat()}
```

### File Locations

**Project Structure Reference** [Source: architecture/10-unified-project-structure.md]

Files to modify/create:
```
backend/src/
├── signal_generator/
│   └── validators/
│       └── phase_validator.py          # MODIFY: Replace stub with full implementation
```

Test files:
```
backend/tests/
├── unit/signal_generator/validators/
│   └── test_phase_validator.py         # MODIFY: Add comprehensive tests
└── integration/signal_generator/
    └── test_phase_validation_integration.py  # NEW: Integration tests
```

### API Specifications

**No New Public Endpoints** [Source: architecture/5-api-specification.md]

PhaseValidator is internal validation logic. Validation results exposed via Signal model:

```json
{
  "id": "signal-uuid",
  "symbol": "AAPL",
  "pattern_type": "SPRING",
  "validation_chain": {
    "validation_results": [
      {
        "stage": "Volume",
        "status": "PASS",
        "validator_id": "VOLUME_VALIDATOR"
      },
      {
        "stage": "Phase",
        "status": "PASS",
        "validator_id": "PHASE_VALIDATOR",
        "metadata": {
          "phase": "C",
          "phase_confidence": 85,
          "pattern_type": "SPRING",
          "phase_duration": 15,
          "fr14_check": "PASS",
          "fr15_check": "PASS",
          "fr3_confidence_check": "PASS"
        }
      }
    ]
  }
}
```

**Rejected Signal Example:**

```json
{
  "pattern_id": "pattern-uuid",
  "pattern_type": "SPRING",
  "rejection_stage": "Phase",
  "rejection_reason": "Spring pattern detected in Phase B - Springs only valid in Phase C after adequate cause building (FR15)",
  "validation_chain": {
    "overall_status": "FAIL",
    "validation_results": [
      {
        "stage": "Volume",
        "status": "PASS"
      },
      {
        "stage": "Phase",
        "status": "FAIL",
        "reason": "Spring pattern detected in Phase B - Springs only valid in Phase C after adequate cause building (FR15)",
        "metadata": {
          "phase": "B",
          "phase_confidence": 80,
          "pattern_type": "SPRING",
          "fr15_check": "FAIL"
        }
      }
    ]
  }
}
```

### Integration Notes

**Validation Chain Order** [Source: Story 8.2]

PhaseValidator is **second stage** in validation chain:
1. VolumeValidator (Story 8.3) - verify volume requirements
2. **PhaseValidator (Story 8.4) - verify phase alignment** ← THIS STORY
3. LevelValidator (Story 8.5) - verify Creek/Ice/Jump levels
4. RiskValidator (Story 8.6) - verify position sizing, heat limits
5. StrategyValidator (Story 8.7) - Wyckoff sanity checks, news

**Why Phase Validation Second:**
- Volume is cheapest check (fail fast on high-volume springs)
- Phase validation requires PhaseClassification (moderate cost)
- Phase must be correct before checking levels/risk
- Early rejection saves expensive risk calculations

**Signal Generation Workflow** [Source: Story 8.1, architecture/8-core-workflows.md]

```
Pattern Detected (Epic 5/6)
  ↓
Build ValidationContext:
  - pattern: Pattern from detector
  - phase_info: PhaseClassification from Story 4.4
  - volume_analysis: VolumeAnalysis from Epic 2
  - trading_range: TradingRange from Epic 3
  ↓
Run Validation Chain:
  1. VolumeValidator (Story 8.3)
  2. PhaseValidator (Story 8.4) ← THIS STORY
  3. LevelValidator (Story 8.5)
  4. RiskValidator (Story 8.6)
  5. StrategyValidator (Story 8.7)
  ↓
If ValidationChain.is_valid:
  Create Signal
Else:
  Reject pattern, log reason
```

### Testing Requirements

**Testing Framework** [Source: architecture/12-testing-strategy.md]
- Backend testing: pytest (8.0+) with async support (pytest-asyncio)
- Unit tests: Test each validation rule independently
- Integration tests: Test full validation with realistic scenarios
- Use pytest fixtures for common ValidationContext setups
- Parametrized tests for pattern-phase combination matrix

**Test Coverage Requirements:**
- Unit test each FR14 rule (Phase A, early Phase B, adequate Phase B)
- Unit test each FR15 rule (Spring→C, SOS→D/late C, LPS→D/E, UTAD→C)
- Unit test FR3 confidence check (below 70%, above 70%, exactly 70%)
- Integration test with full ValidationContext
- Edge case tests (exact thresholds, phase transitions)

**Async Testing Pattern:**

```python
import pytest
from backend.src.signal_generator.validators.phase_validator import PhaseValidator
from backend.src.models.validation import ValidationContext, ValidationStatus

@pytest.mark.asyncio
async def test_spring_in_phase_c_passes():
    # Create context
    context = ValidationContext(
        pattern=Pattern(pattern_type="SPRING", ...),
        phase_info=PhaseClassification(phase=WyckoffPhase.C, confidence=85, ...),
        # ... other fields
    )

    # Execute validation
    validator = PhaseValidator()
    result = await validator.validate(context)

    # Assert
    assert result.status == ValidationStatus.PASS
    assert result.metadata["phase"] == "C"
    assert result.metadata["fr15_check"] == "PASS"
```

### Technical Constraints

**Async/Await Required** [Source: architecture/3-tech-stack.md]
- All validator methods must be `async def`
- PhaseValidator.validate() is async
- Compatible with validation chain orchestration
- Enables future parallel validation if needed

**Pydantic Validation** [Source: architecture/3-tech-stack.md]
- Use Pydantic models for all data structures
- ValidationContext, ValidationResult, PhaseClassification all Pydantic
- Automatic JSON serialization for API responses
- Field validation ensures data integrity

**Error Handling** [Source: architecture/16-error-handling-strategy.md]
- PhaseValidator should NOT raise exceptions
- Return FAIL ValidationResult instead of raising
- Log all validation failures with structlog
- Include detailed context in logs for debugging

### Logging and Observability

**Structured Logging** [Source: architecture/3-tech-stack.md - structlog 24.1+]

Log all phase validation events:

```python
import structlog
logger = structlog.get_logger()

# Validation start
logger.info("phase_validation_started",
            pattern_id=str(context.pattern.id),
            pattern_type=context.pattern.pattern_type,
            current_phase=phase.value,
            phase_confidence=confidence)

# FR3 confidence check
logger.debug("fr3_confidence_check",
             phase=phase.value,
             confidence=confidence,
             minimum_required=70,
             passes=confidence >= 70)

# FR14 early phase check
logger.debug("fr14_early_phase_check",
             phase=phase.value,
             duration=duration,
             trading_allowed=trading_allowed,
             rejection_reason=rejection_reason)

# FR15 alignment check
logger.debug("fr15_phase_pattern_alignment",
             pattern_type=pattern_type,
             required_phase=required_phase,
             actual_phase=phase.value,
             alignment_valid=valid)

# Validation passed
logger.info("phase_validation_passed",
            pattern_type=pattern_type,
            phase=phase.value,
            confidence=confidence,
            fr14_status="PASS",
            fr15_status="PASS")

# Validation failed
logger.warning("phase_validation_failed",
               pattern_type=pattern_type,
               phase=phase.value,
               rejection_reason=reason,
               failed_requirement="FR15")  # or FR14, FR3
```

**Correlation IDs** [Source: architecture/17-monitoring-and-observability.md]
- Use pattern_id as correlation ID to trace through validation
- Enables log queries: "Show all validations for pattern XYZ"
- Pattern ID flows through: Detection → Validation → Signal/Rejection

### Phase-Pattern Alignment Examples

**Valid Combinations:**

| Pattern Type | Valid Phases | Rationale |
|--------------|--------------|-----------|
| SPRING | C | Spring is final test after adequate cause (Phase B ≥10 bars) |
| SOS | D | Breakout occurs after Spring test, beginning of markup |
| SOS | C (if confidence ≥85%) | Very strong late Phase C, imminent markup |
| LPS | D, E | Pullback during markup phase, continuation pattern |
| UTAD | C (Distribution) | Final test before distribution markdown |

**Invalid Combinations (with reasons):**

| Pattern Type | Invalid Phase | Rejection Reason |
|--------------|---------------|------------------|
| SPRING | A | Phase A is stopping action - accumulation not established, too early for Spring |
| SPRING | B (duration <10) | Early Phase B - insufficient cause built, Spring would be premature |
| SPRING | B (duration ≥10) | Phase B is building cause - Spring occurs AFTER cause building in Phase C |
| SPRING | D | Phase D is markup - Spring is test pattern before markup, not during |
| SOS | A | Phase A stopping action - no breakout possible without accumulation |
| SOS | B | Phase B building cause - need Spring test (Phase C) before breakout |
| SOS | C (confidence <85%) | Late Phase C with low confidence - not strong enough for premature breakout |
| LPS | A, B, C | LPS is pullback during markup - requires existing markup (Phase D/E) |

### Dependencies

**Python Libraries** [Source: architecture/3-tech-stack.md]
- Python 3.11+ (async/await, type hints)
- FastAPI 0.109+ (async web framework)
- Pydantic 2.5+ (data validation)
- pytest 8.0+ (testing)
- pytest-asyncio (async test support)
- structlog 24.1+ (structured logging)

**Internal Dependencies**
- Story 8.2: BaseValidator, ValidationResult, ValidationContext, ValidationStatus
- Story 4.4: PhaseClassification, WyckoffPhase, PhaseEvents
- Pattern model (from Epic 5/6): pattern_type field
- ValidationContext assembly (Story 8.1): provides phase_info

**Related Stories**
- **Story 8.2 (Multi-Stage Validation Workflow)** - Created validation framework
- **Story 8.1 (Master Orchestrator)** - Builds ValidationContext with phase_info
- **Story 8.3 (Volume Validation)** - Runs before phase validation
- **Story 8.5 (Level Validation)** - Runs after phase validation
- **Story 4.4 (Phase Classification)** - Provides PhaseClassification model

### Risk Mitigation Notes

**Why Phase Validation Matters** [Source: Epic 8 PRD, FR14, FR15]

Without phase-pattern alignment validation:
- Spring detected in Phase A → false signal, breakdown risk (accumulation not established)
- SOS detected in Phase B → failed breakout (insufficient cause, premature)
- Pattern detection wasted on wrong phase → capital at risk
- FR14/FR15 violations → trading rule breaches, suboptimal entries

**Common Phase Misalignment Scenarios:**

1. **Spring in Phase B (most common mistake):**
   - Phase B: Still building cause, multiple tests expected
   - Spring: Final test AFTER cause building complete
   - Risk: Entry too early, more tests coming, stop-out risk
   - Solution: Wait for Phase C (Spring) or adequate Phase B duration

2. **SOS in Phase C (less than 85% confidence):**
   - Phase C: Test phase, not yet ready for markup
   - SOS: Breakout pattern signaling markup beginning
   - Risk: Failed breakout, return to range
   - Solution: Wait for Phase D or ensure very high confidence (≥85%)

3. **LPS before markup established:**
   - LPS: Pullback to support during existing uptrend
   - Phases A/B/C: No uptrend established yet
   - Risk: No trend to pull back to, not a valid LPS
   - Solution: Only trade LPS in Phase D/E

**Audit Trail Importance:**

Complete phase validation metadata enables:
- "Why was this Spring rejected?" → Check validation_chain: "Spring in Phase B, FR15 violation"
- "Are we following FR14/FR15?" → Query all rejections by failed_requirement
- Pattern learning: Analyze which phase misalignments occur most frequently
- Backtesting: Replay phase validation decisions to optimize detection

**Testing Strategy:**

- Comprehensive unit tests ensure every FR14/FR15 rule enforced
- Parametrized tests cover all pattern-phase combinations
- Integration tests validate with realistic market scenarios
- Edge case tests (exact thresholds) prevent off-by-one errors

## Testing

### Unit Test Requirements
- Test FR3 confidence validation (below 70%, at 70%, above 70%)
- Test FR14 early phase rejection (Phase A, early Phase B, adequate Phase B)
- Test FR15 Spring alignment (valid in C, invalid in A/B/D/E)
- Test FR15 SOS alignment (valid in D, conditional in C, invalid in A/B/E)
- Test FR15 LPS alignment (valid in D/E, invalid in A/B/C)
- Test FR15 UTAD alignment (valid in Distribution C only)
- Test missing phase_info handling
- Test validation metadata population

### Integration Test Requirements
- Full validation with realistic Spring in Phase C
- Full validation with invalid Spring in Phase A/B
- Full validation with SOS in Phase D (ideal)
- Full validation with SOS in late Phase C (85% confidence)
- Full validation with low confidence phase (<70%)
- Edge cases: exact thresholds (70%, 85%, 10 bars)

### Performance Test Requirements
- Phase validation should complete in <2ms (simple conditionals)
- No expensive computations (phase_info pre-calculated)
- Minimal overhead compared to other validators

[Source: architecture/12-testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation for Epic 8.4 - Phase Validation Stage | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None - implementation completed without issues

### Completion Notes

Successfully implemented PhaseValidator with complete FR3/FR14/FR15 enforcement:

**Implementation Highlights:**

- Replaced Story 8.2 stub with full validation logic
- Implemented 4-stage validation workflow (phase_info presence → FR3 confidence → FR14 early phase → FR15 alignment)
- FR3: Phase confidence ≥70% validation
- FR14: Early phase rejection (Phase A always, Phase B if duration <10 bars)
- FR15: Phase-pattern alignment rules:
  - Spring: Only Phase C allowed
  - SOS: Phase D primary, Phase C acceptable if confidence ≥85%
  - LPS: Phase D or E only
  - UTAD: Distribution Phase C only
- Comprehensive metadata population for audit trail (phase, confidence, pattern_type, duration, FR checks)
- Structured logging with structlog (validation start, FR checks, pass/fail outcomes)

**Testing:**

- 43 unit tests covering all FR3/FR14/FR15 scenarios (all passing)
- 10 integration tests with realistic ValidationContext (all passing)
- Parametrized tests for pattern-phase combination matrix
- Edge case tests (exact thresholds: 70%, 85%, 10 bars)
- Test fixtures for common scenarios

**Linting:**

- mypy --strict: PASS (0 issues)
- ruff check: PASS (0 issues after auto-fix)

**Code Quality:**

- Clear separation of concerns (validate_phase_confidence, validate_fr14_early_phase, validate_fr15_phase_pattern_alignment)
- Detailed rejection messages for user actionability
- First-failure-wins pattern (FR3 → FR14 → FR15 order)
- No exceptions raised (returns FAIL ValidationResult instead)

### File List

**Modified:**

- backend/src/signal_generator/validators/phase_validator.py (replaced stub with full implementation)

**Created:**

- backend/tests/unit/signal_generator/validators/test_phase_validator.py (43 tests)
- backend/tests/integration/signal_generator/test_phase_validation_integration.py (10 tests)

## QA Results
_To be filled by QA Agent_
