# Story 8.9: Emergency Exit Conditions Implementation

## Status
Done

## Story
**As an** orchestrator,
**I want** to implement emergency exit conditions that bypass normal flow (FR21),
**so that** positions are closed immediately when invalidation occurs.

## Acceptance Criteria
1. Emergency exit triggers (FR21):
   - Spring low break â†’ exit all campaign positions
   - Ice break after SOS â†’ exit breakout positions
   - UTAD high exceeded â†’ exit short positions
   - Daily loss â‰¥3% (stocks), â‰¥2% (forex) â†’ halt new trades
   - Max drawdown â‰¥15% â†’ halt system
   - **NEW:** Weekend gap trigger (forex) - Friday after 12pm EST entry warning
2. Immediate execution: emergency exits bypass validation queue
3. Notification: urgent alerts to trader (email, SMS, push)
4. Position closure: market orders (accept slippage for speed)
5. Logging: CRITICAL level logs for all emergency exits
6. Post-exit analysis: generate report explaining invalidation
7. Unit test: each emergency condition triggers correctly (stocks and forex)
8. Integration test: simulated invalidations cause immediate exits
9. Recovery protocol: system remains halted until manual reset after max drawdown
10. FR21 compliance: all emergency conditions implemented with asset-class awareness
11. **NEW - Forex Support:** Asset-class-aware risk limits (2% daily loss vs 3% for stocks)
12. **NEW - Forex Support:** Notional exposure limit tracking (3x equity max for forex)

## Tasks / Subtasks

- [ ] Define EmergencyExitTrigger and EmergencyExitEvent models (AC: 1, 5, 6)
  - [ ] Create file: `backend/src/models/emergency_exit.py`
  - [ ] Import required types:
    - `from decimal import Decimal`
    - `from datetime import datetime, timezone`
    - `from pydantic import BaseModel, Field`
    - `from typing import Literal, List, Dict, Any`
    - `from uuid import UUID, uuid4`
  - [ ] Define `EmergencyExitTriggerType` enum:
    - `SPRING_LOW_BREAK` - Spring invalidation level breached
    - `ICE_BREAK_AFTER_SOS` - SOS breakout invalidated (Ice broken)
    - `UTAD_HIGH_EXCEEDED` - UTAD distribution invalidated
    - `DAILY_LOSS_LIMIT` - Daily loss â‰¥3% (stocks) or â‰¥2% (forex) of account equity
    - `MAX_DRAWDOWN_LIMIT` - Max drawdown â‰¥15% from peak
    - `NOTIONAL_EXPOSURE_LIMIT` - NEW (AC: 12): Forex notional exposure > 3x equity
  - [ ] Define `EmergencyExitEvent` Pydantic model (ASSET-CLASS-AWARE - AC: 11):
    - `id: UUID` - Unique event identifier
    - `trigger_type: EmergencyExitTriggerType` - Which condition triggered
    - `asset_class: Literal["STOCK", "FOREX", "CRYPTO"] | None` - Asset class that triggered (NEW - AC: 11)
    - `symbol: str | None` - Symbol that triggered (if pattern-specific)
    - `campaign_id: UUID | None` - Campaign affected (if applicable)
    - `pattern_id: UUID | None` - Pattern that invalidated (if applicable)
    - `trigger_price: Decimal | None` - Price that caused trigger
    - `invalidation_level: Decimal | None` - Level that was breached
    - `daily_loss_pct: Decimal | None` - Daily loss % (if daily loss trigger)
    - `drawdown_pct: Decimal | None` - Drawdown % (if max drawdown trigger)
    - `notional_exposure: Decimal | None` - NEW (AC: 12): Total notional exposure (if NOTIONAL_EXPOSURE_LIMIT)
    - `notional_exposure_limit: Decimal | None` - NEW (AC: 12): Max allowed notional (3x equity for forex)
    - `affected_positions: List[UUID]` - List of position IDs to close
    - `affected_campaigns: List[UUID]` - List of campaign IDs to exit
    - `timestamp: datetime` - When trigger occurred (UTC)
    - `reason: str` - Detailed explanation of trigger (asset-class-aware messaging)
    - `metadata: Dict[str, Any]` - Additional context (current prices, account state, leverage info for forex)
    - `halt_system: bool` - Whether system should halt entirely
    - `halt_new_trades_only: bool` - Whether to only halt new trades (not existing positions)
  - [ ] Add UTC timezone validator (NFR risk mitigation)
  - [ ] Add schema example with all trigger types
  - [ ] Define `EmergencyExitResult` Pydantic model:
    - `exit_event_id: UUID` - Reference to EmergencyExitEvent
    - `positions_closed: List[UUID]` - Successfully closed positions
    - `positions_failed: List[UUID]` - Failed to close positions
    - `exit_orders: List[Dict[str, Any]]` - Market orders placed
    - `total_realized_loss: Decimal` - Total loss from exits
    - `execution_time_ms: int` - Time to execute exits
    - `timestamp: datetime` - Completion timestamp
    - `recovery_required: bool` - Manual intervention needed

- [ ] Implement EmergencyExitService core logic (AC: 1, 2, 4)
  - [ ] Create file: `backend/src/risk_management/emergency_exit_service.py`
  - [ ] Define `EmergencyExitService` class with dependencies:
    - Inject: `CampaignRepository`, `PositionRepository`, `NotificationService`, `AuditTrailRepository`
    - Store reference to `SystemStateManager` for halt control
  - [ ] Implement `async def check_spring_invalidation(pattern: Pattern, current_price: Decimal) -> EmergencyExitEvent | None`:
    - If `pattern.pattern_type == "SPRING"` and `current_price < pattern.invalidation_level`:
      - Fetch all positions in campaign linked to this pattern
      - Create `EmergencyExitEvent` with `trigger_type=SPRING_LOW_BREAK`
      - Include all campaign positions in `affected_positions`
      - Set `halt_new_trades_only=True` (don't halt entire system)
      - Return event
    - Else: return None
  - [ ] Implement `async def check_sos_invalidation(pattern: Pattern, current_price: Decimal, ice_level: Decimal) -> EmergencyExitEvent | None`:
    - If `pattern.pattern_type == "SOS"` and `current_price < ice_level`:
      - Fetch all positions in breakout campaign
      - Create `EmergencyExitEvent` with `trigger_type=ICE_BREAK_AFTER_SOS`
      - Include campaign positions in `affected_positions`
      - Set `halt_new_trades_only=True`
      - Return event
    - Else: return None
  - [ ] Implement `async def check_utad_invalidation(pattern: Pattern, current_price: Decimal) -> EmergencyExitEvent | None`:
    - If `pattern.pattern_type == "UTAD"` and `current_price > pattern.invalidation_level` (high exceeded):
      - Fetch all short positions in campaign
      - Create `EmergencyExitEvent` with `trigger_type=UTAD_HIGH_EXCEEDED`
      - Set `halt_new_trades_only=True`
      - Return event
    - Else: return None
  - [ ] Implement `async def check_daily_loss_limit(portfolio_state: PortfolioState, asset_class: Literal["STOCK", "FOREX", "CRYPTO"]) -> EmergencyExitEvent | None` (ASSET-CLASS-AWARE - AC: 11):
    - Calculate daily P&L: `(current_equity - starting_equity) / starting_equity`
    - **Asset-class-specific thresholds:**
      - STOCK: 3% daily loss threshold
      - FOREX: 2% daily loss threshold (leverage amplifies speed of loss)
      - CRYPTO: 3% daily loss threshold
    - Determine threshold based on asset_class:
      ```python
      if asset_class == "FOREX":
          threshold = -0.02  # 2% for forex
      else:
          threshold = -0.03  # 3% for stocks/crypto
      ```
    - If daily loss â‰¥ threshold:
      - Create `EmergencyExitEvent` with `trigger_type=DAILY_LOSS_LIMIT`
      - Set `asset_class=asset_class`
      - Set `daily_loss_pct=<calculated value>`
      - Set `halt_new_trades_only=True` (keep existing positions open)
      - Set `affected_positions=[]` (don't auto-close positions)
      - Set `reason` with asset-class-aware messaging:
        - FOREX: "Forex daily loss {daily_loss_pct:.1%} exceeded {threshold:.1%} threshold. Leverage amplifies moves - halting new trades to prevent further losses."
        - STOCK: "Daily loss {daily_loss_pct:.1%} exceeded {threshold:.1%} threshold. Halting new trades until review."
      - Return event
    - Else: return None
  - [ ] Implement `async def check_max_drawdown_limit(portfolio_state: PortfolioState) -> EmergencyExitEvent | None`:
    - Calculate drawdown: `(peak_equity - current_equity) / peak_equity`
    - If drawdown â‰¥ 15%:
      - Create `EmergencyExitEvent` with `trigger_type=MAX_DRAWDOWN_LIMIT`
      - Set `drawdown_pct=<calculated value>`
      - Set `halt_system=True` (halt entire system - UNIVERSAL for all asset classes)
      - Set `affected_positions=<all open positions>` (close everything)
      - Return event
    - Else: return None
  - [ ] Implement `async def check_notional_exposure_limit(portfolio_state: PortfolioState) -> EmergencyExitEvent | None` (NEW - AC: 12):
    - **Forex-specific check**: Prevent over-leveraging
    - Calculate total notional exposure: `sum(position.notional_value for position in open_positions if position.asset_class == "FOREX")`
    - Max allowed notional exposure: `portfolio_state.equity * 3.0` (3x equity limit)
    - If total_notional_exposure > max_allowed_notional:
      - Create `EmergencyExitEvent` with `trigger_type=NOTIONAL_EXPOSURE_LIMIT`
      - Set `asset_class="FOREX"`
      - Set `notional_exposure=<calculated total>`
      - Set `notional_exposure_limit=<max allowed>`
      - Set `halt_new_trades_only=True` (prevent new forex positions)
      - Set `affected_positions=[]` (don't auto-close existing positions, but warn)
      - Set `reason=f"Forex notional exposure ${notional_exposure:,.0f} exceeds 3x equity limit (${notional_exposure_limit:,.0f}). This indicates over-leveraging. No new forex positions until exposure reduces."`
      - Set `metadata` with leverage breakdown by position
      - Return event
    - Else: return None
    - **Rationale:** Forex with 50:1 leverage allows massive notional positions on small margin. This check prevents "available margin" trap where traders over-position because broker shows high "buying power".
  - [ ] Implement `async def execute_emergency_exit(event: EmergencyExitEvent) -> EmergencyExitResult`:
    - Log CRITICAL: `"EMERGENCY EXIT TRIGGERED: {event.trigger_type} - {event.reason}"`
    - If `event.halt_system`:
      - Call `SystemStateManager.halt_system(reason=event.reason)`
      - Close ALL open positions immediately
    - Elif `event.halt_new_trades_only`:
      - Call `SystemStateManager.halt_new_trades(reason=event.reason)`
    - For each position in `event.affected_positions`:
      - Place market order to close position (priority queue bypass)
      - Track successful/failed closures
    - Calculate total realized loss
    - Persist `EmergencyExitEvent` to database (audit trail)
    - Return `EmergencyExitResult`
  - [ ] Add error handling: if market order fails, retry up to 3 times with exponential backoff
  - [ ] Add timing: measure execution time from trigger to completion

- [ ] Implement SystemStateManager for halt control (AC: 9)
  - [ ] Create file: `backend/src/risk_management/system_state_manager.py`
  - [ ] Define `SystemState` enum:
    - `ACTIVE` - Normal operation
    - `NEW_TRADES_HALTED` - No new signals, existing positions continue
    - `SYSTEM_HALTED` - Complete shutdown, manual recovery required
  - [ ] Define `SystemStateManager` singleton class:
    - `_state: SystemState = SystemState.ACTIVE` (in-memory state)
    - `_halt_reason: str | None` - Why system halted
    - `_halt_timestamp: datetime | None` - When halt occurred
  - [ ] Implement `def halt_new_trades(reason: str) -> None`:
    - Set `_state = SystemState.NEW_TRADES_HALTED`
    - Store reason and timestamp
    - Log WARNING: "New trades halted: {reason}"
  - [ ] Implement `def halt_system(reason: str) -> None`:
    - Set `_state = SystemState.SYSTEM_HALTED`
    - Store reason and timestamp
    - Log CRITICAL: "SYSTEM HALTED: {reason}"
  - [ ] Implement `def manual_reset(admin_user: str, notes: str) -> None`:
    - Require admin authentication (future: check user role)
    - Set `_state = SystemState.ACTIVE`
    - Clear halt_reason and halt_timestamp
    - Log WARNING: "System manually reset by {admin_user}: {notes}"
    - Persist reset event to audit trail
  - [ ] Implement `def is_active() -> bool`: Return `_state == SystemState.ACTIVE`
  - [ ] Implement `def can_generate_signals() -> bool`: Return `_state != SystemState.SYSTEM_HALTED`
  - [ ] Implement `def get_state() -> dict`: Return current state with reason/timestamp
  - [ ] Add persistence: save state to Redis or PostgreSQL for durability across restarts

- [ ] Integrate emergency exit checks into MasterOrchestrator (AC: 1, 2)
  - [ ] Modify file: `backend/src/pattern_engine/orchestrator.py` (Story 8.1/8.10)
  - [ ] Inject `EmergencyExitService` into `MasterOrchestrator.__init__()`
  - [ ] Add method: `async def monitor_emergency_conditions(symbol: str, current_bar: OHLCVBar) -> None`:
    - Fetch active patterns for symbol with open campaigns
    - For each pattern with `test_confirmed=True`:
      - Call `emergency_exit_service.check_spring_invalidation(pattern, current_bar.close)`
      - Call `emergency_exit_service.check_sos_invalidation(pattern, current_bar.close, ice_level)`
      - Call `emergency_exit_service.check_utad_invalidation(pattern, current_bar.close)`
    - If any check returns `EmergencyExitEvent`:
      - Call `emergency_exit_service.execute_emergency_exit(event)`
      - Emit WebSocket message: `emergency_exit` with event details
  - [ ] Add method: `async def monitor_portfolio_risk() -> None`:
    - Fetch current portfolio state
    - Call `emergency_exit_service.check_daily_loss_limit(portfolio_state)`
    - Call `emergency_exit_service.check_max_drawdown_limit(portfolio_state)`
    - If any check returns event, execute emergency exit
  - [ ] Call `monitor_emergency_conditions()` on EVERY bar ingestion (before pattern detection)
  - [ ] Call `monitor_portfolio_risk()` every 5 minutes (scheduled task)
  - [ ] Before generating new signals, check: `if not system_state_manager.can_generate_signals(): skip signal generation`

- [ ] Implement emergency exit notifications (AC: 3)
  - [ ] Modify file: `backend/src/notifications/service.py`
  - [ ] Add method: `async def send_emergency_exit_alert(event: EmergencyExitEvent, result: EmergencyExitResult) -> None`:
    - Construct urgent message:
      - Subject: "ðŸš¨ EMERGENCY EXIT TRIGGERED: {trigger_type}"
      - Body: Include trigger reason, affected positions, realized loss, timestamp
    - Send SMS via Twilio (high priority)
    - Send Slack webhook with @channel mention
    - Send email with HIGH importance flag
    - If `event.halt_system=True`, include recovery instructions in message
  - [ ] Add retry logic: if notification fails, retry up to 5 times
  - [ ] Log notification success/failure to audit trail
  - [ ] Test notification delivery with mock event

- [ ] Generate post-exit analysis report (AC: 6)
  - [ ] Create file: `backend/src/risk_management/exit_analysis.py`
  - [ ] Define `ExitAnalysisReport` Pydantic model:
    - `exit_event_id: UUID`
    - `trigger_summary: str` - Human-readable summary
    - `pattern_details: Dict[str, Any]` - Pattern that failed (if applicable)
    - `campaign_summary: Dict[str, Any]` - Campaign stats before exit
    - `positions_closed: List[Dict[str, Any]]` - Each position's P&L
    - `total_realized_loss: Decimal`
    - `lessons_learned: str` - Automated analysis of what went wrong
    - `timestamp: datetime`
  - [ ] Implement `async def generate_exit_analysis(event: EmergencyExitEvent, result: EmergencyExitResult) -> ExitAnalysisReport`:
    - Fetch pattern/campaign data from database
    - Calculate P&L for each closed position
    - Analyze trigger conditions (e.g., "Spring low at $148 broke when price hit $147.50")
    - Generate lessons_learned text based on trigger type
    - Return structured report
  - [ ] Persist report to database: `emergency_exit_reports` table
  - [ ] Add API endpoint: `GET /api/v1/emergency-exits/{event_id}/report`
  - [ ] Optionally: attach report PDF to notification email

- [ ] Add emergency exit endpoints to API (AC: 9)
  - [ ] Create file: `backend/src/api/routes/emergency_exits.py`
  - [ ] Define `GET /api/v1/emergency-exits` endpoint:
    - Query params: `?trigger_type=<type>&since=<datetime>&limit=50`
    - Return paginated list of `EmergencyExitEvent` objects
  - [ ] Define `GET /api/v1/emergency-exits/{event_id}` endpoint:
    - Return single `EmergencyExitEvent` with full details
    - Include `EmergencyExitResult` if execution completed
  - [ ] Define `POST /api/v1/system/reset` endpoint (manual recovery):
    - Request body: `{"admin_user": "username", "reset_notes": "..."}`
    - Call `SystemStateManager.manual_reset()`
    - Require authentication (future: admin role check)
    - Return new system state
  - [ ] Define `GET /api/v1/system/state` endpoint:
    - Return current `SystemState` with halt reason/timestamp
    - Return list of halted features (new trades, all trading)
  - [ ] Register routes in `backend/src/api/main.py`

- [ ] Create database migration for emergency exit tables (AC: 5, 6)
  - [ ] Create Alembic migration: `backend/alembic/versions/008_emergency_exits.py`
  - [ ] Define `emergency_exit_events` table:
    - `id UUID PRIMARY KEY`
    - `trigger_type VARCHAR(30) NOT NULL`
    - `symbol VARCHAR(20)`
    - `campaign_id UUID REFERENCES campaigns(id)`
    - `pattern_id UUID REFERENCES patterns(id)`
    - `trigger_price NUMERIC(18,8)`
    - `invalidation_level NUMERIC(18,8)`
    - `daily_loss_pct NUMERIC(6,4)`
    - `drawdown_pct NUMERIC(6,4)`
    - `affected_positions JSONB NOT NULL` - List of position UUIDs
    - `affected_campaigns JSONB NOT NULL` - List of campaign UUIDs
    - `timestamp TIMESTAMPTZ NOT NULL`
    - `reason TEXT NOT NULL`
    - `metadata JSONB`
    - `halt_system BOOLEAN DEFAULT FALSE`
    - `halt_new_trades_only BOOLEAN DEFAULT FALSE`
    - `created_at TIMESTAMPTZ DEFAULT NOW()`
  - [ ] Define `emergency_exit_results` table:
    - `id UUID PRIMARY KEY`
    - `exit_event_id UUID REFERENCES emergency_exit_events(id)`
    - `positions_closed JSONB` - List of successfully closed position UUIDs
    - `positions_failed JSONB` - List of failed position UUIDs
    - `exit_orders JSONB` - Market orders placed
    - `total_realized_loss NUMERIC(12,2)`
    - `execution_time_ms INT`
    - `timestamp TIMESTAMPTZ`
    - `recovery_required BOOLEAN DEFAULT FALSE`
  - [ ] Define `emergency_exit_reports` table:
    - `id UUID PRIMARY KEY`
    - `exit_event_id UUID REFERENCES emergency_exit_events(id) UNIQUE`
    - `trigger_summary TEXT`
    - `pattern_details JSONB`
    - `campaign_summary JSONB`
    - `positions_closed JSONB`
    - `total_realized_loss NUMERIC(12,2)`
    - `lessons_learned TEXT`
    - `timestamp TIMESTAMPTZ`
  - [ ] Create indexes:
    - `CREATE INDEX idx_exit_events_trigger ON emergency_exit_events(trigger_type, timestamp DESC);`
    - `CREATE INDEX idx_exit_events_symbol ON emergency_exit_events(symbol);`
  - [ ] Run migration: `alembic upgrade head`

- [ ] Write unit tests for each emergency trigger (AC: 7)
  - [ ] Create test file: `backend/tests/unit/risk_management/test_emergency_exit_service.py`
  - [ ] Test: `test_spring_low_break_triggers_exit()`
    - Create Spring pattern with `invalidation_level=$148.00`
    - Call `check_spring_invalidation(pattern, current_price=$147.50)`
    - Assert `EmergencyExitEvent` returned with `trigger_type=SPRING_LOW_BREAK`
    - Assert `affected_positions` includes all campaign positions
    - Assert `halt_new_trades_only=True`
  - [ ] Test: `test_spring_above_invalidation_no_trigger()`
    - Create Spring pattern with `invalidation_level=$148.00`
    - Call `check_spring_invalidation(pattern, current_price=$149.00)`
    - Assert `None` returned (no trigger)
  - [ ] Test: `test_ice_break_after_sos_triggers_exit()`
    - Create SOS pattern with Ice level at $155
    - Call `check_sos_invalidation(pattern, current_price=$154.50, ice_level=$155.00)`
    - Assert `EmergencyExitEvent` returned with `trigger_type=ICE_BREAK_AFTER_SOS`
  - [ ] Test: `test_utad_high_exceeded_triggers_exit()`
    - Create UTAD pattern with `invalidation_level=$180.00` (high)
    - Call `check_utad_invalidation(pattern, current_price=$181.00)`
    - Assert `EmergencyExitEvent` returned with `trigger_type=UTAD_HIGH_EXCEEDED`
  - [ ] Test: `test_daily_loss_3pct_halts_new_trades()`
    - Create portfolio state with starting_equity=$10,000, current_equity=$9,700 (3% loss)
    - Call `check_daily_loss_limit(portfolio_state)`
    - Assert `EmergencyExitEvent` returned with `trigger_type=DAILY_LOSS_LIMIT`
    - Assert `halt_new_trades_only=True`
    - Assert `affected_positions=[]` (don't close positions)
  - [ ] Test: `test_daily_loss_2_9pct_no_trigger()`
    - Create portfolio state with 2.9% loss
    - Assert `None` returned (below threshold)
  - [ ] Test: `test_max_drawdown_15pct_halts_system()`
    - Create portfolio state with peak_equity=$12,000, current_equity=$10,200 (15% drawdown)
    - Call `check_max_drawdown_limit(portfolio_state)`
    - Assert `EmergencyExitEvent` returned with `trigger_type=MAX_DRAWDOWN_LIMIT`
    - Assert `halt_system=True`
    - Assert `affected_positions` includes ALL open positions
  - [ ] Test: `test_emergency_exit_execution_closes_positions()`
    - Mock `PositionRepository`, `OrderService`
    - Create `EmergencyExitEvent` with 3 affected positions
    - Call `execute_emergency_exit(event)`
    - Assert 3 market orders placed
    - Assert `EmergencyExitResult` contains successfully closed positions
    - Assert CRITICAL log emitted

- [ ] Write unit tests for SystemStateManager (AC: 9)
  - [ ] Create test file: `backend/tests/unit/risk_management/test_system_state_manager.py`
  - [ ] Test: `test_initial_state_is_active()`
    - Create new `SystemStateManager`
    - Assert `is_active() == True`
    - Assert `can_generate_signals() == True`
  - [ ] Test: `test_halt_new_trades_disables_signals()`
    - Call `halt_new_trades(reason="Daily loss limit")`
    - Assert `is_active() == False`
    - Assert `can_generate_signals() == True` (existing positions continue)
    - Assert `get_state()['state'] == "NEW_TRADES_HALTED"`
  - [ ] Test: `test_halt_system_disables_everything()`
    - Call `halt_system(reason="Max drawdown 15%")`
    - Assert `is_active() == False`
    - Assert `can_generate_signals() == False`
    - Assert `get_state()['state'] == "SYSTEM_HALTED"`
  - [ ] Test: `test_manual_reset_restores_active_state()`
    - Call `halt_system(reason="Test")`
    - Call `manual_reset(admin_user="admin", notes="Testing recovery")`
    - Assert `is_active() == True`
    - Assert `can_generate_signals() == True`
  - [ ] Test: `test_halt_reason_and_timestamp_recorded()`
    - Call `halt_system(reason="Max drawdown")`
    - State = `get_state()`
    - Assert `state['halt_reason'] == "Max drawdown"`
    - Assert `state['halt_timestamp']` is recent datetime

- [ ] Write integration tests for emergency exit workflow (AC: 8)
  - [ ] Create test file: `backend/tests/integration/risk_management/test_emergency_exit_integration.py`
  - [ ] Test: `test_spring_invalidation_closes_campaign_positions()`
    - Set up: Create Spring pattern with campaign containing 3 positions
    - Simulate bar with price below spring low
    - Assert: MasterOrchestrator detects invalidation
    - Assert: Emergency exit event created
    - Assert: All 3 campaign positions closed with market orders
    - Assert: CRITICAL log emitted
    - Assert: Notification sent (mock Twilio/Slack)
    - Assert: Post-exit analysis report generated
  - [ ] Test: `test_sos_ice_break_closes_breakout_positions()`
    - Set up: Create SOS pattern with breakout campaign
    - Simulate bar with price below Ice level
    - Assert: Emergency exit triggered
    - Assert: Breakout positions closed
    - Assert: New trades halted for this symbol
  - [ ] Test: `test_daily_loss_limit_halts_new_signals()`
    - Set up: Portfolio with 3% daily loss
    - Simulate signal generation attempt
    - Assert: `check_daily_loss_limit()` triggers
    - Assert: New signals blocked (system_state_manager.can_generate_signals() == True but new trades halted)
    - Assert: Existing positions remain open
    - Assert: Notification sent
  - [ ] Test: `test_max_drawdown_halts_system_and_closes_all()`
    - Set up: Portfolio with 15% drawdown
    - Simulate risk monitoring check
    - Assert: `check_max_drawdown_limit()` triggers
    - Assert: System halted completely
    - Assert: ALL open positions closed
    - Assert: Signal generation disabled
    - Assert: Manual reset required to resume
  - [ ] Test: `test_manual_reset_after_max_drawdown()`
    - Trigger max drawdown halt
    - Call `POST /api/v1/system/reset` with admin credentials
    - Assert: System state returns to ACTIVE
    - Assert: Signal generation re-enabled
    - Assert: Reset logged to audit trail

- [ ] Add emergency exit monitoring to orchestrator background tasks
  - [ ] Modify file: `backend/src/api/main.py`
  - [ ] Add FastAPI startup event handler:
    - Schedule background task: `run_portfolio_risk_monitoring_loop()`
    - Task runs every 5 minutes
    - Calls `orchestrator.monitor_portfolio_risk()`
  - [ ] Add lifecycle hook: on EVERY bar ingestion, call `monitor_emergency_conditions()`
    - This ensures pattern invalidations detected in real-time
  - [ ] Add graceful shutdown: on SIGTERM, log system state before exit

- [ ] Implement WebSocket emergency exit messages (AC: 3)
  - [ ] Modify file: `backend/src/api/websocket.py`
  - [ ] Define WebSocket message type: `emergency_exit`
  - [ ] When `EmergencyExitEvent` triggered, broadcast to all connected clients:
    ```json
    {
      "type": "emergency_exit",
      "data": {
        "event_id": "uuid",
        "trigger_type": "SPRING_LOW_BREAK",
        "symbol": "AAPL",
        "reason": "Spring low at $148 broken at $147.50",
        "affected_positions": ["uuid1", "uuid2"],
        "timestamp": "2024-03-13T14:35:00Z",
        "halt_system": false,
        "halt_new_trades_only": true
      }
    }
    ```
  - [ ] Frontend should display emergency alert banner immediately
  - [ ] Frontend should refresh positions/campaigns to reflect closures

- [ ] Document emergency exit conditions in architecture docs
  - [ ] Update file: `docs/architecture/6-components.md#6.1.5`:
    - Add `EmergencyExitService` component description
    - List all 5 trigger types with thresholds
    - Explain bypass logic (skips validation queue)
  - [ ] Update file: `docs/architecture/8-core-workflows.md`:
    - Add emergency exit workflow diagram (trigger â†’ execute â†’ notify â†’ report)
    - Show decision tree for halt_system vs halt_new_trades_only
  - [ ] Update file: `docs/architecture/16-error-handling-strategy.md`:
    - Document recovery protocol for max drawdown halt
    - Explain manual reset procedure

- [ ] Add comprehensive docstrings and examples
  - [ ] Add module docstring to `emergency_exit_service.py`:
    - Explain FR21 emergency exit conditions
    - List all trigger types with examples
    - Provide usage example
  - [ ] Add class docstring to `EmergencyExitService`:
    - Explain check methods and execute method
    - Reference FR21 requirement
  - [ ] Add method docstrings for all check methods:
    - Explain trigger conditions
    - Show example trigger scenarios
    - Document return values

- [ ] Create CLI utility to view emergency exit history
  - [ ] Create file: `backend/src/cli/emergency_exits.py`
  - [ ] Add command: `python -m backend.src.cli.emergency_exits list`
    - Fetch recent emergency exit events
    - Display table: Timestamp, Trigger Type, Symbol, Reason, Positions Closed
  - [ ] Add command: `python -m backend.src.cli.emergency_exits show <event_id>`
    - Display full emergency exit event details
    - Show exit result (positions closed, realized loss)
    - Show post-exit analysis report
  - [ ] Add command: `python -m backend.src.cli.emergency_exits reset`
    - Interactive manual system reset
    - Prompt for admin user and reset notes
    - Confirm reset action

## Dev Notes

### Previous Story Insights

**From Story 8.8 (Trade Signal Output Format):**
- TradeSignal contains `validation_chain` for audit trail (FR25)
- TradeSignal includes `campaign_id` linking signals to campaigns
- Status field tracks signal lifecycle: PENDING â†’ APPROVED â†’ FILLED/STOPPED/TARGET_HIT
- Emergency exits will update signal status to STOPPED with exit reason
- All price fields use Decimal type (NFR20: fixed-point arithmetic)

**From Story 8.2 (Multi-Stage Validation Workflow):**
- Validation chain flows through 5 stages: Volume â†’ Phase â†’ Levels â†’ Risk â†’ Strategy
- Early exit on FAIL prevents signal generation
- Emergency exits BYPASS this validation chain entirely (AC: 2)
- ValidationChain provides audit trail of why signals were approved

**From Story 8.6 (Risk Validation Stage):**
- RiskValidator enforces portfolio heat limits (FR18: 10% max)
- Campaign risk limited to 5% of account
- Emergency exits monitor these same metrics in real-time
- Daily loss and max drawdown checks extend risk validation beyond individual trades

**From Epic 9 (Campaign Management):**
- Campaigns group multiple positions under one trading range/pattern
- Campaign invalidation (Spring low break) requires closing ALL campaign positions
- Campaign tracking includes: entries, average entry, total allocation, current risk
- Emergency exit events will reference `campaign_id` to close all campaign positions

**Key Integration Points:**
- EmergencyExitService integrates with MasterOrchestrator (Story 8.1/8.10)
- Emergency exits bypass normal SignalGenerator flow
- SystemStateManager controls whether new signals can be generated
- NotificationService sends urgent alerts (SMS, Slack, Email)
- Audit trail logs all emergency exit events for compliance

### Functional Requirements

**FR21: Emergency Exit Conditions** [Source: docs/prd/requirements.md#FR21]
> "The system shall implement emergency exit conditions: exit immediately if spring low breaks, Ice breaks after SOS, UTAD high exceeded, daily loss â‰¥3%, or max drawdown â‰¥15%"

This story implements all 5 emergency exit conditions:
1. **Spring Low Break**: If price breaks below Spring invalidation level â†’ exit ALL campaign positions
2. **Ice Break After SOS**: If SOS breakout fails and price breaks below Ice â†’ exit breakout positions
3. **UTAD High Exceeded**: If distribution UTAD high is exceeded â†’ exit short positions
4. **Daily Loss â‰¥3%**: If account loses 3% in single day â†’ halt new trades (keep positions)
5. **Max Drawdown â‰¥15%**: If account drawdown from peak â‰¥15% â†’ halt system, close ALL positions

Critical: Emergency exits BYPASS normal validation queue for immediate execution (AC: 2)

**FR18: Risk Limits** [Source: docs/prd/requirements.md#FR18]
> "The system shall enforce risk limits: 2% per trade, 5% per campaign, 10% portfolio heat, 6% correlated sector"

Emergency exits extend FR18 by monitoring portfolio-level risk in real-time:
- Daily loss check ensures account doesn't exceed 3% daily loss
- Max drawdown check ensures account never exceeds 15% drawdown from peak
- These are "circuit breaker" protections beyond individual trade risk

**FR22: Trade Signal Output** [Source: docs/prd/requirements.md#FR22]
> "The system shall generate trade signals containing: symbol, pattern type, phase, entry price, stop loss, target levels, position size, risk amount, R-multiple, confidence score, campaign ID, and timestamp"

Emergency exits update TradeSignal status:
- Signals with open positions updated to status=STOPPED
- Exit reason recorded in signal metadata
- Campaign ID links emergency exit to affected signals

**FR25: Trade Decision Audit Log** [Source: docs/prd/requirements.md#FR25]
> "The system shall maintain trade decision audit log: pattern detection rationale, validation chain results, rejection reasons, confidence calculations, and approval/rejection timestamps"

Emergency exits extend audit trail:
- `emergency_exit_events` table logs all triggers
- `emergency_exit_results` table logs execution outcomes
- `emergency_exit_reports` table provides post-exit analysis
- All events logged at CRITICAL level for compliance

### Data Models

**EmergencyExitEvent Structure** [Source: Story 8.9 AC, docs/architecture/4-data-models.md]

```python
from decimal import Decimal
from datetime import datetime, timezone
from pydantic import BaseModel, Field, validator
from typing import Literal, List, Dict, Any
from uuid import UUID, uuid4

class EmergencyExitTriggerType(str, Enum):
    """Emergency exit trigger types (FR21)"""
    SPRING_LOW_BREAK = "SPRING_LOW_BREAK"
    ICE_BREAK_AFTER_SOS = "ICE_BREAK_AFTER_SOS"
    UTAD_HIGH_EXCEEDED = "UTAD_HIGH_EXCEEDED"
    DAILY_LOSS_LIMIT = "DAILY_LOSS_LIMIT"
    MAX_DRAWDOWN_LIMIT = "MAX_DRAWDOWN_LIMIT"


class EmergencyExitEvent(BaseModel):
    """
    Emergency exit event model (FR21).

    Records trigger conditions and affected positions for immediate exit.
    """
    id: UUID = Field(default_factory=uuid4)
    trigger_type: EmergencyExitTriggerType = Field(..., description="Emergency condition that triggered")
    symbol: str | None = Field(None, description="Symbol that triggered (if pattern-specific)")
    campaign_id: UUID | None = Field(None, description="Campaign affected")
    pattern_id: UUID | None = Field(None, description="Pattern that invalidated")

    # Trigger details
    trigger_price: Decimal | None = Field(None, description="Price that caused trigger")
    invalidation_level: Decimal | None = Field(None, description="Level that was breached")
    daily_loss_pct: Decimal | None = Field(None, ge=Decimal("0.0"), le=Decimal("100.0"), description="Daily loss percentage")
    drawdown_pct: Decimal | None = Field(None, ge=Decimal("0.0"), le=Decimal("100.0"), description="Drawdown from peak")

    # Affected entities
    affected_positions: List[UUID] = Field(default_factory=list, description="Position IDs to close")
    affected_campaigns: List[UUID] = Field(default_factory=list, description="Campaign IDs to exit")

    # Timing and context
    timestamp: datetime = Field(..., description="When trigger occurred (UTC)")
    reason: str = Field(..., description="Detailed explanation of trigger")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional context")

    # System control
    halt_system: bool = Field(default=False, description="Halt entire system")
    halt_new_trades_only: bool = Field(default=False, description="Only halt new trades")

    @validator('timestamp', pre=True)
    def ensure_utc(cls, v):
        """Enforce UTC timezone (NFR risk mitigation)"""
        if v.tzinfo is None:
            return v.replace(tzinfo=timezone.utc)
        return v.astimezone(timezone.utc)

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }
        schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "trigger_type": "SPRING_LOW_BREAK",
                "symbol": "AAPL",
                "campaign_id": "660e8400-e29b-41d4-a716-446655440000",
                "pattern_id": "770e8400-e29b-41d4-a716-446655440000",
                "trigger_price": "147.50",
                "invalidation_level": "148.00",
                "affected_positions": ["pos-uuid-1", "pos-uuid-2"],
                "affected_campaigns": ["camp-uuid-1"],
                "timestamp": "2024-03-13T14:35:00Z",
                "reason": "Spring low at $148.00 broken when price hit $147.50",
                "halt_system": False,
                "halt_new_trades_only": True
            }
        }


class EmergencyExitResult(BaseModel):
    """
    Result of executing emergency exit.

    Records positions closed, orders placed, and execution metrics.
    """
    exit_event_id: UUID = Field(..., description="Reference to EmergencyExitEvent")
    positions_closed: List[UUID] = Field(default_factory=list, description="Successfully closed positions")
    positions_failed: List[UUID] = Field(default_factory=list, description="Failed to close positions")
    exit_orders: List[Dict[str, Any]] = Field(default_factory=list, description="Market orders placed")
    total_realized_loss: Decimal = Field(..., description="Total loss from exits")
    execution_time_ms: int = Field(..., description="Time to execute exits")
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    recovery_required: bool = Field(default=False, description="Manual intervention needed")

    class Config:
        json_encoders = {Decimal: str, datetime: lambda v: v.isoformat()}


class SystemState(str, Enum):
    """System operational state"""
    ACTIVE = "ACTIVE"
    NEW_TRADES_HALTED = "NEW_TRADES_HALTED"
    SYSTEM_HALTED = "SYSTEM_HALTED"
```

### File Locations

**Project Structure Reference** [Source: docs/architecture/10-unified-project-structure.md]

Files to create/modify:
```
backend/src/
â”œâ”€â”€ models/
â”‚   â””â”€â”€ emergency_exit.py              # NEW: EmergencyExitEvent, EmergencyExitResult, SystemState
â”œâ”€â”€ risk_management/
â”‚   â”œâ”€â”€ emergency_exit_service.py      # NEW: EmergencyExitService (core logic)
â”‚   â”œâ”€â”€ system_state_manager.py        # NEW: SystemStateManager (halt control)
â”‚   â””â”€â”€ exit_analysis.py               # NEW: Post-exit analysis report generation
â”œâ”€â”€ pattern_engine/
â”‚   â””â”€â”€ orchestrator.py                # MODIFY: Integrate emergency exit checks
â”œâ”€â”€ api/routes/
â”‚   â””â”€â”€ emergency_exits.py             # NEW: Emergency exit API endpoints
â”œâ”€â”€ notifications/
â”‚   â””â”€â”€ service.py                     # MODIFY: Add emergency exit alerts
â”œâ”€â”€ cli/
â”‚   â””â”€â”€ emergency_exits.py             # NEW: CLI for emergency exit management
â””â”€â”€ api/
    â”œâ”€â”€ main.py                        # MODIFY: Add background risk monitoring task
    â””â”€â”€ websocket.py                   # MODIFY: Add emergency_exit WebSocket message

backend/tests/
â”œâ”€â”€ unit/risk_management/
â”‚   â”œâ”€â”€ test_emergency_exit_service.py # NEW: Unit tests for emergency triggers
â”‚   â””â”€â”€ test_system_state_manager.py   # NEW: Unit tests for state management
â””â”€â”€ integration/risk_management/
    â””â”€â”€ test_emergency_exit_integration.py # NEW: Integration tests

backend/alembic/versions/
â””â”€â”€ 008_emergency_exits.py             # NEW: Database migration

docs/architecture/
â”œâ”€â”€ 6-components.md                    # UPDATE: Document EmergencyExitService
â”œâ”€â”€ 8-core-workflows.md                # UPDATE: Add emergency exit workflow
â””â”€â”€ 16-error-handling-strategy.md      # UPDATE: Document recovery protocol
```

### Component Specifications

**EmergencyExitService Integration** [Source: Story 8.9 AC, docs/architecture/6-components.md#6.1.5]

EmergencyExitService monitors 5 conditions in real-time:

```python
class EmergencyExitService:
    """
    Monitors emergency exit conditions (FR21) and executes immediate exits.

    Bypasses normal validation queue for speed.
    """

    def __init__(
        self,
        campaign_repo: CampaignRepository,
        position_repo: PositionRepository,
        notification_service: NotificationService,
        audit_trail_repo: AuditTrailRepository,
        system_state_manager: SystemStateManager
    ):
        self.campaign_repo = campaign_repo
        self.position_repo = position_repo
        self.notification_service = notification_service
        self.audit_trail_repo = audit_trail_repo
        self.system_state = system_state_manager

    async def check_spring_invalidation(
        self,
        pattern: Pattern,
        current_price: Decimal
    ) -> EmergencyExitEvent | None:
        """
        Check if Spring invalidation level breached (FR21).

        Spring invalidation: price breaks below spring low.
        Action: Exit ALL campaign positions immediately.
        """
        if pattern.pattern_type != "SPRING":
            return None

        if current_price < pattern.invalidation_level:
            # Fetch all positions in this campaign
            campaign = await self.campaign_repo.get_by_pattern(pattern.id)
            positions = await self.position_repo.get_open_by_campaign(campaign.id)

            return EmergencyExitEvent(
                trigger_type=EmergencyExitTriggerType.SPRING_LOW_BREAK,
                symbol=pattern.symbol,
                campaign_id=campaign.id,
                pattern_id=pattern.id,
                trigger_price=current_price,
                invalidation_level=pattern.invalidation_level,
                affected_positions=[p.id for p in positions],
                affected_campaigns=[campaign.id],
                timestamp=datetime.now(timezone.utc),
                reason=f"Spring low at ${pattern.invalidation_level} broken when price hit ${current_price}",
                halt_new_trades_only=True  # Don't halt system, just this campaign
            )

        return None

    async def execute_emergency_exit(
        self,
        event: EmergencyExitEvent
    ) -> EmergencyExitResult:
        """
        Execute emergency exit immediately (FR21 AC: 2, 4).

        Bypasses validation queue, uses market orders for speed.
        """
        start_time = time.time()

        # Log CRITICAL (FR21 AC: 5)
        logger.critical(
            "EMERGENCY EXIT TRIGGERED",
            trigger_type=event.trigger_type,
            symbol=event.symbol,
            reason=event.reason,
            affected_positions=len(event.affected_positions)
        )

        # Halt system if required (FR21 AC: 1)
        if event.halt_system:
            self.system_state.halt_system(reason=event.reason)
        elif event.halt_new_trades_only:
            self.system_state.halt_new_trades(reason=event.reason)

        # Close positions immediately (FR21 AC: 4)
        positions_closed = []
        positions_failed = []
        exit_orders = []
        total_loss = Decimal("0.0")

        for position_id in event.affected_positions:
            try:
                # Place market order (accept slippage for speed)
                order = await self.order_service.place_market_order(
                    position_id=position_id,
                    order_type="CLOSE",
                    priority="EMERGENCY"  # Bypass validation queue
                )
                exit_orders.append(order.dict())
                positions_closed.append(position_id)

                # Calculate realized loss
                position = await self.position_repo.get(position_id)
                total_loss += position.unrealized_pnl

            except Exception as e:
                logger.error(f"Failed to close position {position_id}: {e}")
                positions_failed.append(position_id)

        # Persist event to database (FR25 audit trail)
        await self.audit_trail_repo.log_emergency_exit(event)

        # Send notifications (FR21 AC: 3)
        result = EmergencyExitResult(
            exit_event_id=event.id,
            positions_closed=positions_closed,
            positions_failed=positions_failed,
            exit_orders=exit_orders,
            total_realized_loss=total_loss,
            execution_time_ms=int((time.time() - start_time) * 1000),
            recovery_required=event.halt_system
        )

        await self.notification_service.send_emergency_exit_alert(event, result)

        # Generate post-exit analysis (FR21 AC: 6)
        await self.exit_analysis_service.generate_exit_analysis(event, result)

        return result
```

**MasterOrchestrator Integration** [Source: Story 8.1, 8.10, docs/architecture/6-components.md#6.1.4]

MasterOrchestrator monitors emergency conditions on EVERY bar:

```python
class MasterOrchestrator:
    async def on_bar_ingested(self, symbol: str, bar: OHLCVBar) -> None:
        """
        Called on every new bar (real-time or backtest).

        CRITICAL: Emergency exit checks run BEFORE pattern detection.
        """
        # Step 1: Check emergency exit conditions (FR21)
        await self.monitor_emergency_conditions(symbol, bar)

        # Step 2: Check if system can continue
        if not self.system_state.can_generate_signals():
            logger.warning(f"System halted, skipping analysis for {symbol}")
            return

        # Step 3: Normal pattern detection flow
        await self.analyze_symbol(symbol, bar)

    async def monitor_emergency_conditions(
        self,
        symbol: str,
        current_bar: OHLCVBar
    ) -> None:
        """
        Monitor pattern invalidation conditions (FR21 AC: 1).

        Checks Spring/SOS/UTAD invalidation levels.
        """
        # Fetch active patterns with open campaigns
        patterns = await self.pattern_repo.get_active_with_campaigns(symbol)

        for pattern in patterns:
            # Check pattern-specific invalidations
            event = None

            if pattern.pattern_type == "SPRING":
                event = await self.emergency_exit.check_spring_invalidation(
                    pattern, current_bar.close
                )

            elif pattern.pattern_type == "SOS":
                ice_level = await self.trading_range_service.get_ice_level(
                    pattern.trading_range_id
                )
                event = await self.emergency_exit.check_sos_invalidation(
                    pattern, current_bar.close, ice_level
                )

            elif pattern.pattern_type == "UTAD":
                event = await self.emergency_exit.check_utad_invalidation(
                    pattern, current_bar.close
                )

            # Execute emergency exit if triggered
            if event:
                result = await self.emergency_exit.execute_emergency_exit(event)

                # Broadcast WebSocket message
                await self.websocket_manager.broadcast({
                    "type": "emergency_exit",
                    "data": event.dict()
                })
```

### API Specifications

**Emergency Exit Endpoints** [Source: Story 8.9 AC, docs/architecture/5-api-specification.md]

```typescript
// GET /api/v1/emergency-exits
// Query params: ?trigger_type=SPRING_LOW_BREAK&since=2024-03-13T00:00:00Z&limit=50
{
  "data": [
    {
      "id": "uuid",
      "trigger_type": "SPRING_LOW_BREAK",
      "symbol": "AAPL",
      "campaign_id": "camp-uuid",
      "pattern_id": "pat-uuid",
      "trigger_price": "147.50",
      "invalidation_level": "148.00",
      "affected_positions": ["pos-uuid-1", "pos-uuid-2"],
      "timestamp": "2024-03-13T14:35:00Z",
      "reason": "Spring low at $148.00 broken when price hit $147.50",
      "halt_system": false,
      "halt_new_trades_only": true
    }
  ],
  "pagination": {...}
}

// GET /api/v1/emergency-exits/{event_id}
// Returns single EmergencyExitEvent with EmergencyExitResult

// POST /api/v1/system/reset
// Request body:
{
  "admin_user": "username",
  "reset_notes": "Reviewed drawdown, ready to resume trading"
}
// Response:
{
  "state": "ACTIVE",
  "previous_state": "SYSTEM_HALTED",
  "halt_reason": "Max drawdown 15%",
  "reset_by": "username",
  "reset_at": "2024-03-13T15:00:00Z"
}

// GET /api/v1/system/state
// Response:
{
  "state": "NEW_TRADES_HALTED",
  "halt_reason": "Daily loss limit exceeded (3.2%)",
  "halt_timestamp": "2024-03-13T14:30:00Z",
  "can_generate_signals": false,
  "active_positions": 5
}
```

### Testing Requirements

**Testing Framework** [Source: docs/architecture/12-testing-strategy.md]
- Backend: pytest 8.0+ with async support
- Unit tests: Test each emergency trigger independently
- Integration tests: Test full workflow (trigger â†’ execute â†’ notify â†’ report)
- Mock external dependencies: Order service, notification service

**Test Coverage Goals:**
- EmergencyExitService: 100% coverage (all 5 trigger types)
- SystemStateManager: 100% coverage (all state transitions)
- Emergency exit execution: 100% (market orders, notifications, audit logs)
- Integration tests: End-to-end for each trigger type

### Technical Constraints

**Fixed-Point Arithmetic** [Source: docs/architecture/15-coding-standards.md, NFR20]
- All price fields use `Decimal` type (not float)
- Trigger comparisons: `current_price < invalidation_level` uses Decimal
- Daily loss/drawdown calculations use Decimal for precision

**UTC Timestamps** [Source: docs/architecture/4-data-models.md#4.1]
- All datetime fields must be UTC timezone
- Use `@validator` to enforce UTC on timestamp fields
- ISO 8601 format in JSON: "2024-03-13T14:30:00Z"

**Immediate Execution** [Source: FR21]
- Emergency exits bypass validation queue (priority execution)
- Market orders used (accept slippage for speed)
- Execution time target: <500ms from trigger to order placement

**Audit Trail** [Source: FR25]
- All emergency exit events logged to database (immutable)
- CRITICAL level logs for all triggers
- Post-exit analysis reports persisted
- Notifications sent with full context

### Dependencies

**Python Libraries** [Source: docs/architecture/3-tech-stack.md]
- Python 3.11+ (Decimal, timezone utilities, asyncio)
- Pydantic 2.5+ (model validation, JSON serialization)
- FastAPI 0.109+ (API endpoints, background tasks)
- structlog 24.1+ (CRITICAL level logging)
- Twilio SDK (SMS notifications)
- Slack SDK (Slack webhooks)

**Internal Dependencies**
- Story 8.1/8.10: MasterOrchestrator (integration point)
- Story 8.2: ValidationChain (emergency exits bypass this)
- Story 8.6: RiskValidator (portfolio heat monitoring)
- Story 8.8: TradeSignal (update status to STOPPED)
- Epic 9: Campaign management (campaign position tracking)
- Pattern models (Epic 5/6): invalidation_level field

**Database Schema**
- `emergency_exit_events` table (Alembic migration 008)
- `emergency_exit_results` table
- `emergency_exit_reports` table
- Foreign keys: `campaign_id`, `pattern_id` references

### Performance Considerations

**Real-Time Monitoring:**
- Emergency condition checks run on EVERY bar ingestion
- Target latency: <50ms per check (5 checks Ã— 10ms each)
- Database queries optimized with indexes on pattern.invalidation_level

**Execution Speed:**
- Emergency exit execution target: <500ms
- Market order placement prioritized (bypass queue)
- Parallel position closure (async/await)

**Notification Delivery:**
- SMS/Slack/Email sent asynchronously (non-blocking)
- Retry logic ensures delivery (up to 5 retries)
- Critical notifications logged even if delivery fails

## Testing

### Unit Test Requirements
- Test each emergency trigger with valid/invalid conditions
- Test SystemStateManager state transitions
- Test emergency exit execution (positions closed, orders placed)
- Test notification sending (mock Twilio/Slack)
- Test post-exit analysis report generation
- Test UTC timezone enforcement on timestamps
- Test Decimal precision in trigger comparisons

### Integration Test Requirements
- Test Spring invalidation workflow (pattern break â†’ exit campaign)
- Test SOS ice break workflow
- Test UTAD invalidation workflow
- Test daily loss limit workflow (halt new trades)
- Test max drawdown workflow (halt system, close all positions)
- Test manual reset workflow
- Test WebSocket emergency exit messages

### API Test Requirements
- Test GET /emergency-exits returns paginated list
- Test GET /emergency-exits/{id} returns full event details
- Test POST /system/reset restores ACTIVE state
- Test GET /system/state returns current halt status

[Source: docs/architecture/12-testing-strategy.md]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation for Epic 8.9 - Emergency Exit Conditions Implementation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results
_To be filled by QA Agent_
