# Story 9.3: Signal Prioritization Logic

## Status
Done

## Story
**As a** campaign manager,
**I want** to prioritize concurrent signals by confidence, R-multiple, and pattern type (FR28),
**so that** the best opportunity is signaled when multiple patterns trigger simultaneously.

## Acceptance Criteria
1. Priority scoring (FR28): confidence (40%), R-multiple (30%), pattern priority (30%)
2. Pattern priority order: Spring > LPS > SOS > UTAD
3. Rationale: Springs rarest and highest R, LPS better than SOS direct
4. Function: `calculate_priority_score(signal) -> float` returns 0-100
5. Tie-breaking: if scores equal, use pattern priority
6. Signal queue: priority queue orders signals by score
7. Unit test: Spring 75% confidence scores higher than SOS 85% confidence
8. Unit test: LPS with 3.5R scores higher than SOS with 2.8R
9. Integration test: multiple signals correctly ordered by priority
10. API: GET /api/signals?sorted=true returns prioritized list

## Tasks / Subtasks

- [ ] Create PriorityScore data model (AC: 1, 4)
  - [ ] Create file: `backend/src/models/priority.py`
  - [ ] Import dependencies:
    - `from uuid import UUID`
    - `from datetime import datetime, timezone`
    - `from decimal import Decimal`
    - `from typing import Literal`
    - `from pydantic import BaseModel, Field, validator`
  - [ ] Define PatternPriorityOrder enum (AC: 2):
    - `SPRING = 1` - Highest priority (rarest, best R-multiple)
    - `LPS = 2` - Second priority (better than SOS direct entry)
    - `SOS = 3` - Third priority (breakout confirmation)
    - `UTAD = 4` - Lowest priority (distribution pattern)
    - Rationale (AC: 3): Springs have highest R-multiple potential (3-5R), LPS offers better entry than direct SOS (reduced risk), SOS is breakout but higher entry, UTAD is distribution (sell signal, lower priority for long-only system)
  - [ ] Define PriorityComponents dataclass:
    - `confidence_score: int` - Pattern confidence 70-95% (FR26)
    - `confidence_normalized: Decimal` - Normalized 0.0-1.0 for scoring
    - `r_multiple: Decimal` - Expected reward/risk ratio (2.0-5.0+)
    - `r_normalized: Decimal` - Normalized 0.0-1.0 for scoring
    - `pattern_type: str` - "SPRING" | "LPS" | "SOS" | "UTAD"
    - `pattern_priority: int` - 1-4 from PatternPriorityOrder
    - `pattern_normalized: Decimal` - Normalized 0.0-1.0 for scoring
  - [ ] Define PriorityScore dataclass (AC: 1, 4):
    - `signal_id: UUID` - Foreign key to TradeSignal
    - `priority_score: Decimal` - Final score 0.0-100.0 (AC: 4)
    - `components: PriorityComponents` - Breakdown of scoring components
    - `weights: dict` - FR28 weights: `{"confidence": 0.40, "r_multiple": 0.30, "pattern": 0.30}` (AC: 1)
    - `calculated_at: datetime` - When score was calculated (UTC)
    - `rank: int | None` - Position in priority queue (1=highest)
  - [ ] Add JSON serialization config:
    - Serialize Decimal as string (preserve precision)
    - Serialize datetime as ISO 8601 UTC
  - [ ] Add method: `def __lt__(self, other: PriorityScore) -> bool` for heap comparison:
    - Used by Python heapq for priority queue ordering
    - Higher priority_score = lower heap value (Python heapq is min-heap)
    - Implementation: `return self.priority_score > other.priority_score` (invert for max-heap behavior)
    - Tie-breaking (AC: 5): If scores equal, compare pattern_priority (lower number = higher priority)

- [ ] Implement calculate_priority_score function (AC: 1, 4)
  - [ ] Create file: `backend/src/signal_prioritization/scorer.py`
  - [ ] Import dependencies:
    - `from decimal import Decimal`
    - `from typing import Dict`
    - `from backend.src.models.signal import TradeSignal`
    - `from backend.src.models.priority import PriorityScore, PriorityComponents, PatternPriorityOrder`
    - `from structlog import get_logger`
  - [ ] Define SignalScorer class:
    - Constructor: configure normalization ranges
      - `min_confidence: int = 70` - Minimum confidence score (FR26)
      - `max_confidence: int = 95` - Maximum confidence score (FR26)
      - `min_r_multiple: Decimal = Decimal("2.0")` - Minimum R-multiple (FR17)
      - `max_r_multiple: Decimal = Decimal("5.0")` - Maximum R-multiple (upper bound for normalization)
      - `weights: Dict[str, Decimal]` - FR28 weights (AC: 1)
      - `logger: structlog.Logger` - Structured logging
  - [ ] Implement `def normalize_confidence(confidence: int) -> Decimal` (AC: 1):
    - Normalize confidence score 70-95 to range 0.0-1.0
    - Formula: `(confidence - min_confidence) / (max_confidence - min_confidence)`
    - Example: confidence=85 → `(85-70)/(95-70) = 15/25 = 0.60`
    - Clamp to [0.0, 1.0]: if confidence < 70, return 0.0; if > 95, return 1.0
  - [ ] Implement `def normalize_r_multiple(r_multiple: Decimal) -> Decimal` (AC: 1):
    - Normalize R-multiple 2.0-5.0 to range 0.0-1.0
    - Formula: `(r_multiple - min_r_multiple) / (max_r_multiple - min_r_multiple)`
    - Example: r_multiple=3.5 → `(3.5-2.0)/(5.0-2.0) = 1.5/3.0 = 0.50`
    - Clamp to [0.0, 1.0]: if r < 2.0, return 0.0; if > 5.0, return 1.0
  - [ ] Implement `def normalize_pattern_priority(pattern_type: str) -> Decimal` (AC: 2, 3):
    - Map pattern type to priority order (AC: 2): Spring=1, LPS=2, SOS=3, UTAD=4
    - Normalize to 0.0-1.0 (invert: lower number = higher score)
    - Formula: `(max_priority - priority) / (max_priority - min_priority)`
    - Where max_priority=4 (UTAD), min_priority=1 (Spring)
    - Examples:
      - Spring (priority=1): `(4-1)/(4-1) = 3/3 = 1.0` (highest score)
      - LPS (priority=2): `(4-2)/(4-1) = 2/3 = 0.67`
      - SOS (priority=3): `(4-3)/(4-1) = 1/3 = 0.33`
      - UTAD (priority=4): `(4-4)/(4-1) = 0/3 = 0.0` (lowest score)
  - [ ] Implement `def calculate_priority_score(signal: TradeSignal) -> PriorityScore` (AC: 4):
    - Extract values from signal:
      - confidence = signal.confidence_score (int, 70-95)
      - r_multiple = signal.r_multiple (Decimal, 2.0+)
      - pattern_type = signal.pattern_type (str)
    - Normalize each component:
      - confidence_normalized = normalize_confidence(confidence)
      - r_normalized = normalize_r_multiple(r_multiple)
      - pattern_normalized = normalize_pattern_priority(pattern_type)
    - Calculate weighted score (AC: 1: FR28 weights):
      - `priority_score = (confidence_normalized * 0.40) + (r_normalized * 0.30) + (pattern_normalized * 0.30)`
      - Result range: 0.0-1.0
      - Scale to 0-100: `priority_score * 100`
    - Build PriorityComponents:
      - confidence_score = confidence
      - confidence_normalized = confidence_normalized
      - r_multiple = r_multiple
      - r_normalized = r_normalized
      - pattern_type = pattern_type
      - pattern_priority = PatternPriorityOrder[pattern_type].value
      - pattern_normalized = pattern_normalized
    - Build PriorityScore:
      - signal_id = signal.id
      - priority_score = final_score (0.0-100.0)
      - components = built PriorityComponents
      - weights = {"confidence": 0.40, "r_multiple": 0.30, "pattern": 0.30}
      - calculated_at = datetime.now(timezone.utc)
      - rank = None (set by priority queue)
    - Log score calculation:
      - `logger.info("priority_score_calculated", signal_id=signal.id, priority_score=final_score, pattern_type=pattern_type)`
    - Return PriorityScore
  - [ ] Add validation:
    - Raise ValueError if signal.confidence_score not in [70, 95]
    - Raise ValueError if signal.r_multiple < 2.0
    - Raise ValueError if pattern_type not in ["SPRING", "LPS", "SOS", "UTAD"]

- [ ] Create SignalPriorityQueue implementation (AC: 6)
  - [ ] Create file: `backend/src/signal_prioritization/priority_queue.py`
  - [ ] Import dependencies:
    - `import heapq`
    - `from typing import List, Optional`
    - `from uuid import UUID`
    - `from backend.src.models.signal import TradeSignal`
    - `from backend.src.models.priority import PriorityScore`
    - `from backend.src.signal_prioritization.scorer import SignalScorer`
    - `from structlog import get_logger`
  - [ ] Define SignalPriorityQueue class (AC: 6):
    - Constructor:
      - `scorer: SignalScorer` - Injected scorer for calculating priorities
      - `heap: List[tuple]` - Internal heap: `[(priority_score, rank_counter, signal)]`
      - `rank_counter: int` - Auto-increment counter for tie-breaking
      - `signal_scores: Dict[UUID, PriorityScore]` - Map signal_id → PriorityScore
      - `logger: structlog.Logger` - Structured logging
    - Internal heap structure (Python heapq):
      - Min-heap: smallest value at top
      - To get max-priority (highest score), negate priority_score: `(-priority_score, rank_counter, signal)`
      - rank_counter ensures FIFO tie-breaking when scores equal
  - [ ] Implement `def push(signal: TradeSignal) -> None` (AC: 6):
    - Calculate priority score: `score = self.scorer.calculate_priority_score(signal)`
    - Add to heap with negated score (max-heap behavior):
      - `heapq.heappush(self.heap, (-score.priority_score, self.rank_counter, signal))`
    - Store score mapping: `self.signal_scores[signal.id] = score`
    - Increment rank_counter
    - Log: `logger.info("signal_added_to_queue", signal_id=signal.id, priority_score=score.priority_score, queue_size=len(self.heap))`
  - [ ] Implement `def pop() -> TradeSignal | None` (AC: 6):
    - If heap empty: return None
    - Pop highest priority signal: `neg_score, rank, signal = heapq.heappop(self.heap)`
    - Update rank in stored PriorityScore: `self.signal_scores[signal.id].rank = 1` (was highest)
    - Log: `logger.info("signal_popped_from_queue", signal_id=signal.id, remaining_size=len(self.heap))`
    - Return signal
  - [ ] Implement `def peek() -> TradeSignal | None`:
    - If heap empty: return None
    - Return highest priority signal without removing: `return self.heap[0][2]`
  - [ ] Implement `def get_all_sorted() -> List[TradeSignal]` (AC: 10):
    - Return copy of all signals in priority order
    - Use heapq.nsmallest (which returns largest priority_score first due to negation)
    - `sorted_tuples = heapq.nsmallest(len(self.heap), self.heap)`
    - Extract signals: `return [tup[2] for tup in sorted_tuples]`
  - [ ] Implement `def get_score(signal_id: UUID) -> PriorityScore | None`:
    - Return stored PriorityScore for signal_id
    - `return self.signal_scores.get(signal_id)`
  - [ ] Implement `def size() -> int`:
    - Return current queue size: `return len(self.heap)`
  - [ ] Implement `def clear() -> None`:
    - Clear heap and scores: `self.heap.clear()`, `self.signal_scores.clear()`, `self.rank_counter = 0`

- [ ] Integrate priority scoring with MasterOrchestrator (AC: 6)
  - [ ] Update `backend/src/signal_generator/master_orchestrator.py`
  - [ ] Inject SignalPriorityQueue into MasterOrchestrator constructor:
    - Add parameter: `signal_queue: SignalPriorityQueue`
    - Store as instance variable: `self.signal_queue = signal_queue`
  - [ ] Modify `generate_signal_from_pattern()` method:
    - After TradeSignal created and campaign linked:
      - Call `self.signal_queue.push(signal)` (AC: 6)
      - Log: `logger.info("signal_added_to_priority_queue", signal_id=signal.id, pattern_type=signal.pattern_type)`
    - Signal queue now maintains all signals in priority order
  - [ ] Add method: `async def get_next_signal() -> TradeSignal | None`:
    - Pop highest priority signal from queue: `signal = self.signal_queue.pop()`
    - If signal is None: return None (queue empty)
    - Return signal for trading system to execute
  - [ ] Add method: `async def get_pending_signals(limit: int = 50) -> List[TradeSignal]`:
    - Get all signals from queue in priority order: `signals = self.signal_queue.get_all_sorted()`
    - Apply limit: `return signals[:limit]`
    - Used by API endpoint to show pending signals

- [ ] Add API endpoint: GET /api/v1/signals?sorted=true (AC: 10)
  - [ ] Update file: `backend/src/api/routes/signals.py`
  - [ ] Add query parameter to existing GET /signals endpoint:
    - `sorted: bool = Query(False)` - Return signals in priority order (AC: 10)
  - [ ] If sorted=True:
    - Call `orchestrator.get_pending_signals()` to get prioritized list
    - For each signal, fetch PriorityScore: `signal_queue.get_score(signal.id)`
    - Attach priority_score to signal response (add to serialization)
  - [ ] Response format (AC: 10):
    ```json
    {
      "data": [
        {
          "id": "uuid",
          "symbol": "AAPL",
          "pattern_type": "SPRING",
          "confidence_score": 85,
          "r_multiple": 3.5,
          "priority_score": 72.5,
          "rank": 1,
          "status": "PENDING"
        },
        {
          "id": "uuid",
          "symbol": "MSFT",
          "pattern_type": "SOS",
          "confidence_score": 90,
          "r_multiple": 2.8,
          "priority_score": 65.3,
          "rank": 2,
          "status": "PENDING"
        }
      ],
      "pagination": {...}
    }
    ```
  - [ ] If sorted=False:
    - Use existing query logic (order by generated_at DESC)

- [ ] Write unit tests for priority scoring (AC: 7, 8)
  - [ ] Create test file: `backend/tests/unit/signal_prioritization/test_scorer.py`
  - [ ] Test: `test_normalize_confidence()`:
    - Test confidence=70 → normalized=0.0
    - Test confidence=85 → normalized=0.6
    - Test confidence=95 → normalized=1.0
    - Test confidence=60 (below min) → normalized=0.0 (clamped)
    - Test confidence=100 (above max) → normalized=1.0 (clamped)
  - [ ] Test: `test_normalize_r_multiple()`:
    - Test r=2.0 → normalized=0.0
    - Test r=3.5 → normalized=0.5
    - Test r=5.0 → normalized=1.0
    - Test r=1.5 (below min) → normalized=0.0 (clamped)
    - Test r=6.0 (above max) → normalized=1.0 (clamped)
  - [ ] Test: `test_normalize_pattern_priority()`:
    - Test SPRING → normalized=1.0 (highest priority)
    - Test LPS → normalized=0.67
    - Test SOS → normalized=0.33
    - Test UTAD → normalized=0.0 (lowest priority)
  - [ ] Test: `test_calculate_priority_score_weighted()` (AC: 1):
    - Create mock TradeSignal: confidence=80, r_multiple=3.0, pattern_type="SPRING"
    - Calculate normalized values:
      - confidence: (80-70)/(95-70) = 10/25 = 0.40
      - r_multiple: (3.0-2.0)/(5.0-2.0) = 1.0/3.0 = 0.33
      - pattern (Spring): 1.0
    - Calculate weighted score: `(0.40 * 0.40) + (0.33 * 0.30) + (1.0 * 0.30) = 0.16 + 0.10 + 0.30 = 0.56`
    - Scaled to 100: 56.0
    - Assert: priority_score == 56.0
  - [ ] Test: `test_spring_75_confidence_beats_sos_85_confidence()` (AC: 7):
    - Signal A: SPRING, confidence=75, r_multiple=3.5
      - confidence_norm = (75-70)/(95-70) = 5/25 = 0.20
      - r_norm = (3.5-2.0)/(5.0-2.0) = 1.5/3.0 = 0.50
      - pattern_norm = 1.0 (SPRING)
      - score = (0.20*0.40) + (0.50*0.30) + (1.0*0.30) = 0.08 + 0.15 + 0.30 = 0.53 = 53.0
    - Signal B: SOS, confidence=85, r_multiple=3.5
      - confidence_norm = (85-70)/(95-70) = 15/25 = 0.60
      - r_norm = 0.50 (same)
      - pattern_norm = 0.33 (SOS)
      - score = (0.60*0.40) + (0.50*0.30) + (0.33*0.30) = 0.24 + 0.15 + 0.10 = 0.49 = 49.0
    - Assert: spring_score (53.0) > sos_score (49.0) (AC: 7)
    - Pattern priority (30% weight) outweighs 10-point confidence difference (4 points of final score)
  - [ ] Test: `test_lps_3_5r_beats_sos_2_8r()` (AC: 8):
    - Signal A: LPS, confidence=80, r_multiple=3.5
      - confidence_norm = 0.40
      - r_norm = (3.5-2.0)/(5.0-2.0) = 0.50
      - pattern_norm = 0.67 (LPS)
      - score = (0.40*0.40) + (0.50*0.30) + (0.67*0.30) = 0.16 + 0.15 + 0.20 = 0.51 = 51.0
    - Signal B: SOS, confidence=80, r_multiple=2.8
      - confidence_norm = 0.40 (same)
      - r_norm = (2.8-2.0)/(5.0-2.0) = 0.8/3.0 = 0.27
      - pattern_norm = 0.33 (SOS)
      - score = (0.40*0.40) + (0.27*0.30) + (0.33*0.30) = 0.16 + 0.08 + 0.10 = 0.34 = 34.0
    - Assert: lps_score (51.0) > sos_score (34.0) (AC: 8)
    - Higher R-multiple (30% weight) + better pattern priority (30% weight) significantly beat SOS
  - [ ] Test: `test_tie_breaking_uses_pattern_priority()` (AC: 5):
    - Create two signals with same score but different pattern types
    - Signal A: SPRING, score=50.0
    - Signal B: SOS, score=50.0
    - Create PriorityScore objects for both
    - Assert: spring_priority_score < sos_priority_score (for heap ordering)
    - Tie-breaking uses pattern_priority (1 vs 3)

- [ ] Write unit tests for SignalPriorityQueue (AC: 6)
  - [ ] Create test file: `backend/tests/unit/signal_prioritization/test_priority_queue.py`
  - [ ] Test: `test_push_and_pop_maintains_priority_order()`:
    - Create 5 signals with different scores:
      - Signal A: score=80.0 (highest)
      - Signal B: score=65.0
      - Signal C: score=90.0 (should pop first)
      - Signal D: score=50.0 (lowest)
      - Signal E: score=75.0
    - Push all signals to queue
    - Pop signals one by one
    - Assert order: C (90.0), A (80.0), E (75.0), B (65.0), D (50.0)
  - [ ] Test: `test_get_all_sorted_does_not_modify_queue()`:
    - Push 3 signals to queue
    - Call get_all_sorted()
    - Assert: queue size unchanged (3)
    - Assert: signals returned in priority order
  - [ ] Test: `test_peek_returns_highest_priority_without_removing()`:
    - Push 3 signals
    - Call peek()
    - Assert: highest priority signal returned
    - Assert: queue size unchanged
  - [ ] Test: `test_tie_breaking_fifo_for_equal_scores()`:
    - Push 3 signals with same score (75.0) but same pattern type
    - Pop all signals
    - Assert: signals returned in FIFO order (insertion order preserved)
  - [ ] Test: `test_get_score_returns_priority_score_for_signal()`:
    - Push signal with calculated score
    - Call get_score(signal.id)
    - Assert: PriorityScore returned with correct priority_score value

- [ ] Write integration test for multiple signals prioritization (AC: 9)
  - [ ] Create test file: `backend/tests/integration/signal_prioritization/test_signal_prioritization_integration.py`
  - [ ] Test: `test_multiple_concurrent_signals_correctly_prioritized()` (AC: 9):
    - Setup: Seed database with 5 patterns detected simultaneously (same timestamp):
      - Pattern 1: SPRING, confidence=85, r_multiple=4.0 → expected rank 1
      - Pattern 2: SOS, confidence=90, r_multiple=3.0 → expected rank 3
      - Pattern 3: LPS, confidence=80, r_multiple=3.5 → expected rank 2
      - Pattern 4: UTAD, confidence=85, r_multiple=2.5 → expected rank 5
      - Pattern 5: SOS, confidence=75, r_multiple=2.8 → expected rank 4
    - Execute: Run MasterOrchestrator to generate signals from all patterns
    - Signals automatically added to priority queue during generation
    - Call orchestrator.get_pending_signals() to retrieve prioritized list
    - Assert order: Spring (rank 1), LPS (rank 2), SOS-90 (rank 3), SOS-75 (rank 4), UTAD (rank 5)
    - Validate scores match expected calculations
  - [ ] Test: `test_priority_queue_integration_with_orchestrator()`:
    - Create 3 patterns: SPRING (high score), SOS (medium), UTAD (low)
    - Generate signals via orchestrator
    - Assert: signal_queue.size() == 3
    - Pop highest priority: Assert pattern_type == "SPRING"
    - Pop next: Assert pattern_type == "SOS"
    - Pop last: Assert pattern_type == "UTAD"
  - [ ] Test: `test_api_endpoint_returns_sorted_signals()` (AC: 10):
    - Setup: Generate 5 signals with varying priorities
    - Call API: GET /api/v1/signals?sorted=true
    - Assert: Response status 200
    - Assert: Signals returned in descending priority order
    - Assert: Each signal includes priority_score and rank fields
    - Assert: Highest rank (1) at top of list

- [ ] Add logging and observability
  - [ ] Use structlog for all prioritization operations:
    - Log level INFO: Score calculated, signal added to queue, signal popped
    - Log level DEBUG: Component scores breakdown (confidence_norm, r_norm, pattern_norm)
    - Log level WARNING: Unusual scores (priority_score < 20 or > 95)
  - [ ] Include context in all logs:
    - signal_id, pattern_type, confidence_score, r_multiple, priority_score, rank
  - [ ] Add metrics (OpenTelemetry):
    - Histogram: priority_score_distribution (track score ranges)
    - Counter: signals_by_pattern_priority (count by SPRING, LPS, SOS, UTAD)
    - Gauge: queue_size (current pending signals)

- [ ] Document priority scoring in architecture docs
  - [ ] Update `docs/architecture/6-components.md`:
    - Add section: "6.1.10 Signal Prioritization Service"
    - Describe FR28 scoring algorithm with weights
    - Document pattern priority order rationale
  - [ ] Update `docs/architecture/4-data-models.md`:
    - Add section: "4.X PriorityScore"
    - Document PriorityScore and PriorityComponents dataclasses
    - Include scoring formula and examples
  - [ ] Create `backend/src/signal_prioritization/README.md`:
    - Explain priority scoring algorithm
    - Provide worked examples for each pattern type
    - Document normalization formulas
    - Include edge cases (tie-breaking, clamping)

## Dev Notes

### Functional Requirements

**FR28: Signal Prioritization** [Source: docs/prd/epic-9-campaign-management-system.md#Story-9.3]
> "Priority scoring: confidence (40%), R-multiple (30%), pattern priority (30%). Pattern priority order: Spring > LPS > SOS > UTAD"

This story implements the complete FR28 prioritization algorithm. The weights reflect the relative importance of each factor:
- **Confidence (40%)**: Pattern detection quality is most important (reliable signals)
- **R-multiple (30%)**: Risk/reward potential is second priority (trade efficiency)
- **Pattern Priority (30%)**: Pattern type rarity and strategic value (BMAD methodology)

**Pattern Priority Rationale** (AC: 2, 3):
- **Spring (1)**: Rarest pattern, highest R-multiple (3-5R), lowest entry price (best value)
- **LPS (2)**: Better entry than direct SOS (reduced risk), confirms markup readiness
- **SOS (3)**: Breakout confirmation, but higher entry price than Spring/LPS
- **UTAD (4)**: Distribution pattern (sell signal), lowest priority for long-only system

**FR17: R-Multiple Targets** [Source: docs/prd/epic-8-signal-generation-validation-workflow.md]
> "Minimum 2R for all signals. Springs target 3-5R, SOS/LPS target 2-3R"

R-multiple normalization uses 2.0-5.0 range based on FR17 targets. Signals below 2R are rejected during validation (Story 8.6), so prioritization assumes r_multiple >= 2.0.

**FR26: Confidence Scoring** [Source: docs/prd/epic-6-pattern-detection-engine.md]
> "Pattern confidence scores range 70-95%"

Confidence normalization uses 70-95 range based on FR26. Patterns below 70% confidence are rejected during detection, so prioritization assumes confidence >= 70.

### Data Models

**PriorityScore Model Structure** [Source: Story 9.3 AC, docs/architecture/4-data-models.md]

```python
from uuid import UUID
from datetime import datetime, timezone
from decimal import Decimal
from typing import Literal, Dict
from pydantic import BaseModel, Field
from enum import IntEnum

class PatternPriorityOrder(IntEnum):
    """
    Pattern priority for signal ranking (AC: 2).
    Lower number = higher priority.
    """
    SPRING = 1  # Highest priority
    LPS = 2
    SOS = 3
    UTAD = 4   # Lowest priority

class PriorityComponents(BaseModel):
    """
    Breakdown of priority score components for transparency.
    """
    confidence_score: int = Field(..., ge=70, le=95)
    confidence_normalized: Decimal = Field(..., ge=0, le=1)
    r_multiple: Decimal = Field(..., ge=2.0)
    r_normalized: Decimal = Field(..., ge=0, le=1)
    pattern_type: Literal["SPRING", "LPS", "SOS", "UTAD"]
    pattern_priority: int = Field(..., ge=1, le=4)
    pattern_normalized: Decimal = Field(..., ge=0, le=1)

class PriorityScore(BaseModel):
    """
    Priority score for signal ranking (AC: 1, 4).

    FR28 weighted scoring:
    - Confidence: 40%
    - R-multiple: 30%
    - Pattern priority: 30%
    """
    signal_id: UUID
    priority_score: Decimal = Field(..., ge=0, le=100)  # Final score 0-100 (AC: 4)
    components: PriorityComponents
    weights: Dict[str, Decimal] = Field(
        default={"confidence": Decimal("0.40"), "r_multiple": Decimal("0.30"), "pattern": Decimal("0.30")}
    )
    calculated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    rank: int | None = None  # Position in queue (1=highest)

    def __lt__(self, other: "PriorityScore") -> bool:
        """
        Comparison for heap ordering (AC: 5, 6).
        Higher priority_score = higher priority (inverted for min-heap).
        Tie-breaking: use pattern_priority (lower number wins).
        """
        if self.priority_score != other.priority_score:
            return self.priority_score > other.priority_score  # Invert for max-heap
        return self.components.pattern_priority < other.components.pattern_priority

    class Config:
        json_encoders = {
            Decimal: str,
            datetime: lambda v: v.isoformat()
        }
```

**Priority Scoring Algorithm** (AC: 1, 4):

```python
def calculate_priority_score(signal: TradeSignal) -> PriorityScore:
    """
    FR28 priority scoring algorithm.

    Example calculation for Spring:
    - confidence=85: (85-70)/(95-70) = 0.60
    - r_multiple=3.5: (3.5-2.0)/(5.0-2.0) = 0.50
    - pattern=SPRING: (4-1)/(4-1) = 1.0
    - score = (0.60 * 0.40) + (0.50 * 0.30) + (1.0 * 0.30) = 0.24 + 0.15 + 0.30 = 0.69
    - scaled = 0.69 * 100 = 69.0
    """
    # Normalize components to 0.0-1.0
    conf_norm = (signal.confidence_score - 70) / (95 - 70)
    r_norm = (signal.r_multiple - 2.0) / (5.0 - 2.0)
    pattern_priority = PatternPriorityOrder[signal.pattern_type].value
    pattern_norm = (4 - pattern_priority) / (4 - 1)  # Invert: lower priority = higher score

    # Apply FR28 weights
    weighted_score = (conf_norm * 0.40) + (r_norm * 0.30) + (pattern_norm * 0.30)

    # Scale to 0-100
    final_score = weighted_score * 100

    return PriorityScore(
        signal_id=signal.id,
        priority_score=Decimal(str(final_score)),
        components=PriorityComponents(
            confidence_score=signal.confidence_score,
            confidence_normalized=Decimal(str(conf_norm)),
            r_multiple=signal.r_multiple,
            r_normalized=Decimal(str(r_norm)),
            pattern_type=signal.pattern_type,
            pattern_priority=pattern_priority,
            pattern_normalized=Decimal(str(pattern_norm))
        ),
        calculated_at=datetime.now(timezone.utc)
    )
```

### File Locations

**Project Structure Reference** [Source: docs/architecture/10-unified-project-structure.md]

Files to create/modify:
```
backend/src/
├── models/
│   └── priority.py                         # NEW: PriorityScore, PriorityComponents models
├── signal_prioritization/
│   ├── __init__.py                         # NEW: Module init
│   ├── scorer.py                           # NEW: SignalScorer class with scoring algorithm
│   └── priority_queue.py                   # NEW: SignalPriorityQueue class
├── signal_generator/
│   └── master_orchestrator.py              # MODIFY: Integrate priority queue
├── api/routes/
│   └── signals.py                          # MODIFY: Add sorted=true query parameter

backend/tests/
├── unit/
│   └── signal_prioritization/
│       ├── test_scorer.py                  # NEW: Scoring algorithm tests
│       └── test_priority_queue.py          # NEW: Priority queue tests
└── integration/
    └── signal_prioritization/
        └── test_signal_prioritization_integration.py  # NEW: End-to-end tests

docs/architecture/
├── 4-data-models.md                        # UPDATE: Add PriorityScore model
└── 6-components.md                         # UPDATE: Add Signal Prioritization Service
```

### API Specifications

**Prioritized Signals Endpoint** [Source: Story 9.3 AC: 10, docs/architecture/5-api-specification.md]

```typescript
// GET /api/v1/signals?sorted=true
// Query parameters: sorted (boolean), status, symbol, limit, offset
// Response:
{
  "data": [
    {
      "id": "uuid",
      "symbol": "AAPL",
      "pattern_type": "SPRING",
      "confidence_score": 85,
      "r_multiple": 3.5,
      "entry_price": "148.50",
      "stop_loss": "145.00",
      "target_1": "156.00",
      "position_size": "100",
      "risk_amount": 350.00,
      "status": "PENDING",
      "priority_score": 69.0,  // NEW: Priority score 0-100
      "priority_rank": 1,      // NEW: Queue position
      "priority_components": { // NEW: Score breakdown
        "confidence_normalized": 0.60,
        "r_normalized": 0.50,
        "pattern_normalized": 1.0
      },
      "generated_at": "2024-10-15T14:30:00Z"
    },
    {
      "id": "uuid",
      "symbol": "MSFT",
      "pattern_type": "SOS",
      "confidence_score": 90,
      "r_multiple": 2.8,
      "priority_score": 61.3,
      "priority_rank": 2,
      "status": "PENDING"
    }
  ],
  "pagination": {
    "returned_count": 2,
    "total_count": 2,
    "limit": 50,
    "offset": 0,
    "has_more": false
  }
}

// Signals ordered by priority_score DESC (highest priority first)
```

### Component Integration

**Priority Queue Integration Points** [Source: Story 9.3, docs/architecture/6-components.md]

1. **MasterOrchestrator** (Story 8.10)
   - After TradeSignal created, push to SignalPriorityQueue
   - Queue maintains all pending signals in priority order
   - Orchestrator provides get_next_signal() method for trading system

2. **SignalGenerator** (Story 8.8)
   - TradeSignal includes all fields needed for prioritization: confidence_score, r_multiple, pattern_type
   - No changes to SignalGenerator required (read-only access)

3. **Campaign Service** (Story 9.1)
   - Signals linked to campaigns before prioritization
   - Campaign context available but not used in priority calculation (FR28 only uses signal attributes)

4. **Trading System** (Future)
   - Calls orchestrator.get_next_signal() to pop highest priority signal
   - Executes signals in priority order
   - Updates signal status after execution

5. **API Layer**
   - GET /api/v1/signals?sorted=true returns prioritized list
   - Frontend displays signals with priority scores and ranks
   - Dashboard shows "Next Signal to Trade" (highest priority pending)

### Testing Requirements

**Testing Framework** [Source: docs/architecture/12-testing-strategy.md]
- Backend: pytest 8.0+ with async support
- Mock TradeSignal objects with varying confidence, r_multiple, pattern_type
- Unit tests: Test each normalization function independently
- Integration tests: Test full pipeline with multiple concurrent signals

**Test Coverage Goals:**
- SignalScorer unit tests: 100% (all normalization functions, weighted calculation)
- SignalPriorityQueue unit tests: 100% (push, pop, peek, tie-breaking)
- Integration tests: Full prioritization pipeline with 5+ signals (AC: 9)
- API tests: GET /signals?sorted=true returns correct order (AC: 10)

**Test Scenarios** (AC: 7, 8):
- **AC 7**: Spring 75% confidence beats SOS 85% confidence (pattern priority weight)
- **AC 8**: LPS with 3.5R beats SOS with 2.8R (R-multiple + pattern priority)
- Edge cases: Tie-breaking, score clamping, invalid inputs

### Technical Constraints

**Priority Queue Implementation** [Source: Story 9.3 AC: 6]
- Use Python heapq (binary heap) for O(log n) insert/pop
- Min-heap by default, so negate priority_score for max-heap behavior
- Tie-breaking uses rank_counter (FIFO) and pattern_priority (AC: 5)

**Normalization Ranges** [Source: FR17, FR26]
- Confidence: 70-95% (FR26 detection thresholds)
- R-multiple: 2.0-5.0 (FR17 minimum 2R, Spring target 5R max)
- Pattern: 1-4 (Spring=1, LPS=2, SOS=3, UTAD=4)
- Clamping: Values outside ranges clipped to [0.0, 1.0]

**Decimal Precision** [Source: docs/architecture/15-coding-standards.md]
- Use Python Decimal for all score calculations
- Avoid float for financial/scoring precision
- Serialize Decimal as string in JSON

**Performance** [Source: Story 9.3 AC: 6]
- Priority queue operations: O(log n) insert, O(log n) pop, O(1) peek
- Sorting all signals: O(n log n) using heapq.nsmallest
- Acceptable for 10-100 pending signals (typical load)

### Dependencies

**Python Libraries** [Source: docs/architecture/3-tech-stack.md]
- Python 3.11+ (dataclasses, heapq stdlib)
- Pydantic 2.5+ (data models, validation)
- structlog 24.1+ (structured logging)
- No new external dependencies (heapq is stdlib)

**Internal Dependencies**
- TradeSignal model (Story 8.8): Source of confidence_score, r_multiple, pattern_type
- MasterOrchestrator (Story 8.10): Integration point for priority queue
- Campaign Service (Story 9.1): Campaign linking happens before prioritization

### Previous Story Insights

**From Story 9.1 (Campaign Creation and Lifecycle):**
- Campaigns track multiple signals (Spring, SOS, LPS) within same trading range
- Campaign.total_allocation enforces 5% max risk per campaign
- Signal prioritization happens after campaign linking
- Campaign context NOT used in priority calculation (FR28 only uses signal attributes)

**From Story 8.8 (Trade Signal Output Format):**
- TradeSignal includes: confidence_score (int, 70-95), r_multiple (Decimal, 2.0+), pattern_type (str)
- All fields needed for prioritization already present in TradeSignal
- No changes to TradeSignal model required

**From Story 8.10 (MasterOrchestrator Integration):**
- Orchestrator generates signals from validated patterns
- Signals created in generate_signal_from_pattern() method
- Integration point: Add signal_queue.push(signal) after signal creation
- Orchestrator can provide get_next_signal() and get_pending_signals() methods

**Key Insight: Prioritization as Quality Gate**
- Priority scoring determines which signals are most valuable
- Not all approved signals are equal (some have better risk/reward)
- FR28 weights reflect BMAD methodology priorities (quality > reward > pattern rarity)
- Prioritization enables intelligent signal selection when multiple opportunities arise
- Foundation for automated trading system (pop highest priority signal first)

### Testing

**Unit Test Requirements:**
- Test each normalization function (confidence, r_multiple, pattern)
- Test weighted scoring calculation with known inputs
- Test AC 7: Spring 75% confidence beats SOS 85% confidence
- Test AC 8: LPS with 3.5R beats SOS with 2.8R
- Test priority queue push/pop maintains correct order
- Test tie-breaking (equal scores use pattern_priority)
- Test edge cases: clamping, minimum values, invalid pattern types

**Integration Test Requirements:**
- Test AC 9: Multiple concurrent signals (5+) correctly ordered
- Test full pipeline: pattern → signal → prioritization → queue
- Test API endpoint: GET /signals?sorted=true returns prioritized list (AC: 10)
- Test priority scores match expected calculations
- Test rank assignment (1=highest priority)

**Example Test Data:**
- Spring 85% confidence, 3.5R → score ~69.0 → rank 1
- LPS 80% confidence, 3.5R → score ~51.0 → rank 2
- SOS 90% confidence, 3.0R → score ~61.3 → rank depends on others
- UTAD 85% confidence, 2.5R → score ~28.0 → lowest rank

[Source: docs/architecture/12-testing-strategy.md, Story 9.3 AC: 7, 8, 9]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation for Epic 9.3 - Signal Prioritization Logic | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- Phase 1 Commit: 7938546 (Story 9.3: Signal Prioritization - Phase 1 Implementation)
- Phase 2 Commit: 969b7c6 (Story 9.3: Signal Prioritization - Phase 2 MasterOrchestrator Integration)
- Phase 3 Commit: 8c32a18 (Story 9.3: Signal Prioritization - Phase 3 API Endpoint)

### Completion Notes

**Implementation Summary:**

Story 9.3 completed successfully in 3 phases with all acceptance criteria verified:

**Phase 1: Core Scoring Engine (AC: 1-8)**
- Created `PriorityScore`, `PriorityComponents`, `PatternPriorityOrder` models
- Implemented `SignalScorer` with FR28 weighted algorithm (40% confidence, 30% R-multiple, 30% pattern)
- Implemented `SignalPriorityQueue` using Python heapq (binary heap, O(log n) operations)
- 31/31 unit tests passing (test_scorer.py: 21 tests, test_priority_queue.py: 10 tests)
- All mypy --strict and ruff checks passing
- Commit: 7938546

**Phase 2: MasterOrchestrator Integration (AC: 6, 9)**
- Added `SignalPriorityQueue` as optional dependency injection parameter
- Integrated automatic signal.push() after TradeSignal creation
- Added `get_next_signal()` and `get_pending_signals()` methods to orchestrator
- 10/10 integration tests passing (test_signal_prioritization_integration.py)
- Graceful degradation when priority queue not configured (warning logs)
- Commit: 969b7c6

**Phase 3: API Endpoint (AC: 10)**
- Added `sorted` query parameter to GET /api/v1/signals endpoint
- Implemented `calculate_adhoc_priority_score()` helper using same FR28 algorithm
- Added sorting logic with fallback for when orchestrator not fully wired
- 7/7 API integration tests passing (test_signals_api_sorted.py)
- Works with all existing filters (status, symbol, min_confidence, etc.)
- Pagination applied after sorting
- Commit: 8c32a18

**Test Results:**
- Total: 48 tests passing (31 unit + 10 integration + 7 API)
- AC 7 Verified: Spring 75% beats SOS 85% (pattern priority outweighs confidence)
- AC 8 Verified: LPS 3.5R beats SOS 2.8R (R-multiple + pattern priority)
- AC 9 Verified: Multiple signals correctly ordered by priority
- AC 10 Verified: API sorted parameter returns priority-ordered signals

**Key Architectural Decisions:**
1. **Dependency Injection**: SignalPriorityQueue injected via MasterOrchestrator constructor (optional, backward compatible)
2. **Binary Heap (heapq)**: O(log n) push/pop operations, negated scores for max-heap behavior
3. **Tie-Breaking**: Pattern priority (AC: 5), then FIFO (rank_counter)
4. **API Fallback**: calculate_adhoc_priority_score() enables sorted parameter without full DI wiring
5. **Decimal Precision**: All scores use Decimal to avoid float precision issues

**Pattern Priority Rationale (AC: 2, 3):**
- Spring (1): Rarest pattern, best R-multiple (3-5R), lowest entry price
- LPS (2): Better entry than direct SOS, reduced risk
- SOS (3): Breakout confirmation, higher entry price
- UTAD (4): Distribution pattern (sell signal), lowest priority

**FR28 Algorithm Example:**
```
Signal: SPRING, confidence=85, r_multiple=3.5
- confidence_norm = (85-70)/(95-70) = 0.60
- r_norm = (3.5-2.0)/(5.0-2.0) = 0.50
- pattern_norm (Spring) = 1.0
- score = (0.60*0.40) + (0.50*0.30) + (1.0*0.30) = 0.24 + 0.15 + 0.30 = 0.69
- scaled = 0.69 * 100 = 69.0
```

**Known Limitations:**
- API endpoint uses ad-hoc scoring instead of MasterOrchestrator queue (TODO: wire up orchestrator via DI)
- Priority queue not yet connected to trading system (future story)
- No persistence layer (signals stored in-memory via mock _signal_store)

**Future Work:**
- Wire MasterOrchestrator into API via dependency injection (replace calculate_adhoc_priority_score)
- Add database repository for signal persistence
- Integrate priority queue with automated trading system

### File List

**Created:**
- `backend/src/models/priority.py` (166 lines) - PriorityScore, PriorityComponents, PatternPriorityOrder models
- `backend/src/signal_prioritization/__init__.py` (19 lines) - Module exports
- `backend/src/signal_prioritization/scorer.py` (288 lines) - SignalScorer with FR28 algorithm
- `backend/src/signal_prioritization/priority_queue.py` (236 lines) - SignalPriorityQueue with binary heap
- `backend/tests/unit/signal_prioritization/test_scorer.py` (512 lines) - 21 scoring tests (AC: 1-8)
- `backend/tests/unit/signal_prioritization/test_priority_queue.py` (382 lines) - 10 queue tests (AC: 6)
- `backend/tests/integration/signal_prioritization/test_signal_prioritization_integration.py` (426 lines) - 10 integration tests (AC: 9)
- `backend/tests/integration/api/test_signals_api_sorted.py` (343 lines) - 7 API tests (AC: 10)

**Modified:**
- `backend/src/signal_generator/master_orchestrator.py` - Added priority queue integration (lines 63, 245, 293, 714-775)
- `backend/src/api/routes/signals.py` - Added sorted parameter and calculate_adhoc_priority_score (lines 235-355, 463-511)

## QA Results
_To be filled by QA Agent_
