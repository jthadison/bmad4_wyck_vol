# Story 11.5: Advanced Charting Integration

## Status
Done

## Story
**As a** trader,
**I want** interactive charts showing detected patterns overlaid on price action,
**so that** I can visually verify pattern detection quality.

## Acceptance Criteria
1. Chart library: Lightweight Charts (TradingView library)
2. Chart displays: candlesticks with volume panel
3. Pattern markers: Spring, UTAD, SOS, Test marked with icons and labels
4. Level lines: Creek, Ice, Jump drawn as horizontal lines with labels
5. Phase annotations: background shading for Phase A/B/C/D/E
6. Confidence badges: pattern markers show confidence percentage
7. Zoom/pan: mouse wheel zoom, click-drag pan
8. Timeframe selector: 1D, 1W, 1M bars
9. Component: `PatternChart.tsx`
10. Performance: renders 500 bars with 20 pattern markers smoothly
11. **[WYCKOFF]** Schematic overlay: display which Wyckoff schematic (#1 or #2) the current pattern matches
12. **[WYCKOFF]** Cause-building visualization: show Point & Figure count and projected Jump target with progress indicator
13. **[WYCKOFF]** Preliminary events markers: PS, SC, AR, ST events marked on chart before Spring patterns
14. **[WYCKOFF]** Schematic template overlay: semi-transparent idealized pattern overlay showing expected price action

## Tasks / Subtasks

- [ ] **Task 1: Backend - Chart Data API Endpoint** (AC: 1, 2, 8)
  - [ ] Subtask 1.1: Create `GET /api/v1/charts/data` route in `backend/src/api/routes/charts.py`
  - [ ] Subtask 1.2: Add query parameters: `symbol` (required), `timeframe` (1D/1W/1M), `start_date`, `end_date`, `limit` (default 500)
  - [ ] Subtask 1.3: Create `ChartDataRequest` Pydantic model in `backend/src/models/chart.py` for query validation
  - [ ] Subtask 1.4: Create `ChartDataResponse` Pydantic model with fields: bars (OHLCV array), patterns (detected patterns), trading_ranges (with levels)
  - [ ] Subtask 1.5: Implement repository method `get_chart_data(symbol, timeframe, start_date, end_date, limit)` in `backend/src/repositories/chart_repository.py`
  - [ ] Subtask 1.6: Query OHLCV bars from `ohlcv_bars` table with date range filter
  - [ ] Subtask 1.7: Query detected patterns for symbol+timeframe from `patterns` table with `test_confirmed=true`
  - [ ] Subtask 1.8: Query trading ranges with Creek/Ice/Jump levels from `trading_ranges` table
  - [ ] Subtask 1.9: Transform database results to Lightweight Charts format (time as Unix timestamp, OHLCV as separate fields)
  - [ ] Subtask 1.10: Unit test endpoint with mock data (pytest)
  - [ ] Subtask 1.11: Integration test with database query performance (pytest) - verify response < 100ms for 500 bars

- [ ] **Task 2: Backend - Pattern Marker Data Models** (AC: 3, 6)
  - [ ] Subtask 2.1: Create `PatternMarker` Pydantic model in `backend/src/models/chart.py`
  - [ ] Subtask 2.2: Fields: id, pattern_type (SPRING/UTAD/SOS/LPS/TEST), timestamp, price, confidence_score, label_text, icon_type
  - [ ] Subtask 2.3: Create method `to_chart_marker(pattern: Pattern) -> PatternMarker` to transform Pattern model to chart format
  - [ ] Subtask 2.4: Map pattern types to icon identifiers: Springâ†’"â¬†ï¸", UTADâ†’"â¬‡ï¸", SOSâ†’"ðŸš€", LPSâ†’"ðŸ“", Testâ†’"âœ“"
  - [ ] Subtask 2.5: Generate label text: "{pattern_type} ({confidence}%)" e.g., "Spring (85%)"
  - [ ] Subtask 2.6: Unit test pattern marker transformation logic (pytest)

- [ ] **Task 3: Backend - Trading Range Level Lines** (AC: 4)
  - [ ] Subtask 3.1: Create `LevelLine` Pydantic model in `backend/src/models/chart.py`
  - [ ] Subtask 3.2: Fields: level_type (CREEK/ICE/JUMP), price, label, color, line_style (SOLID/DASHED)
  - [ ] Subtask 3.3: Create method `to_level_lines(trading_range: TradingRange) -> List[LevelLine]`
  - [ ] Subtask 3.4: Map levels to colors: Creekâ†’red (#DC2626), Iceâ†’blue (#2563EB), Jumpâ†’green (#16A34A)
  - [ ] Subtask 3.5: Format labels: "Creek: $152.35", "Ice: $160.00", "Jump: $168.50"
  - [ ] Subtask 3.6: Use SOLID style for active ranges, DASHED for completed ranges
  - [ ] Subtask 3.7: Unit test level line generation (pytest)

- [ ] **Task 4: Backend - Phase Annotation Data** (AC: 5)
  - [ ] Subtask 4.1: Create `PhaseAnnotation` Pydantic model in `backend/src/models/chart.py`
  - [ ] Subtask 4.2: Fields: phase (A/B/C/D/E), start_timestamp, end_timestamp, background_color (with alpha transparency)
  - [ ] Subtask 4.3: Query detected phases from `patterns` table based on phase field and timestamps
  - [ ] Subtask 4.4: Calculate phase duration from earliest to latest pattern in that phase
  - [ ] Subtask 4.5: Map phases to background colors: Phase Aâ†’gray (#9CA3AF20), Phase Bâ†’blue (#3B82F620), Phase Câ†’yellow (#FCD34D20), Phase Dâ†’orange (#FB923C20), Phase Eâ†’green (#34D39920)
  - [ ] Subtask 4.6: Handle overlapping phases by prioritizing latest detected phase
  - [ ] Subtask 4.7: Unit test phase annotation generation with various phase sequences (pytest)

- [ ] **Task 5: Backend - Type Generation** (AC: 9)
  - [ ] Subtask 5.1: Run `pydantic-to-typescript` to generate TypeScript types from chart models
  - [ ] Subtask 5.2: Verify generated types in `frontend/src/types/`: ChartDataResponse.ts, PatternMarker.ts, LevelLine.ts, PhaseAnnotation.ts
  - [ ] Subtask 5.3: Update FastAPI OpenAPI schema with chart endpoint documentation

- [ ] **Task 6: Frontend - Lightweight Charts Integration** (AC: 1, 2, 9, 10)
  - [ ] Subtask 6.1: Install `lightweight-charts` package via npm: `npm install lightweight-charts@4.1+`
  - [ ] Subtask 6.2: Create `PatternChart.vue` component in `frontend/src/components/charts/`
  - [ ] Subtask 6.3: Import Lightweight Charts library and TypeScript types
  - [ ] Subtask 6.4: Initialize chart instance in `onMounted` hook with candlestick series
  - [ ] Subtask 6.5: Configure chart options: grid, crosshair, time scale, price scale
  - [ ] Subtask 6.6: Add volume histogram series as separate pane below main chart
  - [ ] Subtask 6.7: Set chart dimensions to fill parent container with responsive sizing
  - [ ] Subtask 6.8: Handle chart cleanup in `onUnmounted` hook to prevent memory leaks
  - [ ] Subtask 6.9: Component test for chart initialization (Vitest)

- [ ] **Task 7: Frontend - OHLCV Data Loading** (AC: 2, 8, 10)
  - [ ] Subtask 7.1: Create Pinia store `useChartStore.ts` in `frontend/src/stores/`
  - [ ] Subtask 7.2: Define store state: chartData (ChartDataResponse), selectedSymbol, selectedTimeframe, isLoading, error
  - [ ] Subtask 7.3: Define store action: `fetchChartData(symbol, timeframe, dateRange)` using API client
  - [ ] Subtask 7.4: Transform API response to Lightweight Charts format: convert ISO timestamps to Unix seconds
  - [ ] Subtask 7.5: Convert Decimal strings to numbers using `parseFloat()` for prices (acceptable for chart display)
  - [ ] Subtask 7.6: Implement data caching strategy: cache data for 5 minutes per symbol+timeframe
  - [ ] Subtask 7.7: Add loading skeleton using PrimeVue Skeleton while data loads
  - [ ] Subtask 7.8: Handle error states with PrimeVue Toast notifications
  - [ ] Subtask 7.9: Unit test store with mock API responses (Vitest)
  - [ ] Subtask 7.10: Performance test: verify 500 bars load in < 200ms (Vitest)

- [ ] **Task 8: Frontend - Pattern Marker Overlays** (AC: 3, 6)
  - [ ] Subtask 8.1: Create custom pattern marker renderer using Lightweight Charts markers API
  - [ ] Subtask 8.2: Map marker positions: Spring/SOSâ†’below candle (position: 'belowBar'), UTAD/Testâ†’above candle (position: 'aboveBar')
  - [ ] Subtask 8.3: Render marker icons as Unicode emoji characters (â¬†ï¸, â¬‡ï¸, ðŸš€, ðŸ“, âœ“)
  - [ ] Subtask 8.4: Add marker colors: Springâ†’green, UTADâ†’red, SOSâ†’blue, LPSâ†’purple, Testâ†’gray
  - [ ] Subtask 8.5: Render confidence badges as marker tooltips using Lightweight Charts tooltip plugin
  - [ ] Subtask 8.6: Tooltip content: "{pattern_type} | Confidence: {confidence}% | Entry: ${entry_price}"
  - [ ] Subtask 8.7: Handle marker click events to show pattern details in modal/drawer
  - [ ] Subtask 8.8: Component test for marker rendering with mock patterns (Vitest)

- [ ] **Task 9: Frontend - Level Line Overlays** (AC: 4)
  - [ ] Subtask 9.1: Use Lightweight Charts price line API to render Creek/Ice/Jump levels
  - [ ] Subtask 9.2: Create price lines with specified colors and line styles (solid/dashed)
  - [ ] Subtask 9.3: Add price line labels with level name and price: "Creek: $152.35"
  - [ ] Subtask 9.4: Position labels on right y-axis
  - [ ] Subtask 9.5: Update level lines when trading range changes or new ranges detected
  - [ ] Subtask 9.6: Allow toggling level line visibility via checkbox controls
  - [ ] Subtask 9.7: Component test for level line rendering (Vitest)

- [ ] **Task 10: Frontend - Phase Annotations Background Shading** (AC: 5)
  - [ ] Subtask 10.1: Research Lightweight Charts background shading API or plugin for time-based backgrounds
  - [ ] Subtask 10.2: If no native support, create custom canvas overlay layer for phase backgrounds
  - [ ] Subtask 10.3: Render semi-transparent rectangles for each phase duration using mapped colors
  - [ ] Subtask 10.4: Add phase labels at top of each shaded region: "Phase C", "Phase D", etc.
  - [ ] Subtask 10.5: Ensure phase backgrounds render behind candlesticks and markers
  - [ ] Subtask 10.6: Handle phase annotation updates when new phases detected
  - [ ] Subtask 10.7: Allow toggling phase annotation visibility
  - [ ] Subtask 10.8: Component test for phase annotation rendering (Vitest)

- [ ] **Task 11: Frontend - Zoom and Pan Controls** (AC: 7)
  - [ ] Subtask 11.1: Enable Lightweight Charts built-in mouse wheel zoom (enabled by default)
  - [ ] Subtask 11.2: Enable click-drag pan using chart options: `handleScroll: true, handleScale: true`
  - [ ] Subtask 11.3: Add zoom reset button to restore default view (show all bars)
  - [ ] Subtask 11.4: Add zoom level indicator showing number of visible bars
  - [ ] Subtask 11.5: Implement keyboard shortcuts: "+" zoom in, "-" zoom out, "0" reset zoom
  - [ ] Subtask 11.6: Persist zoom/pan state in component state for better UX
  - [ ] Subtask 11.7: Component test for zoom/pan interactions (Vitest)

- [ ] **Task 12: Frontend - Timeframe Selector** (AC: 8)
  - [ ] Subtask 12.1: Create timeframe selector component using PrimeVue SelectButton
  - [ ] Subtask 12.2: Options: "1 Day" (1D bars), "1 Week" (1W bars), "1 Month" (1M bars)
  - [ ] Subtask 12.3: On selection change, call `fetchChartData()` with new timeframe
  - [ ] Subtask 12.4: Show loading indicator during timeframe switch
  - [ ] Subtask 12.5: Persist selected timeframe in localStorage for user preference
  - [ ] Subtask 12.6: Component test for timeframe selector interaction (Vitest)

- [ ] **Task 13: Frontend - Symbol Selector Integration** (AC: 9)
  - [ ] Subtask 13.1: Accept `symbol` as component prop with default value
  - [ ] Subtask 13.2: Watch for symbol prop changes and reload chart data
  - [ ] Subtask 13.3: Emit `symbol-changed` event when symbol changes
  - [ ] Subtask 13.4: Handle invalid symbol errors gracefully with user feedback
  - [ ] Subtask 13.5: Component test for symbol prop changes (Vitest)

- [ ] **Task 14: Frontend - Performance Optimization** (AC: 10)
  - [ ] Subtask 14.1: Lazy load PatternChart component using Vue's `defineAsyncComponent()`
  - [ ] Subtask 14.2: Implement virtual rendering for marker tooltips (only render visible markers)
  - [ ] Subtask 14.3: Debounce chart resize events (300ms) to prevent excessive re-renders
  - [ ] Subtask 14.4: Use `requestAnimationFrame` for smooth marker animations
  - [ ] Subtask 14.5: Profile chart rendering with 500 bars + 20 markers using Vue DevTools
  - [ ] Subtask 14.6: Verify chart renders in < 500ms and maintains 60fps during pan/zoom
  - [ ] Subtask 14.7: Performance test with Vitest: measure render time for 500 bars

- [ ] **Task 15: Frontend - Chart Controls and Settings** (AC: 7, 8)
  - [ ] Subtask 15.1: Create chart toolbar component with controls layout
  - [ ] Subtask 15.2: Add toggle switches: Show Patterns, Show Levels, Show Phases, Show Volume
  - [ ] Subtask 15.3: Add date range picker using PrimeVue Calendar for custom date ranges
  - [ ] Subtask 15.4: Add export button to download chart as PNG image using Lightweight Charts screenshot API
  - [ ] Subtask 15.5: Style toolbar with consistent PrimeVue theme
  - [ ] Subtask 15.6: Component test for toolbar controls (Vitest)

- [ ] **Task 16: Wyckoff Enhancement - Schematic Matching & Overlay** (AC: 11, 14)
  - [ ] Subtask 16.1: Create `WyckoffSchematic` Pydantic model with fields: schematic_type (ACCUMULATION_1/ACCUMULATION_2/DISTRIBUTION_1/DISTRIBUTION_2), confidence_score
  - [ ] Subtask 16.2: Implement schematic matching algorithm comparing actual pattern sequence to Wyckoff schematics
  - [ ] Subtask 16.3: Add schematic_match field to ChartDataResponse
  - [ ] Subtask 16.4: Create schematic template data: ideal price action curves for Schematic #1 and #2
  - [ ] Subtask 16.5: Create schematic overlay component rendering semi-transparent template pattern
  - [ ] Subtask 16.6: Display schematic badge on chart: "Matches: Accumulation Schematic #1 (87% confidence)"
  - [ ] Subtask 16.7: Add toggle control: "Show Schematic Overlay" checkbox
  - [ ] Subtask 16.8: Scale schematic template to fit current trading range (Creek to Ice levels)
  - [ ] Subtask 16.9: Highlight deviations: show where actual price action deviates from schematic template
  - [ ] Subtask 16.10: Unit test schematic matching algorithm (pytest)
  - [ ] Subtask 16.11: Component test for schematic overlay rendering (Vitest)

- [ ] **Task 17: Wyckoff Enhancement - Cause-Building Visualization** (AC: 12)
  - [ ] Subtask 17.1: Create `CauseBuildingData` Pydantic model with fields: column_count, target_column_count, projected_jump, progress_percentage
  - [ ] Subtask 17.2: Implement Point & Figure counting algorithm based on trading range width and bar count
  - [ ] Subtask 17.3: Calculate P&F count: number of accumulation columns (wide-range bars within trading range)
  - [ ] Subtask 17.4: Calculate projected Jump target: Creek + (Ice-Creek) Ã— (column_count Ã— 0.5)
  - [ ] Subtask 17.5: Add cause_building field to ChartDataResponse
  - [ ] Subtask 17.6: Create cause-building panel overlay on chart showing: "Count: 14/18 columns (78% complete)"
  - [ ] Subtask 17.7: Draw projected Jump target as dashed green line above Ice level
  - [ ] Subtask 17.8: Add progress bar: visual indicator of cause-building completion
  - [ ] Subtask 17.9: Display count methodology: "Target: $168.50 (18-column count Ã— $0.92 per column)"
  - [ ] Subtask 17.10: Update Jump target in real-time as new bars are added
  - [ ] Subtask 17.11: Unit test P&F counting algorithm (pytest)
  - [ ] Subtask 17.12: Component test for cause-building visualization (Vitest)

- [ ] **Task 18: Wyckoff Enhancement - Preliminary Events Markers** (AC: 13)
  - [ ] Subtask 18.1: Add preliminary_events array to ChartDataResponse (PS, SC, AR, ST markers)
  - [ ] Subtask 18.2: Query patterns table for preliminary events in chart date range
  - [ ] Subtask 18.3: Create marker styling for preliminary events:
    - PS (Preliminary Support): blue circle above bar
    - SC (Selling Climax): red triangle below bar
    - AR (Automatic Rally): green arrow up from SC
    - ST (Secondary Test): purple square at retest of SC
  - [ ] Subtask 18.4: Render preliminary event markers on chart with labels
  - [ ] Subtask 18.5: Connect related events with dashed lines: PS-SC, SC-AR, ST-Spring
  - [ ] Subtask 18.6: Add tooltips explaining each preliminary event: "Selling Climax - panic selling exhaustion"
  - [ ] Subtask 18.7: Add toggle control: "Show Preliminary Events" checkbox
  - [ ] Subtask 18.8: Highlight complete sequences: PSâ†’SCâ†’ARâ†’STâ†’Spring with green background
  - [ ] Subtask 18.9: Component test for preliminary events rendering (Vitest)

- [ ] **Task 19: Integration Testing** (AC: All)
  - [ ] Subtask 19.1: E2E test: Load chart with default symbol and verify candlesticks render (Playwright)
  - [ ] Subtask 19.2: E2E test: Verify pattern markers appear at correct timestamps with correct icons (Playwright)
  - [ ] Subtask 19.3: E2E test: Verify Creek/Ice/Jump level lines render with correct colors and labels (Playwright)
  - [ ] Subtask 19.4: E2E test: Verify phase annotations show correct background colors (Playwright)
  - [ ] Subtask 19.5: E2E test: Mouse wheel zoom in/out and verify zoom level changes (Playwright)
  - [ ] Subtask 19.6: E2E test: Click-drag pan and verify chart scrolls (Playwright)
  - [ ] Subtask 19.7: E2E test: Switch timeframe selector and verify new data loads (Playwright)
  - [ ] Subtask 19.8: E2E test: Click pattern marker and verify tooltip displays confidence (Playwright)
  - [ ] Subtask 19.9: E2E test: Performance test - verify 500 bars + 20 markers render in < 1 second (Playwright)
  - [ ] Subtask 19.10: E2E test: Verify chart responsive on mobile viewport (Playwright)
  - [ ] Subtask 19.11: E2E test: Toggle schematic overlay and verify template appears (Playwright)
  - [ ] Subtask 19.12: E2E test: Verify schematic badge shows correct match type and confidence (Playwright)
  - [ ] Subtask 19.13: E2E test: Verify cause-building panel displays count and progress (Playwright)
  - [ ] Subtask 19.14: E2E test: Verify projected Jump target line appears above Ice (Playwright)
  - [ ] Subtask 19.15: E2E test: Toggle preliminary events and verify PS, SC, AR, ST markers appear (Playwright)
  - [ ] Subtask 19.16: E2E test: Verify preliminary event connection lines render correctly (Playwright)

## Dev Notes

### Previous Story Insights
Story 11.4 (Campaign Tracker Visualization) established patterns for real-time data visualization with WebSocket updates and PrimeVue component integration. Story 11.5 builds on similar Vue 3 + Pinia patterns but introduces the Lightweight Charts library for advanced financial charting, requiring specialized charting APIs and performance optimization techniques.

### Epic Context
This story is part of Epic 11 (Configuration & Analytics) which delivers FR30 UI components. Story 11.5 specifically implements the advanced charting visualization that enables traders to visually verify Wyckoff pattern detection quality by overlaying detected patterns (Spring, UTAD, SOS, LPS, Test) on price charts with trading range levels (Creek, Ice, Jump) and phase annotations.

### Tech Stack - Charting Library
[Source: docs/architecture/3-tech-stack.md]

**Lightweight Charts v4.1+:**
- Official TradingView library (free, MIT license)
- Optimized for OHLCV candlestick data
- Supports custom overlays for pattern markers (Spring, SOS, UTAD)
- Lightweight bundle size (~50KB gzipped)
- Built-in zoom/pan controls
- Performance target: Smooth rendering of 500+ bars with overlays

The library provides:
- Candlestick series API for OHLCV data
- Histogram series API for volume bars
- Markers API for pattern detection icons
- Price lines API for Creek/Ice/Jump levels
- Time scale and price scale customization
- Native TypeScript support

Installation:
```bash
npm install lightweight-charts@4.1+
```

### Data Models

**Chart Data Models:**
[Source: docs/architecture/4-data-models.md]

The backend must provide chart data in a format compatible with Lightweight Charts while maintaining type safety through Pydantic models.

**Backend Pydantic Models:**

```python
# backend/src/models/chart.py

from decimal import Decimal
from datetime import datetime
from typing import List, Optional, Literal
from pydantic import BaseModel, Field
from uuid import UUID

class ChartBar(BaseModel):
    """Single OHLCV bar for chart display"""
    time: int  # Unix timestamp in seconds (Lightweight Charts format)
    open: float  # Acceptable to use float for display purposes
    high: float
    low: float
    close: float
    volume: int

class PatternMarker(BaseModel):
    """Pattern detection marker for chart overlay"""
    id: UUID
    pattern_type: Literal["SPRING", "UTAD", "SOS", "LPS", "TEST"]
    time: int  # Unix timestamp in seconds
    price: float  # Price where marker appears
    position: Literal["belowBar", "aboveBar"]  # Lightweight Charts position
    confidence_score: int  # 70-95%
    label_text: str  # e.g., "Spring (85%)"
    icon: str  # Unicode emoji: â¬†ï¸, â¬‡ï¸, ðŸš€, ðŸ“, âœ“
    color: str  # Hex color code
    shape: Literal["circle", "square", "arrowUp", "arrowDown"]  # Lightweight Charts shape

class LevelLine(BaseModel):
    """Trading range level line (Creek, Ice, Jump)"""
    level_type: Literal["CREEK", "ICE", "JUMP"]
    price: float
    label: str  # e.g., "Creek: $152.35"
    color: str  # Hex color code
    line_style: Literal["SOLID", "DASHED"]
    line_width: int = 2

class PhaseAnnotation(BaseModel):
    """Wyckoff phase background shading"""
    phase: Literal["A", "B", "C", "D", "E"]
    start_time: int  # Unix timestamp in seconds
    end_time: int  # Unix timestamp in seconds
    background_color: str  # Hex color with alpha: #9CA3AF20
    label: str  # e.g., "Phase C"

class TradingRangeLevels(BaseModel):
    """Active trading range levels for chart"""
    trading_range_id: UUID
    symbol: str
    creek_level: float  # Support
    ice_level: float  # Resistance
    jump_target: float  # Projected target
    range_status: Literal["ACTIVE", "COMPLETED"]

class ChartDataRequest(BaseModel):
    """Query parameters for chart data endpoint"""
    symbol: str = Field(..., max_length=20)
    timeframe: Literal["1D", "1W", "1M"] = "1D"
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    limit: int = Field(500, ge=50, le=2000)  # Performance constraint

class ChartDataResponse(BaseModel):
    """Complete chart data payload"""
    symbol: str
    timeframe: str
    bars: List[ChartBar]
    patterns: List[PatternMarker]
    level_lines: List[LevelLine]
    phase_annotations: List[PhaseAnnotation]
    trading_ranges: List[TradingRangeLevels]
    bar_count: int
    date_range: dict  # {"start": "2024-01-01", "end": "2024-03-13"}

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }
```

**Pattern Type to Chart Marker Mapping:**

| Pattern Type | Icon | Color | Position | Shape |
|--------------|------|-------|----------|-------|
| SPRING | â¬†ï¸ | #16A34A (green) | belowBar | arrowUp |
| UTAD | â¬‡ï¸ | #DC2626 (red) | aboveBar | arrowDown |
| SOS | ðŸš€ | #2563EB (blue) | belowBar | circle |
| LPS | ðŸ“ | #9333EA (purple) | belowBar | circle |
| TEST | âœ“ | #6B7280 (gray) | aboveBar | square |

**Level Line Color Mapping:**

| Level Type | Color | Description |
|------------|-------|-------------|
| CREEK | #DC2626 (red) | Support level - invalidation point |
| ICE | #2563EB (blue) | Resistance level - breakout target |
| JUMP | #16A34A (green) | Projected profit target |

**Phase Background Color Mapping:**

| Phase | Color | Description |
|-------|-------|-------------|
| Phase A | #9CA3AF20 (gray, 12% opacity) | Stopping action |
| Phase B | #3B82F620 (blue, 12% opacity) | Cause building |
| Phase C | #FCD34D20 (yellow, 12% opacity) | Spring testing |
| Phase D | #FB923C20 (orange, 12% opacity) | Signs of Strength |
| Phase E | #34D39920 (green, 12% opacity) | Markup |

### API Specifications

**Chart Data Endpoint:**
[Source: docs/architecture/5-api-specification.md]

```
GET /api/v1/charts/data
Query Parameters:
  - symbol: string (required) - Ticker symbol
  - timeframe: "1D" | "1W" | "1M" (default: "1D")
  - start_date: ISO datetime (optional) - Default: 90 days ago
  - end_date: ISO datetime (optional) - Default: now
  - limit: integer (default: 500, max: 2000)

Response: 200 OK
{
  "symbol": "AAPL",
  "timeframe": "1D",
  "bars": [
    {
      "time": 1710345600,
      "open": 152.35,
      "high": 154.20,
      "low": 151.80,
      "close": 153.50,
      "volume": 1234567
    }
  ],
  "patterns": [
    {
      "id": "uuid",
      "pattern_type": "SPRING",
      "time": 1710345600,
      "price": 151.80,
      "position": "belowBar",
      "confidence_score": 85,
      "label_text": "Spring (85%)",
      "icon": "â¬†ï¸",
      "color": "#16A34A",
      "shape": "arrowUp"
    }
  ],
  "level_lines": [
    {
      "level_type": "CREEK",
      "price": 150.00,
      "label": "Creek: $150.00",
      "color": "#DC2626",
      "line_style": "SOLID",
      "line_width": 2
    }
  ],
  "phase_annotations": [
    {
      "phase": "C",
      "start_time": 1710000000,
      "end_time": 1710345600,
      "background_color": "#FCD34D20",
      "label": "Phase C"
    }
  ],
  "trading_ranges": [
    {
      "trading_range_id": "uuid",
      "symbol": "AAPL",
      "creek_level": 150.00,
      "ice_level": 160.00,
      "jump_target": 168.50,
      "range_status": "ACTIVE"
    }
  ],
  "bar_count": 500,
  "date_range": {
    "start": "2024-01-01T00:00:00Z",
    "end": "2024-03-13T23:59:59Z"
  }
}

Error Responses:
- 400 Bad Request: Invalid query parameters (e.g., limit > 2000)
- 404 Not Found: Symbol not found
- 500 Internal Server Error: Database error
```

**Performance Requirements:**
- Response time: < 100ms (p95) for 500 bars [Source: docs/architecture/14-security-and-performance.md]
- Database query optimization with composite indexes on (symbol, timeframe, timestamp)
- Use `LIMIT` clause to prevent excessive data transfer

### Component Specifications

**Frontend Components:**
[Source: docs/architecture/6-components.md, docs/architecture/10-unified-project-structure.md]

**PatternChart.vue:**
- New component location: `frontend/src/components/charts/PatternChart.vue`
- Responsibilities: Render Lightweight Charts instance, display candlesticks with volume, overlay pattern markers, draw level lines, show phase annotations, handle zoom/pan interactions
- Props: `symbol` (string, required), `timeframe` (string, default: "1D"), `height` (number, default: 600)
- Technology: Vue 3 Composition API, Lightweight Charts library, Pinia store integration
- Lifecycle: Initialize chart in `onMounted`, cleanup in `onUnmounted` to prevent memory leaks

**Pinia Store - useChartStore:**
- New store location: `frontend/src/stores/chartStore.ts`
- State: chartData (ChartDataResponse), selectedSymbol, selectedTimeframe, isLoading, error, cacheMap (for 5-min caching)
- Actions: fetchChartData(symbol, timeframe, dateRange), clearCache()
- Getters: getBars, getPatterns, getLevelLines, getPhaseAnnotations
- Integrates with existing `useApi` composable for REST API calls

### File Locations

**Backend Files to Create/Modify:**
[Source: docs/architecture/10-unified-project-structure.md]

```
backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ routes/
â”‚   â”‚       â””â”€â”€ charts.py                # CREATE: New chart data endpoint
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ chart.py                     # CREATE: Chart data models (ChartBar, PatternMarker, LevelLine, PhaseAnnotation, ChartDataRequest, ChartDataResponse)
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ chart_repository.py          # CREATE: Repository for chart data queries (get_chart_data, get_patterns_for_chart, get_trading_range_levels)
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”‚   â””â”€â”€ test_chart_models.py         # CREATE: Unit tests for chart model transformations
â”‚   â””â”€â”€ integration/
â”‚       â””â”€â”€ test_chart_api.py            # CREATE: Integration tests with database and performance validation
```

**Frontend Files to Create/Modify:**
[Source: docs/architecture/10-unified-project-structure.md]

```
frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â””â”€â”€ charts/
â”‚   â”‚       â”œâ”€â”€ PatternChart.vue         # CREATE: Main charting component with Lightweight Charts
â”‚   â”‚       â””â”€â”€ ChartToolbar.vue         # CREATE: Chart controls (timeframe selector, toggles, export button)
â”‚   â”œâ”€â”€ stores/
â”‚   â”‚   â””â”€â”€ chartStore.ts                # CREATE: Pinia store for chart data management
â”‚   â”œâ”€â”€ composables/
â”‚   â”‚   â””â”€â”€ useChart.ts                  # CREATE: Reusable chart logic composable
â”‚   â”œâ”€â”€ types/                           # AUTO-GENERATED: TypeScript types from Pydantic
â”‚   â”‚   â”œâ”€â”€ ChartDataResponse.ts
â”‚   â”‚   â”œâ”€â”€ PatternMarker.ts
â”‚   â”‚   â”œâ”€â”€ LevelLine.ts
â”‚   â”‚   â”œâ”€â”€ PhaseAnnotation.ts
â”‚   â”‚   â””â”€â”€ ChartBar.ts
â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ api.ts                       # EXISTING: Use for REST API calls
â”œâ”€â”€ tests/
â”‚   â””â”€â”€ components/
â”‚       â”œâ”€â”€ PatternChart.spec.ts         # CREATE: Component tests
â”‚       â””â”€â”€ ChartToolbar.spec.ts         # CREATE: Toolbar component tests
```

**E2E Tests:**
```
tests/
â””â”€â”€ e2e/
    â””â”€â”€ pattern-chart.spec.ts            # CREATE: Playwright E2E tests for charting
```

### Technical Constraints

**Lightweight Charts API Requirements:**
[Source: docs/architecture/3-tech-stack.md]

- Chart instance creation: Use `createChart(container, options)` API
- Candlestick series: Use `addCandlestickSeries()` for OHLCV bars
- Volume histogram: Use `addHistogramSeries()` for volume display below main chart
- Custom markers: Use `setMarkers()` API with marker array
- Price lines: Use `createPriceLine()` API for Creek/Ice/Jump levels
- Time format: Unix timestamps in **seconds** (not milliseconds)
- Data format: Bars must be sorted by time ascending
- Performance: Avoid frequent full re-renders; use `update()` for incremental changes

**Data Format Conversion:**

Backend stores timestamps as ISO datetime UTC. Lightweight Charts requires Unix timestamps in **seconds**.

Conversion in backend:
```python
# Convert datetime to Unix seconds
bar_time = int(bar.timestamp.timestamp())
```

Conversion in frontend:
```typescript
// Convert ISO string to Unix seconds
const barTime = Math.floor(new Date(bar.timestamp).getTime() / 1000);
```

**Decimal Precision for Chart Display:**
[Source: docs/architecture/15-coding-standards.md]

While financial calculations require `Decimal` (Python) and `Big` (TypeScript), chart display can safely use `float` (Python) and `number` (TypeScript) since precision loss is acceptable for visual representation.

Backend: Convert `Decimal` prices to `float` when creating `ChartBar` objects.
Frontend: Use `parseFloat()` or direct number assignment for chart data.

**Performance Optimization:**
[Source: docs/architecture/14-security-and-performance.md]

- Frontend bundle size target: < 500KB gzipped
- Lazy load PatternChart component using `defineAsyncComponent()` to reduce initial bundle
- Chart rendering target: < 500ms for 500 bars + 20 markers
- Maintain 60fps during zoom/pan interactions
- Debounce chart resize events (300ms) to prevent excessive re-renders
- Use `requestAnimationFrame` for smooth animations
- Cache chart data in Pinia store for 5 minutes per symbol+timeframe

**Database Query Optimization:**
[Source: docs/architecture/14-security-and-performance.md]

- Create composite index: `CREATE INDEX idx_ohlcv_symbol_timeframe_timestamp ON ohlcv_bars(symbol, timeframe, timestamp DESC);`
- Create composite index: `CREATE INDEX idx_patterns_symbol_timeframe ON patterns(symbol, timeframe, pattern_bar_timestamp DESC);`
- Use `LIMIT` clause to prevent excessive data transfer (max 2000 bars)
- Query response time target: < 100ms (p95)

**Chart Component Lifecycle:**

```typescript
// Prevent memory leaks
onMounted(() => {
  chart = createChart(chartContainer.value, chartOptions);
  // Initialize series, markers, etc.
});

onUnmounted(() => {
  if (chart) {
    chart.remove();  // CRITICAL: Remove chart instance
    chart = null;
  }
});
```

### Testing

**Backend Testing:**
[Source: docs/architecture/12-testing-strategy.md]

- **Unit Tests (pytest)**: Test chart model transformations (Pattern â†’ PatternMarker, TradingRange â†’ LevelLine), timestamp conversions, color mappings
- **Integration Tests (pytest)**: Test full chart data retrieval with database joins (OHLCV + patterns + trading ranges), verify response format matches Lightweight Charts requirements
- **Performance Tests (pytest)**: Verify chart data endpoint responds in < 100ms for 500 bars

**Frontend Testing:**
[Source: docs/architecture/12-testing-strategy.md]

- **Component Tests (Vitest + Vue Testing Library)**: Test PatternChart.vue initialization, marker rendering, level line rendering, phase annotations, zoom/pan controls
- **Store Tests (Vitest)**: Test useChartStore actions and state updates, caching logic
- **Performance Tests (Vitest)**: Measure chart rendering time for 500 bars + 20 markers (< 500ms target)

**E2E Testing:**
[Source: docs/architecture/12-testing-strategy.md]

- **Playwright Tests**: Full user flow loading chart â†’ verifying candlesticks â†’ checking pattern markers â†’ verifying level lines â†’ testing zoom/pan â†’ switching timeframes
- Test chart responsiveness on different viewport sizes
- Screenshot tests for visual regression testing of chart layout

### Testing Standards

**Test File Locations:**
[Source: docs/architecture/12-testing-strategy.md]

- Backend unit tests: `backend/tests/unit/test_chart_models.py`
- Backend integration tests: `backend/tests/integration/test_chart_api.py`
- Frontend component tests: `frontend/tests/components/PatternChart.spec.ts`, `frontend/tests/components/ChartToolbar.spec.ts`
- E2E tests: `tests/e2e/pattern-chart.spec.ts` (Playwright)

**Testing Frameworks:**
[Source: docs/architecture/3-tech-stack.md]

- Backend: pytest 8.0+ with pytest-mock, factory-boy for fixtures, async test support
- Frontend: Vitest 1.2+ for component tests, Vue Testing Library integration
- E2E: Playwright 1.41+ with screenshot/video recording

**Test Coverage Requirements:**

- Unit tests: 80% coverage minimum for new code
- Integration tests: Cover happy path (successful chart data load), error scenarios (invalid symbol, database errors), performance validation (< 100ms response time)
- E2E tests: Cover complete user journey viewing chart â†’ interacting with markers â†’ zooming/panning â†’ switching timeframes

**Mock Data Requirements:**

- Create factory for ChartDataResponse with 500 bars and 20 pattern markers
- Mock chart data with various pattern types (Spring, UTAD, SOS, LPS, Test) at different timestamps
- Mock trading range with Creek/Ice/Jump levels
- Mock phase annotations for Phase C/D/E sequences
- Test edge cases: empty chart (no bars), no patterns detected, no active trading ranges

**Performance Test Example:**

```python
# backend/tests/integration/test_chart_api.py
import time

def test_chart_data_performance(client, db_session):
    """Verify chart endpoint responds in < 100ms for 500 bars"""
    # Setup: Create 500 bars in database
    start_time = time.time()
    response = client.get("/api/v1/charts/data?symbol=AAPL&limit=500")
    elapsed = (time.time() - start_time) * 1000  # ms

    assert response.status_code == 200
    assert elapsed < 100  # 100ms target
    assert len(response.json()["bars"]) == 500
```

```typescript
// frontend/tests/components/PatternChart.spec.ts
import { performance } from 'perf_hooks';

test('chart renders 500 bars in < 500ms', async () => {
  const mockData = createMockChartData(500, 20); // 500 bars, 20 markers
  const start = performance.now();

  const wrapper = mount(PatternChart, {
    props: { symbol: 'AAPL' }
  });

  await wrapper.vm.loadChartData(mockData);
  const elapsed = performance.now() - start;

  expect(elapsed).toBeLessThan(500); // 500ms target
  expect(wrapper.find('.tv-lightweight-charts').exists()).toBe(true);
});
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story draft created with comprehensive technical details from PRD, Epic 11, and Architecture docs | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes List
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results
_To be populated by QA agent during testing_
