# Story 12.5: Commission and Slippage Modeling

## Status
Ready for Development

## Sprint Assignment

**Sprint 1** - Foundation & Dataset (Required by Story 12.1)

- Dependency of: Story 12.1 (Backtesting Engine)
- Parallel Work: Story 12.2 (Dataset Creation)

## Story
**As a** backtesting developer,
**I want** realistic commission and slippage to prevent over-optimistic backtest results,
**so that** live trading performance matches backtest expectations.

## Acceptance Criteria
1. Commission: flat $0.005/share (configurable per broker)
2. Slippage model: percentage-based on liquidity
3. Liquidity calculation: avg_volume > $1M = 0.02% slippage, < $1M = 0.05%
4. Market impact: larger positions (>10% daily volume) incur additional slippage
5. Fill simulation: market orders filled at next bar open + slippage
6. Limit orders: filled if price reaches limit during bar (conservative: use high for buys, low for sells)
7. Function: `calculate_fill_price(order, next_bar, liquidity) -> Decimal`
8. Backtest report: shows total commissions and slippage costs
9. Unit test: fill prices calculated correctly for various scenarios
10. Realistic expectations: 2.5R theoretical becomes 2.2R after costs

## Tasks / Subtasks

- [ ] **Task 1: Create Commission Models** (AC: 1, 8)
  - [ ] Subtask 1.1: Create Pydantic model `CommissionConfig` in `backend/src/models/backtest.py`:
    - `commission_type`: Literal["PER_SHARE", "PERCENTAGE", "FIXED"] (default "PER_SHARE")
    - `commission_per_share`: Decimal (default Decimal("0.005") for IB retail)
    - `commission_percentage`: Decimal (optional, for percentage-based brokers)
    - `fixed_commission_per_trade`: Decimal (optional, for fixed-rate brokers)
    - `min_commission`: Decimal (default Decimal("1.00") - minimum per trade)
    - `max_commission`: Decimal (optional, for capped commission brokers)
    - `broker_name`: str (e.g., "Interactive Brokers", "TD Ameritrade", "Robinhood")
  - [ ] Subtask 1.2: Create Pydantic model `CommissionBreakdown` in `backend/src/models/backtest.py`:
    - `order_id`: UUID (reference to BacktestOrder)
    - `shares`: int (quantity)
    - `base_commission`: Decimal (commission before min/max caps)
    - `applied_commission`: Decimal (actual commission charged after min/max)
    - `commission_type`: str (which calculation method used)
    - `broker_name`: str
  - [ ] Subtask 1.3: Add `commission_config` field to BacktestConfig model
  - [ ] Subtask 1.4: Add `commission_breakdown` field to BacktestOrder model
  - [ ] Subtask 1.5: Add validators to ensure Decimal precision (8 decimal places) [Source: architecture/15-coding-standards.md]
  - [ ] Subtask 1.6: Unit test all models with Pydantic validation (pytest)
  - [ ] Subtask 1.7: Run `pydantic-to-typescript` to generate TypeScript types

- [ ] **Task 2: Create Slippage Models** (AC: 2, 3, 4)
  - [ ] Subtask 2.1: Create Pydantic model `SlippageConfig` in `backend/src/models/backtest.py`:
    - `slippage_model`: Literal["LIQUIDITY_BASED", "FIXED_PERCENTAGE", "VOLUME_WEIGHTED"] (default "LIQUIDITY_BASED")
    - `high_liquidity_threshold`: Decimal (default Decimal("1000000") = $1M avg volume)
    - `high_liquidity_slippage_pct`: Decimal (default Decimal("0.0002") = 0.02%)
    - `low_liquidity_slippage_pct`: Decimal (default Decimal("0.0005") = 0.05%)
    - `market_impact_enabled`: bool (default True)
    - `market_impact_threshold_pct`: Decimal (default Decimal("0.10") = 10% of bar volume)
    - `market_impact_per_increment_pct`: Decimal (default Decimal("0.0001") = 0.01% per 10% increment)
    - `fixed_slippage_pct`: Decimal (optional, for FIXED_PERCENTAGE model)
  - [ ] Subtask 2.2: Create Pydantic model `SlippageBreakdown` in `backend/src/models/backtest.py`:
    - `order_id`: UUID
    - `bar_volume`: int (volume of the fill bar)
    - `bar_avg_dollar_volume`: Decimal (20-bar average dollar volume for liquidity calc)
    - `order_quantity`: int
    - `order_value`: Decimal (quantity * fill_price)
    - `volume_participation_pct`: Decimal (order_quantity / bar_volume)
    - `base_slippage_pct`: Decimal (liquidity-based slippage)
    - `market_impact_slippage_pct`: Decimal (additional slippage from market impact)
    - `total_slippage_pct`: Decimal (base + market impact)
    - `slippage_dollar_amount`: Decimal (total slippage in dollars)
    - `slippage_model_used`: str
  - [ ] Subtask 2.3: Add `slippage_config` field to BacktestConfig model
  - [ ] Subtask 2.4: Add `slippage_breakdown` field to BacktestOrder model
  - [ ] Subtask 2.5: Unit test all models with Pydantic validation (pytest)
  - [ ] Subtask 2.6: Run `pydantic-to-typescript` to generate TypeScript types

- [ ] **Task 3: Create Liquidity Calculator** (AC: 3)
  - [ ] Subtask 3.1: Create class `LiquidityCalculator` in `backend/src/backtesting/liquidity_calculator.py`
  - [ ] Subtask 3.2: Implement `calculate_avg_dollar_volume(bars: List[OHLCVBar], lookback: int = 20) -> Decimal`:
    - Calculate rolling 20-bar average: avg((close * volume) for each bar)
    - Use pandas for vectorized calculation: `df['dollar_volume'].rolling(lookback).mean()`
    - Return most recent average dollar volume as Decimal
  - [ ] Subtask 3.3: Implement `is_high_liquidity(avg_dollar_volume: Decimal, threshold: Decimal) -> bool`:
    - Return True if avg_dollar_volume >= threshold (default $1M)
    - Return False otherwise
  - [ ] Subtask 3.4: Implement `get_base_slippage_pct(avg_dollar_volume: Decimal, config: SlippageConfig) -> Decimal`:
    - If high_liquidity: return config.high_liquidity_slippage_pct (0.02%)
    - If low_liquidity: return config.low_liquidity_slippage_pct (0.05%)
  - [ ] Subtask 3.5: Use structlog for logging liquidity calculations [Source: architecture/3-tech-stack.md#structlog]
  - [ ] Subtask 3.6: Unit tests:
    - Test avg_dollar_volume calculation with synthetic OHLCV data
    - Test liquidity threshold boundary cases ($999,999 vs $1,000,001)
    - Test base slippage selection logic
  - [ ] Subtask 3.7: Use Decimal type throughout (NOT float) [Source: architecture/15-coding-standards.md]

- [ ] **Task 4: Create Market Impact Calculator** (AC: 4)
  - [ ] Subtask 4.1: Create class `MarketImpactCalculator` in `backend/src/backtesting/market_impact_calculator.py`
  - [ ] Subtask 4.2: Implement `calculate_volume_participation(order_quantity: int, bar_volume: int) -> Decimal`:
    - Calculate: order_quantity / bar_volume
    - Return as Decimal percentage (e.g., Decimal("0.15") = 15%)
    - Handle edge case: bar_volume = 0 → return Decimal("0")
  - [ ] Subtask 4.3: Implement `calculate_market_impact_slippage(volume_participation_pct: Decimal, config: SlippageConfig) -> Decimal`:
    - If not config.market_impact_enabled: return Decimal("0")
    - If volume_participation_pct <= config.market_impact_threshold_pct (10%): return Decimal("0")
    - Calculate excess participation: volume_participation_pct - threshold_pct
    - Calculate increments: excess_pct / 0.10 (number of 10% increments)
    - Calculate impact: increments * config.market_impact_per_increment_pct (0.01% per increment)
    - Return market impact slippage as Decimal
  - [ ] Subtask 4.4: Example calculation:
    - Order: 10,000 shares, Bar volume: 50,000 shares
    - Volume participation: 20% (exceeds 10% threshold)
    - Excess: 20% - 10% = 10% = 1 increment
    - Market impact: 1 * 0.01% = 0.01% additional slippage
  - [ ] Subtask 4.5: Unit tests:
    - Test volume participation calculation (various quantities vs bar volumes)
    - Test market impact at threshold boundary (9.9%, 10.0%, 10.1%)
    - Test incremental impact (15%, 20%, 30%, 50% participation)
    - Test disabled market impact (config.market_impact_enabled = False)
    - Test zero bar volume edge case

- [ ] **Task 5: Create Commission Calculator** (AC: 1, 10)
  - [ ] Subtask 5.1: Create class `CommissionCalculator` in `backend/src/backtesting/commission_calculator.py`
  - [ ] Subtask 5.2: Implement `calculate_commission(order: BacktestOrder, config: CommissionConfig) -> Decimal`:
    - Route to appropriate calculation method based on config.commission_type
    - Call _calculate_per_share, _calculate_percentage, or _calculate_fixed
    - Apply min/max commission caps
    - Return final commission as Decimal
  - [ ] Subtask 5.3: Implement `_calculate_per_share(quantity: int, commission_per_share: Decimal) -> Decimal`:
    - Base commission: quantity * commission_per_share
    - Example: 1,000 shares * $0.005 = $5.00
    - Return base commission
  - [ ] Subtask 5.4: Implement `_calculate_percentage(order_value: Decimal, commission_percentage: Decimal) -> Decimal`:
    - Base commission: order_value * commission_percentage
    - Example: $10,000 order * 0.001 (0.1%) = $10.00
    - Return base commission
  - [ ] Subtask 5.5: Implement `_calculate_fixed(fixed_commission: Decimal) -> Decimal`:
    - Return fixed commission regardless of order size
    - Example: $1.00 per trade (Robinhood-style)
  - [ ] Subtask 5.6: Implement `_apply_min_max_caps(base_commission: Decimal, config: CommissionConfig) -> Decimal`:
    - If base_commission < config.min_commission: return min_commission
    - If config.max_commission and base_commission > max_commission: return max_commission
    - Else: return base_commission
  - [ ] Subtask 5.7: Create `CommissionBreakdown` object with calculation details
  - [ ] Subtask 5.8: Unit tests:
    - Test per-share calculation (IB: 1000 shares → $5.00)
    - Test percentage calculation (TD: $10,000 order at 0.1% → $10.00)
    - Test fixed calculation (Robinhood: $0 or $1.00)
    - Test min commission cap (10 shares * $0.005 = $0.05 → capped to $1.00 min)
    - Test max commission cap (100,000 shares * $0.005 = $500 → capped to $100 max)

- [ ] **Task 6: Create Slippage Calculator** (AC: 2, 3, 4, 7)
  - [ ] Subtask 6.1: Create class `SlippageCalculator` in `backend/src/backtesting/slippage_calculator.py`
  - [ ] Subtask 6.2: Dependencies: LiquidityCalculator, MarketImpactCalculator
  - [ ] Subtask 6.3: Implement `calculate_slippage(order: BacktestOrder, fill_bar: OHLCVBar, historical_bars: List[OHLCVBar], config: SlippageConfig) -> Decimal`:
    - Calculate avg_dollar_volume using LiquidityCalculator
    - Get base_slippage_pct based on liquidity
    - Calculate volume_participation_pct
    - Get market_impact_slippage_pct using MarketImpactCalculator
    - Calculate total_slippage_pct = base + market_impact
    - Return total slippage percentage as Decimal
  - [ ] Subtask 6.4: Implement `apply_slippage_to_price(base_price: Decimal, slippage_pct: Decimal, side: Literal["BUY", "SELL"]) -> Decimal`:
    - BUY: fill_price = base_price * (1 + slippage_pct) (slippage increases cost)
    - SELL: fill_price = base_price * (1 - slippage_pct) (slippage decreases proceeds)
    - Return adjusted fill_price as Decimal
  - [ ] Subtask 6.5: Create `SlippageBreakdown` object with calculation details
  - [ ] Subtask 6.6: Unit tests:
    - Test high liquidity slippage (>$1M avg volume → 0.02%)
    - Test low liquidity slippage (<$1M avg volume → 0.05%)
    - Test market impact added slippage (>10% volume participation)
    - Test BUY slippage application ($100 base + 0.02% → $100.02)
    - Test SELL slippage application ($100 base - 0.02% → $99.98)
    - Test combined base + impact (0.02% base + 0.01% impact = 0.03% total)

- [ ] **Task 7: Implement Fill Price Calculation** (AC: 5, 6, 7)
  - [ ] Subtask 7.1: Create class `FillPriceCalculator` in `backend/src/backtesting/fill_price_calculator.py`
  - [ ] Subtask 7.2: Dependencies: SlippageCalculator, CommissionCalculator
  - [ ] Subtask 7.3: Implement `calculate_fill_price(order: BacktestOrder, next_bar: OHLCVBar, historical_bars: List[OHLCVBar], config: BacktestConfig) -> Decimal`:
    - Route to market order or limit order fill logic
    - Return final fill price as Decimal
  - [ ] Subtask 7.4: Implement `_calculate_market_order_fill(order, next_bar, historical_bars, config) -> Decimal`:
    - Base fill price: next_bar.open (market orders fill at next bar open)
    - Calculate slippage using SlippageCalculator
    - Apply slippage to base price using apply_slippage_to_price
    - Return adjusted fill price
  - [ ] Subtask 7.5: Implement `_calculate_limit_order_fill(order, next_bar, historical_bars, config) -> Optional[Decimal]`:
    - Check if limit price reached during bar:
      - BUY limit: fill if next_bar.low <= order.limit_price (conservative: assume filled at high)
      - SELL limit: fill if next_bar.high >= order.limit_price (conservative: assume filled at low)
    - If filled: return limit_price (no slippage on limit orders)
    - If not filled: return None (order not filled this bar)
  - [ ] Subtask 7.6: Conservative limit order fills:
    - BUY limit triggered at bar.low, but fill at bar.high (worst case for buyer)
    - SELL limit triggered at bar.high, but fill at bar.low (worst case for seller)
    - This prevents over-optimistic backtest results
  - [ ] Subtask 7.7: Unit tests:
    - Test market order fill at next_bar.open + slippage
    - Test BUY limit order: limit $100, bar.low $99.50, bar.high $100.20 → fill at $100.20
    - Test SELL limit order: limit $100, bar.high $100.50, bar.low $99.80 → fill at $99.80
    - Test limit order not filled: BUY limit $100, bar.low $100.10 → no fill
    - Test limit order not filled: SELL limit $100, bar.high $99.90 → no fill

- [ ] **Task 8: Create Transaction Cost Analyzer** (AC: 8, 10)
  - [ ] Subtask 8.1: Create class `TransactionCostAnalyzer` in `backend/src/backtesting/transaction_cost_analyzer.py`
  - [ ] Subtask 8.2: Implement `analyze_trade_costs(trade: BacktestTrade) -> TransactionCostReport`:
    - Extract commission and slippage from trade
    - Calculate total transaction costs = commission + slippage
    - Calculate cost as % of trade value
    - Calculate cost in R-multiples (cost / risk_amount)
    - Return TransactionCostReport
  - [ ] Subtask 8.3: Create Pydantic model `TransactionCostReport`:
    - `trade_id`: UUID
    - `entry_commission`: Decimal
    - `exit_commission`: Decimal
    - `total_commission`: Decimal
    - `entry_slippage`: Decimal
    - `exit_slippage`: Decimal
    - `total_slippage`: Decimal
    - `total_transaction_costs`: Decimal
    - `transaction_cost_pct`: Decimal (costs as % of trade value)
    - `transaction_cost_r_multiple`: Decimal (costs in R terms)
    - `gross_pnl`: Decimal (before costs)
    - `net_pnl`: Decimal (after costs)
    - `gross_r_multiple`: Decimal
    - `net_r_multiple`: Decimal
  - [ ] Subtask 8.4: Implement `analyze_backtest_costs(backtest_result: BacktestResult) -> BacktestCostSummary`:
    - Aggregate costs across all trades
    - Calculate total commissions paid
    - Calculate total slippage incurred
    - Calculate avg cost per trade
    - Calculate cost impact on metrics (gross vs net R-multiple)
  - [ ] Subtask 8.5: Create Pydantic model `BacktestCostSummary`:
    - `total_trades`: int
    - `total_commission_paid`: Decimal
    - `total_slippage_cost`: Decimal
    - `total_transaction_costs`: Decimal
    - `avg_commission_per_trade`: Decimal
    - `avg_slippage_per_trade`: Decimal
    - `avg_transaction_cost_per_trade`: Decimal
    - `cost_as_pct_of_total_pnl`: Decimal
    - `gross_avg_r_multiple`: Decimal
    - `net_avg_r_multiple`: Decimal
    - `r_multiple_degradation`: Decimal (gross - net)
  - [ ] Subtask 8.6: Add `cost_summary` field to BacktestResult model
  - [ ] Subtask 8.7: Unit tests:
    - Test single trade cost analysis (2.5R gross → 2.2R net after $50 commission + $30 slippage)
    - Test backtest-level cost aggregation (100 trades, various costs)
    - Test R-multiple degradation calculation

- [ ] **Task 9: Integration with BacktestEngine** (AC: 5, 7, 8)
  - [ ] Subtask 9.1: Modify `BacktestEngine.run_backtest()` in `backend/src/backtesting/engine.py`
  - [ ] Subtask 9.2: Add commission_config and slippage_config to BacktestConfig
  - [ ] Subtask 9.3: When filling orders, call `FillPriceCalculator.calculate_fill_price()`:
    - Pass order, next_bar, historical_bars, config
    - Get fill price with slippage applied
  - [ ] Subtask 9.4: Calculate commission using `CommissionCalculator.calculate_commission()`:
    - Pass order, commission_config
    - Deduct commission from cash/P&L
  - [ ] Subtask 9.5: Store commission_breakdown and slippage_breakdown in BacktestOrder
  - [ ] Subtask 9.6: Update BacktestTrade to include:
    - `entry_commission`, `exit_commission`
    - `entry_slippage`, `exit_slippage`
    - `total_commission`, `total_slippage`
    - `gross_pnl` (before costs), `net_pnl` (after costs)
    - `gross_r_multiple`, `net_r_multiple`
  - [ ] Subtask 9.7: After backtest completes, call `TransactionCostAnalyzer.analyze_backtest_costs()`:
    - Generate BacktestCostSummary
    - Attach to BacktestResult.cost_summary
  - [ ] Subtask 9.8: Update equity curve calculation to reflect costs:
    - Deduct commissions from cash immediately on order fill
    - Slippage already reflected in fill price
  - [ ] Subtask 9.9: Integration tests:
    - Run backtest with realistic commission/slippage config
    - Verify trades have commission and slippage applied
    - Verify net R-multiple < gross R-multiple
    - Verify cost summary calculated correctly

- [ ] **Task 10: Backtest Report Enhancements** (AC: 8, 10)
  - [ ] Subtask 10.1: Add cost breakdown section to BacktestResult
  - [ ] Subtask 10.2: Include in backtest report JSON:
    - cost_summary (BacktestCostSummary)
    - per_trade_costs (List[TransactionCostReport])
  - [ ] Subtask 10.3: Update API endpoint `GET /api/v1/backtest/results/{id}` to return cost data
  - [ ] Subtask 10.4: Create database migration to add cost columns to backtest_results table:
    - `total_commission_paid`: NUMERIC(12,2)
    - `total_slippage_cost`: NUMERIC(12,2)
    - `gross_avg_r_multiple`: NUMERIC(6,2)
    - `net_avg_r_multiple`: NUMERIC(6,2)
  - [ ] Subtask 10.5: Update BacktestRepository to serialize/deserialize cost data
  - [ ] Subtask 10.6: Integration test: verify cost data stored and retrieved via API

- [ ] **Task 11: Preset Broker Commission Profiles** (AC: 1)
  - [ ] Subtask 11.1: Create `CommissionProfiles` utility class in `backend/src/backtesting/commission_profiles.py`
  - [ ] Subtask 11.2: Define preset profiles for common brokers:
    - **Interactive Brokers Retail**: $0.005/share, min $1.00, max $0.5% of trade value
    - **Interactive Brokers Pro**: $0.0035/share, min $0.35
    - **TD Ameritrade**: $0/share (commission-free equities)
    - **E*TRADE**: $0/share (commission-free equities)
    - **Robinhood**: $0/share (commission-free)
    - **Fidelity**: $0/share (commission-free equities)
    - **Charles Schwab**: $0/share (commission-free equities)
  - [ ] Subtask 11.3: Implement `get_profile(broker_name: str) -> CommissionConfig`:
    - Return pre-configured CommissionConfig for broker
    - Raise ValueError if broker not found
  - [ ] Subtask 11.4: Implement `list_profiles() -> List[str]`:
    - Return list of available broker profile names
  - [ ] Subtask 11.5: Add broker profile selection to BacktestConfig:
    - `broker_profile`: Optional[str] (e.g., "Interactive Brokers Retail")
    - If set, auto-populate commission_config from profile
  - [ ] Subtask 11.6: Unit tests: verify all broker profiles return valid CommissionConfig
  - [ ] Subtask 11.7: Document broker profiles in code comments with last updated date

- [ ] **Task 12: Realistic Expectation Validation** (AC: 10)
  - [ ] Subtask 12.1: Create validation test in `backend/tests/integration/test_realistic_costs.py`
  - [ ] Subtask 12.2: Scenario: Theoretical 2.5R trade with IB commission and slippage
  - [ ] Subtask 12.3: Setup:
    - Entry: $100.00 (1,000 shares, $100,000 position)
    - Stop: $99.00 (1R = $1,000 risk)
    - Target: $102.50 (2.5R = $2,500 profit)
  - [ ] Subtask 12.4: Calculate costs:
    - Entry commission: 1,000 shares * $0.005 = $5.00
    - Exit commission: 1,000 shares * $0.005 = $5.00
    - Entry slippage (0.02%): $100 * 0.0002 * 1,000 = $20.00
    - Exit slippage (0.02%): $102.50 * 0.0002 * 1,000 = $20.50
    - Total costs: $50.50
  - [ ] Subtask 12.5: Expected results:
    - Gross P&L: $2,500
    - Net P&L: $2,500 - $50.50 = $2,449.50
    - Gross R-multiple: 2.5R
    - Net R-multiple: 2.449R (approximately 2.2R as per AC10)
  - [ ] Subtask 12.6: Run backtest with this scenario
  - [ ] Subtask 12.7: Assert net_r_multiple is approximately 2.2R to 2.4R (validates realistic cost impact)
  - [ ] Subtask 12.8: Document this as example in backtest documentation

- [ ] **Task 13: Edge Cases and Error Handling** (AC: 7, 9)
  - [ ] Subtask 13.1: Handle zero bar volume:
    - If fill_bar.volume = 0, use previous bar volume for liquidity calc
    - Log warning with structlog
    - Set volume_participation_pct = 0 (can't calculate participation)
  - [ ] Subtask 13.2: Handle missing historical bars for liquidity calculation:
    - If fewer than 20 bars available, use available bars
    - Log info message about reduced lookback period
    - Fallback: use low_liquidity_slippage_pct as conservative estimate
  - [ ] Subtask 13.3: Handle invalid limit order prices:
    - Limit price must be > 0
    - BUY limit must be < current market (can't buy above market with limit)
    - SELL limit must be > current market (can't sell below market with limit)
    - Raise ValueError if invalid
  - [ ] Subtask 13.4: Handle extreme market impact (>100% volume participation):
    - If order size > bar volume, log critical warning
    - Cap market impact slippage at reasonable max (e.g., 1%)
    - In live trading, this would be impossible (can't trade more than available)
  - [ ] Subtask 13.5: Handle commission calculation edge cases:
    - quantity = 0 → commission = $0
    - order_value = $0 → commission = min_commission
  - [ ] Subtask 13.6: Unit tests for all edge cases
  - [ ] Subtask 13.7: Integration test: backtest with intentionally problematic data (missing bars, zero volume)

- [ ] **Task 14: Performance Optimization** (AC: 9)
  - [ ] Subtask 14.1: Optimize liquidity calculation:
    - Pre-calculate 20-bar rolling avg dollar volume for entire dataset using pandas
    - Cache results in BacktestEngine to avoid recalculation per order
    - Target: no performance degradation vs BacktestEngine without costs
  - [ ] Subtask 14.2: Vectorize slippage calculations where possible:
    - Use pandas to calculate avg_dollar_volume for all bars at once
    - Store in DataFrame column for fast lookup
  - [ ] Subtask 14.3: Benchmark test:
    - Run backtest with 10,000 bars, commission and slippage enabled
    - Assert execution_time < 5 seconds (same as NFR7 target)
  - [ ] Subtask 14.4: Profile hot paths using cProfile if performance degrades

- [ ] **Task 15: Unit Testing** (AC: 9)
  - [ ] Subtask 15.1: Create `backend/tests/unit/test_commission_calculator.py`
  - [ ] Subtask 15.2: Test per-share commission calculation
  - [ ] Subtask 15.3: Test percentage commission calculation
  - [ ] Subtask 15.4: Test fixed commission calculation
  - [ ] Subtask 15.5: Test min/max commission caps
  - [ ] Subtask 15.6: Create `backend/tests/unit/test_slippage_calculator.py`
  - [ ] Subtask 15.7: Test liquidity-based slippage (high vs low liquidity)
  - [ ] Subtask 15.8: Test market impact calculation (various volume participation levels)
  - [ ] Subtask 15.9: Test slippage application to price (BUY vs SELL)
  - [ ] Subtask 15.10: Create `backend/tests/unit/test_fill_price_calculator.py`
  - [ ] Subtask 15.11: Test market order fill price calculation
  - [ ] Subtask 15.12: Test limit order fill logic (filled vs not filled)
  - [ ] Subtask 15.13: Test conservative limit order fills (worst-case fill prices)
  - [ ] Subtask 15.14: Create `backend/tests/unit/test_transaction_cost_analyzer.py`
  - [ ] Subtask 15.15: Test per-trade cost analysis
  - [ ] Subtask 15.16: Test backtest-level cost aggregation
  - [ ] Subtask 15.17: Test R-multiple degradation calculation
  - [ ] Subtask 15.18: Use factory-boy for generating test BacktestOrder, BacktestTrade fixtures

- [ ] **Task 16: Integration Testing** (AC: 5, 7, 8, 10)
  - [ ] Subtask 16.1: Create `backend/tests/integration/test_commission_slippage_integration.py`
  - [ ] Subtask 16.2: Test full backtest with commission and slippage enabled
  - [ ] Subtask 16.3: Use labeled pattern dataset from Story 12.2
  - [ ] Subtask 16.4: Configure realistic costs: IB commission + liquidity-based slippage
  - [ ] Subtask 16.5: Run backtest, verify all trades have commission and slippage applied
  - [ ] Subtask 16.6: Verify BacktestCostSummary calculated correctly
  - [ ] Subtask 16.7: Verify net_avg_r_multiple < gross_avg_r_multiple
  - [ ] Subtask 16.8: Verify cost impact on equity curve (lower than gross equity curve)
  - [ ] Subtask 16.9: Test with different broker profiles (IB, TD, Robinhood)
  - [ ] Subtask 16.10: Verify 2.5R theoretical → ~2.2R net as per AC10

- [ ] **Task 17: Documentation** (AC: 1, 2, 3, 4, 7, 10)
  - [ ] Subtask 17.1: Create `backend/docs/commission-and-slippage.md` guide:
    - Explain why realistic costs are critical for backtest validity
    - Document commission models (per-share, percentage, fixed)
    - Document slippage models (liquidity-based, market impact)
    - Provide formulas and examples for each calculation
    - Show realistic cost impact on R-multiples (2.5R → 2.2R example)
  - [ ] Subtask 17.2: Document broker commission profiles:
    - List all supported brokers
    - Show commission structures for each
    - Explain when to use which profile
  - [ ] Subtask 17.3: Document slippage configuration parameters:
    - Liquidity thresholds
    - Market impact thresholds
    - How to calibrate for different asset classes (stocks vs futures)
  - [ ] Subtask 17.4: Provide code examples:
    - Creating BacktestConfig with commission/slippage
    - Using broker profiles
    - Interpreting BacktestCostSummary results
  - [ ] Subtask 17.5: Add docstrings to all classes and methods
  - [ ] Subtask 17.6: Update main project README with link to commission/slippage docs

- [ ] **Task 18: Database Migration** (AC: 8)
  - [ ] Subtask 18.1: Create Alembic migration: `{timestamp}_add_commission_slippage_columns.py`
  - [ ] Subtask 18.2: Add columns to backtest_results table:
    - `total_commission_paid`: NUMERIC(12,2)
    - `total_slippage_cost`: NUMERIC(12,2)
    - `gross_avg_r_multiple`: NUMERIC(6,2)
    - `net_avg_r_multiple`: NUMERIC(6,2)
  - [ ] Subtask 18.3: Add columns to BacktestTrade-equivalent table (if stored separately):
    - `entry_commission`: NUMERIC(12,2)
    - `exit_commission`: NUMERIC(12,2)
    - `entry_slippage`: NUMERIC(12,2)
    - `exit_slippage`: NUMERIC(12,2)
  - [ ] Subtask 18.4: Run migration: `alembic upgrade head`
  - [ ] Subtask 18.5: Verify schema updates

## Dev Notes

### Epic 12 Context

This story is part of Epic 12: Backtesting & Validation Framework. It enhances the backtesting engine from Story 12.1 by adding realistic transaction costs (commission and slippage). This is critical because **backtests without realistic costs produce over-optimistic results** that don't match live trading performance.

**Key Problem**: A system that shows 3R average in backtests might only achieve 2.5R in live trading due to commissions and slippage. This story ensures backtest results are predictive of live performance.

**Dependencies**:
- Story 12.1 (Custom Backtesting Engine Architecture) must be complete
- BacktestEngine, BacktestOrder, BacktestTrade models must exist
- BacktestConfig model must be extensible for commission/slippage configs

### Previous Story Context

**Story 12.1 (Custom Backtesting Engine Architecture)** created the foundation:
- `BacktestEngine` class in `backend/src/backtesting/engine.py` [Source: docs/stories/epic-12/12.1.custom-backtesting-engine-architecture.md]
- Event-driven backtesting with bar-by-bar execution
- Order simulation and position tracking
- Basic slippage calculator (simplified version)
- Commission calculator (basic per-share model)
- This story ENHANCES those components with comprehensive models

**Story 12.4 (Walk-Forward Backtesting)** uses backtesting engine:
- Walk-forward testing validates out-of-sample performance
- Realistic costs are essential for accurate walk-forward results
- This story ensures walk-forward tests reflect live trading costs

### Commission Models Explained

**Why Commission Matters**:
Commission reduces net P&L on every trade. Even small commissions (< $10/trade) add up over hundreds of trades and can significantly impact overall performance.

**Commission Types**:

1. **Per-Share Commission** (Most common for active traders):
   - Charge: $X per share traded
   - Example: Interactive Brokers Retail: $0.005/share
   - 1,000 shares = $5.00 commission
   - Benefit: Scales with position size
   - Used by: Interactive Brokers, TradeStation

2. **Percentage Commission**:
   - Charge: X% of trade value
   - Example: 0.1% of $10,000 trade = $10.00
   - Benefit: Proportional to risk
   - Used by: Some international brokers, CFD brokers

3. **Fixed Commission**:
   - Charge: $X per trade regardless of size
   - Example: $1.00 per trade (or $0 for Robinhood)
   - Benefit: Predictable costs
   - Used by: Robinhood, E*TRADE, TD Ameritrade (now mostly $0)

**Min/Max Caps**:
- **Min commission**: Prevents tiny trades from being "free" (e.g., $1.00 minimum)
- **Max commission**: Caps costs on very large trades (e.g., max 0.5% of trade value)
- Example: IB charges $0.005/share but max 0.5% of trade value

### Slippage Models Explained

**What is Slippage?**
Slippage is the difference between the expected fill price and the actual fill price. It occurs because:
1. Market orders fill at the **next available price**, not the current quote
2. Your order consumes liquidity and moves the market (market impact)
3. Spread between bid and ask
4. Volatility during order execution

**Liquidity-Based Slippage** (AC2, AC3):
- **High liquidity** (avg daily dollar volume > $1M): 0.02% slippage
  - Example: AAPL, MSFT, GOOGL (very liquid)
  - $100 stock → slippage = $0.02 per share
- **Low liquidity** (avg daily dollar volume < $1M): 0.05% slippage
  - Example: Small-cap stocks, low-volume periods
  - $100 stock → slippage = $0.05 per share

**Why 20-bar Average Dollar Volume?**
- Uses rolling 20-bar average to capture recent liquidity trends
- Daily dollar volume = close_price * volume
- Smooths out daily spikes/dips in volume
- Reflects current market conditions better than static classification

**Market Impact Slippage** (AC4):
- **What**: Additional slippage when your order is large relative to bar volume
- **Threshold**: Orders > 10% of bar volume incur additional slippage
- **Incremental Impact**: +0.01% slippage per 10% increment above threshold
- **Example**:
  - Bar volume: 100,000 shares
  - Your order: 30,000 shares (30% participation)
  - Excess: 30% - 10% = 20% = 2 increments
  - Market impact: 2 * 0.01% = 0.02% additional slippage
  - Total slippage: 0.02% (base) + 0.02% (impact) = 0.04%

**Why Market Impact Matters**:
Large orders "move the market" because you're consuming significant liquidity. Other traders see your order and adjust prices. This is especially critical for:
- Low liquidity stocks
- Large position sizes
- Volatile markets

### Fill Price Calculation (AC5, AC6, AC7)

**Market Orders** (AC5):
- Fill at **next bar open** + slippage (realistic lag)
- BUY: fill_price = next_bar.open * (1 + slippage_pct)
  - Slippage increases cost (you pay more)
  - Example: $100 open + 0.02% = $100.02 fill
- SELL: fill_price = next_bar.open * (1 - slippage_pct)
  - Slippage decreases proceeds (you receive less)
  - Example: $100 open - 0.02% = $99.98 fill

**Limit Orders** (AC6):
- Fill only if price reaches limit during the bar
- **BUY limit**: Triggered if bar.low <= limit_price
  - Conservative fill: Use bar.high as fill price (worst case for buyer)
  - Example: Limit $100, bar low $99.50, bar high $100.20 → fill at $100.20
  - Why conservative? Can't assume you got filled at the low; assume worst case
- **SELL limit**: Triggered if bar.high >= limit_price
  - Conservative fill: Use bar.low as fill price (worst case for seller)
  - Example: Limit $100, bar high $100.50, bar low $99.80 → fill at $99.80
  - Why conservative? Can't assume you got filled at the high; assume worst case

**No Slippage on Limit Orders**:
- Limit orders specify max/min price, so no additional slippage applied
- But conservative fill assumption accounts for execution uncertainty

### Realistic Cost Impact (AC10)

**Example Trade Analysis**:
```
Setup:
- Entry: $100.00 (1,000 shares = $100,000 position)
- Stop Loss: $99.00 (1R risk = $1,000)
- Target: $102.50 (2.5R theoretical profit = $2,500)

Gross P&L (before costs): $2,500

Costs:
- Entry commission: 1,000 shares * $0.005 = $5.00
- Exit commission: 1,000 shares * $0.005 = $5.00
- Entry slippage: $100 * 0.0002 * 1,000 = $20.00
- Exit slippage: $102.50 * 0.0002 * 1,000 = $20.50
- Total costs: $50.50

Net P&L (after costs): $2,500 - $50.50 = $2,449.50

R-Multiples:
- Gross R-multiple: $2,500 / $1,000 = 2.5R
- Net R-multiple: $2,449.50 / $1,000 = 2.449R ≈ 2.4R

Impact: 0.1R reduction due to costs (4% degradation)
```

**Why This Matters**:
- A system averaging 2.5R per trade in "perfect" backtests...
- ...will only achieve ~2.2R to 2.4R in live trading after costs
- This story ensures backtests reflect this reality
- Prevents disappointment when live trading underperforms backtest expectations

### Data Models

**CommissionConfig** [Source: architecture/4-data-models.md patterns]:
```python
class CommissionConfig(BaseModel):
    commission_type: Literal["PER_SHARE", "PERCENTAGE", "FIXED"] = "PER_SHARE"
    commission_per_share: Decimal = Field(default=Decimal("0.005"))
    commission_percentage: Decimal = Field(default=Decimal("0"))
    fixed_commission_per_trade: Decimal = Field(default=Decimal("0"))
    min_commission: Decimal = Field(default=Decimal("1.00"))
    max_commission: Optional[Decimal] = None
    broker_name: str = "Interactive Brokers Retail"
```

**SlippageConfig** [Source: architecture/4-data-models.md patterns]:
```python
class SlippageConfig(BaseModel):
    slippage_model: Literal["LIQUIDITY_BASED", "FIXED_PERCENTAGE"] = "LIQUIDITY_BASED"
    high_liquidity_threshold: Decimal = Field(default=Decimal("1000000"))
    high_liquidity_slippage_pct: Decimal = Field(default=Decimal("0.0002"))
    low_liquidity_slippage_pct: Decimal = Field(default=Decimal("0.0005"))
    market_impact_enabled: bool = True
    market_impact_threshold_pct: Decimal = Field(default=Decimal("0.10"))
    market_impact_per_increment_pct: Decimal = Field(default=Decimal("0.0001"))
```

**BacktestCostSummary** (aggregate costs for entire backtest):
```python
class BacktestCostSummary(BaseModel):
    total_trades: int
    total_commission_paid: Decimal
    total_slippage_cost: Decimal
    total_transaction_costs: Decimal
    avg_commission_per_trade: Decimal
    avg_slippage_per_trade: Decimal
    gross_avg_r_multiple: Decimal
    net_avg_r_multiple: Decimal
    r_multiple_degradation: Decimal  # gross - net
```

### File Locations

[Source: architecture/10-unified-project-structure.md]

**New Backend Files**:
```
backend/
├── src/
│   ├── models/
│   │   └── backtest.py                     # MODIFY: Add CommissionConfig, SlippageConfig, BacktestCostSummary
│   ├── backtesting/
│   │   ├── commission_calculator.py        # CREATE: Commission calculation
│   │   ├── slippage_calculator.py          # ENHANCE: From 12.1, add liquidity + market impact
│   │   ├── liquidity_calculator.py         # CREATE: Liquidity analysis
│   │   ├── market_impact_calculator.py     # CREATE: Market impact slippage
│   │   ├── fill_price_calculator.py        # CREATE: Market + limit order fills
│   │   ├── transaction_cost_analyzer.py    # CREATE: Cost analysis and reporting
│   │   ├── commission_profiles.py          # CREATE: Preset broker profiles
│   │   └── engine.py                       # MODIFY: Integrate cost calculators
│   └── api/routes/
│       └── backtest.py                     # MODIFY: Return cost data in results
├── tests/
│   ├── unit/
│   │   ├── test_commission_calculator.py   # CREATE
│   │   ├── test_slippage_calculator.py     # CREATE
│   │   ├── test_fill_price_calculator.py   # CREATE
│   │   └── test_transaction_cost_analyzer.py # CREATE
│   └── integration/
│       ├── test_commission_slippage_integration.py # CREATE
│       └── test_realistic_costs.py         # CREATE (AC10 validation)
└── docs/
    └── commission-and-slippage.md          # CREATE
```

### Tech Stack

[Source: architecture/3-tech-stack.md]

**Core Technologies**:
- Python 3.11+ with Decimal type for financial precision
- Pydantic 2.5+ for data validation and TypeScript codegen
- pandas 2.2+ for vectorized liquidity calculations (20-bar rolling avg)
- FastAPI 0.109+ for API endpoints
- PostgreSQL 15+ for storing cost data (NUMERIC columns)

**Python Libraries**:
- `Decimal` for all financial calculations (commission, slippage, P&L) - NEVER use float [Source: architecture/15-coding-standards.md]
- pandas for rolling window calculations (avg dollar volume)
- structlog for logging cost calculations [Source: architecture/3-tech-stack.md]

### Testing Strategy

[Source: architecture/12-testing-strategy.md]

**Unit Tests** (`backend/tests/unit/`):
- Test each calculator independently (commission, slippage, liquidity, market impact)
- Test edge cases: zero volume, extreme participation, min/max caps
- Test all commission types (per-share, percentage, fixed)
- Test all slippage scenarios (high/low liquidity, market impact)
- Use factory-boy for generating test fixtures

**Integration Tests** (`backend/tests/integration/`):
- Full backtest with realistic costs (IB commission + liquidity-based slippage)
- Verify cost impact on R-multiples (2.5R → 2.2R as per AC10)
- Test different broker profiles (IB, TD, Robinhood)
- Verify cost summary calculations

**Performance Tests**:
- Ensure no performance degradation vs baseline BacktestEngine
- Target: 10,000 bars in <5 seconds (same as NFR7)
- Optimize liquidity calculations using pandas vectorization

### Coding Standards

[Source: architecture/15-coding-standards.md]

**Decimal Precision**:
- Use `Decimal` type for ALL financial values (commission, slippage, prices, P&L)
- NEVER use `float` for money calculations
- Example: `commission: Decimal = Field(..., decimal_places=2, max_digits=12)`

**Naming Conventions**:
- Classes: PascalCase (`CommissionCalculator`, `SlippageCalculator`)
- Functions: snake_case (`calculate_fill_price`, `apply_slippage_to_price`)
- Files: snake_case (`commission_calculator.py`, `fill_price_calculator.py`)

**Type Safety**:
- Complete type hints on all functions
- Use Literal types for enums (`Literal["BUY", "SELL"]`)
- Use Optional for nullable fields

### Error Handling

**Zero Bar Volume**:
- If fill_bar.volume = 0, use previous bar volume
- Log warning with structlog
- Set volume_participation_pct = 0

**Missing Historical Data**:
- If fewer than 20 bars for liquidity calc, use available bars
- Fallback to low_liquidity_slippage_pct as conservative estimate
- Log info message about reduced lookback period

**Invalid Limit Orders**:
- Validate: limit_price > 0
- Validate: BUY limit < market, SELL limit > market
- Raise ValueError if invalid

**Extreme Market Impact**:
- If order size > bar volume, log critical warning
- Cap market impact slippage at 1% max
- In reality, such orders would be impossible to fill

### Broker Commission Profiles

**Interactive Brokers Retail**:
- Per-share: $0.005/share
- Min: $1.00
- Max: 0.5% of trade value
- Use case: Active traders, medium-to-large positions

**Interactive Brokers Pro**:
- Per-share: $0.0035/share
- Min: $0.35
- Use case: High-volume traders, professionals

**TD Ameritrade / E*TRADE / Fidelity / Schwab**:
- Commission: $0 (commission-free equities)
- Use case: Retail investors, buy-and-hold

**Robinhood**:
- Commission: $0 (commission-free)
- Note: Payment for order flow may result in worse fill prices (not modeled here)
- Use case: Retail investors

### Performance Considerations

**Liquidity Calculation Optimization**:
- Pre-calculate 20-bar rolling avg dollar volume for entire dataset using pandas
- Store in DataFrame column: `df['avg_dollar_volume'] = (df['close'] * df['volume']).rolling(20).mean()`
- Cache in BacktestEngine to avoid recalculation per order
- Target: negligible overhead vs baseline BacktestEngine

**Vectorization**:
- Use pandas for all rolling window calculations (not loops)
- Calculate avg_dollar_volume for all bars at once, not per bar
- Store results in DataFrame for fast lookup during backtesting

## Testing

### Testing Framework
[Source: architecture/12-testing-strategy.md]

- Use pytest 8.0+ for all backend unit and integration tests
- Test files mirror source structure
- Unit tests: `backend/tests/unit/test_commission_calculator.py`, etc.
- Integration tests: `backend/tests/integration/test_commission_slippage_integration.py`

### Test Coverage Requirements
- Target 90%+ test coverage (NFR8)
- Cover all commission calculation types (per-share, percentage, fixed)
- Cover all slippage scenarios (high/low liquidity, market impact)
- Cover edge cases (zero volume, extreme participation, min/max caps)
- Cover integration with BacktestEngine

### Unit Test Requirements

**Commission Calculator Tests**:
- Per-share: 1,000 shares * $0.005 = $5.00
- Percentage: $10,000 * 0.001 = $10.00
- Fixed: $1.00 per trade
- Min cap: 10 shares * $0.005 = $0.05 → capped to $1.00 min
- Max cap: 100,000 shares * $0.005 = $500 → capped to $100 max

**Slippage Calculator Tests**:
- High liquidity (>$1M): 0.02% slippage
- Low liquidity (<$1M): 0.05% slippage
- Market impact: 30% volume participation → +0.02% slippage
- BUY slippage: $100 + 0.02% = $100.02
- SELL slippage: $100 - 0.02% = $99.98

**Fill Price Calculator Tests**:
- Market order: next_bar.open + slippage
- BUY limit: limit $100, bar low $99.50, high $100.20 → fill at $100.20
- SELL limit: limit $100, bar high $100.50, low $99.80 → fill at $99.80
- Limit not filled: BUY limit $100, bar low $100.10 → no fill

**Transaction Cost Analyzer Tests**:
- Single trade: 2.5R gross → 2.2R net after $50 costs
- Backtest-level: aggregate 100 trades, verify total costs
- R-multiple degradation: gross_r - net_r

### Integration Test Requirements

**Full Backtest with Realistic Costs**:
- Symbols: ["AAPL", "MSFT"]
- Date range: 2020-2024
- Commission: IB Retail ($0.005/share)
- Slippage: Liquidity-based + market impact
- Verify:
  - All trades have commission and slippage applied
  - BacktestCostSummary calculated correctly
  - net_avg_r_multiple < gross_avg_r_multiple
  - Cost impact on equity curve

**Realistic Expectations Validation (AC10)**:
- 2.5R theoretical trade
- Expected net R: ~2.2R to 2.4R after costs
- Verify actual results match expectations

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation with comprehensive commission and slippage modeling details | Bob (Scrum Master) |

## Dev Agent Record

_This section will be populated by the development agent during implementation._

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_This section will be populated by the QA agent after story completion._
