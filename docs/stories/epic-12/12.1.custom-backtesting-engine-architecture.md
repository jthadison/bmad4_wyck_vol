# Story 12.1: Custom Backtesting Engine Architecture

## Status
Draft

## Story
**As a** backtesting developer,
**I want** an event-driven backtesting engine that simulates realistic bar-by-bar execution,
**so that** backtest results accurately reflect live trading conditions.

## Acceptance Criteria
1. Event-driven architecture: process one bar at a time (no look-ahead bias)
2. Order simulation: market orders filled at next bar open (realistic slippage)
3. Commission model: $0.005/share (Interactive Brokers retail pricing)
4. Slippage model: 0.02% for liquid stocks (>$1M avg volume), 0.05% for less liquid
5. Position tracking: maintains open positions, tracks P&L, enforces risk limits
6. Bar-by-bar state: all detectors see only historical data up to current bar
7. Class: `BacktestEngine` with method `run_backtest(symbol, start_date, end_date, config) -> BacktestResult`
8. Validation: no future data leakage (strict unit test)
9. Performance: process 10,000 bars in <5 seconds
10. Output: BacktestResult with equity curve, trade list, metrics

## Tasks / Subtasks

- [ ] **Task 1: Backend - Backtesting Data Models** (AC: 7, 10)
  - [ ] Subtask 1.1: Create `BacktestConfig` Pydantic model in `backend/src/models/backtest.py`
  - [ ] Subtask 1.2: Fields: symbol, start_date, end_date, initial_capital, max_position_size, commission_per_share, slippage_model, slippage_percentage, risk_limits
  - [ ] Subtask 1.3: Create `BacktestOrder` model with fields: order_id, symbol, order_type (MARKET/LIMIT), side (BUY/SELL), quantity, limit_price, timestamps, fill_price, commission, slippage
  - [ ] Subtask 1.4: Create `BacktestPosition` model with fields: symbol, quantity, entry_price, current_price, unrealized_pnl, realized_pnl
  - [ ] Subtask 1.5: Create `BacktestTrade` model with fields: trade_id, symbol, entry/exit timestamps/prices, quantity, pnl, commission_total, slippage_total, r_multiple, pattern_type
  - [ ] Subtask 1.6: Create `EquityCurvePoint` model with fields: timestamp, portfolio_value, cash, positions_value, daily_return, cumulative_return
  - [ ] Subtask 1.7: Create `BacktestMetrics` model with fields: total_return_pct, cagr, sharpe_ratio, max_drawdown, win_rate, avg_r_multiple, profit_factor, trade counts
  - [ ] Subtask 1.8: Create `BacktestResult` model with fields: backtest_run_id, symbol, timeframe, dates, config, equity_curve, trades, metrics, look_ahead_bias_check, execution_time
  - [ ] Subtask 1.9: Unit test all models with Pydantic validation (pytest)
  - [ ] Subtask 1.10: Run `pydantic-to-typescript` to generate TypeScript types

- [ ] **Task 2: Backend - Slippage and Commission Calculator** (AC: 2, 3, 4)
  - [ ] Subtask 2.1: Create `SlippageCalculator` class in `backend/src/backtesting/slippage_calculator.py`
  - [ ] Subtask 2.2: Implement `calculate_slippage(bar, order_side, quantity, avg_volume) -> Decimal`
  - [ ] Subtask 2.3: Liquidity-based slippage: avg_volume > $1M → 0.02%, else 0.05%
  - [ ] Subtask 2.4: Market impact model: quantity > 10% of bar volume → add 0.01% per 10% increment
  - [ ] Subtask 2.5: Buy orders: slippage increases fill price (bar.open * (1 + slippage_pct))
  - [ ] Subtask 2.6: Sell orders: slippage decreases fill price (bar.open * (1 - slippage_pct))
  - [ ] Subtask 2.7: Create `CommissionCalculator` class in same file
  - [ ] Subtask 2.8: Implement `calculate_commission(quantity, commission_per_share) -> Decimal`
  - [ ] Subtask 2.9: Default commission: $0.005/share (configurable via BacktestConfig)
  - [ ] Subtask 2.10: Unit tests: verify slippage/commission calculations, test market impact scenarios (pytest)

- [ ] **Task 3: Backend - Order Simulator** (AC: 2, 4)
  - [ ] Subtask 3.1: Create `OrderSimulator` class in `backend/src/backtesting/order_simulator.py`
  - [ ] Subtask 3.2: Implement `submit_order(order, current_bar) -> BacktestOrder` with PENDING status
  - [ ] Subtask 3.3: Market orders stored as PENDING, to be filled at NEXT bar open
  - [ ] Subtask 3.4: Implement `fill_pending_orders(next_bar, avg_volume) -> List[BacktestOrder]`
  - [ ] Subtask 3.5: Fill market orders at next_bar.open + slippage using SlippageCalculator
  - [ ] Subtask 3.6: Calculate commission using CommissionCalculator
  - [ ] Subtask 3.7: Update order status to FILLED with filled_bar_timestamp, fill_price, commission, slippage
  - [ ] Subtask 3.8: Limit orders (optional): fill if price reaches limit during bar
  - [ ] Subtask 3.9: Use conservative fill assumptions: buy at high, sell at low
  - [ ] Subtask 3.10: Unit tests: verify market order fills at next bar, verify slippage/commission applied (pytest)

- [ ] **Task 4: Backend - Position Manager** (AC: 5)
  - [ ] Subtask 4.1: Create `PositionManager` class in `backend/src/backtesting/position_manager.py`
  - [ ] Subtask 4.2: State: positions dict (by symbol), cash, initial_capital
  - [ ] Subtask 4.3: Implement `open_position(order) -> BacktestPosition` - deduct cash, create/update position
  - [ ] Subtask 4.4: Calculate average entry price for multiple entries
  - [ ] Subtask 4.5: Implement `close_position(order) -> BacktestTrade` - add cash, calculate realized P&L
  - [ ] Subtask 4.6: Generate BacktestTrade record with P&L, R-multiple
  - [ ] Subtask 4.7: Implement `calculate_portfolio_value(current_bar) -> Decimal`
  - [ ] Subtask 4.8: Portfolio value = cash + sum(position qty * current price)
  - [ ] Subtask 4.9: Implement `calculate_unrealized_pnl(current_bar) -> Decimal`
  - [ ] Subtask 4.10: Unit tests: verify position open/close, P&L calculations, portfolio value (pytest)

- [ ] **Task 5: Backend - Event-Driven Backtest Engine Core** (AC: 1, 6, 7, 8, 9)
  - [ ] Subtask 5.1: Create `BacktestEngine` class in `backend/src/backtesting/engine.py`
  - [ ] Subtask 5.2: Dependencies: PositionManager, OrderSimulator, SlippageCalculator, PatternDetectionEngine, SignalGenerator
  - [ ] Subtask 5.3: Implement `run_backtest(symbol, start_date, end_date, config) -> BacktestResult`
  - [ ] Subtask 5.4: Load historical OHLCV bars from database via OHLCVRepository
  - [ ] Subtask 5.5: Initialize PositionManager with initial_capital
  - [ ] Subtask 5.6: Event loop: iterate bars chronologically (NO look-ahead)
  - [ ] Subtask 5.7: For each bar i: create historical_bars_slice = bars[0:i+1] (only past data)
  - [ ] Subtask 5.8: Pass historical_bars_slice to pattern detectors
  - [ ] Subtask 5.9: Run pattern detection on current bar with historical context only
  - [ ] Subtask 5.10: If pattern detected → generate signal using SignalGenerator
  - [ ] Subtask 5.11: If signal approved → submit market order via OrderSimulator
  - [ ] Subtask 5.12: Fill pending orders from previous bar using current bar as "next bar"
  - [ ] Subtask 5.13: Update positions via PositionManager
  - [ ] Subtask 5.14: Calculate portfolio value at end of bar
  - [ ] Subtask 5.15: Append EquityCurvePoint to equity_curve list
  - [ ] Subtask 5.16: Enforce risk limits: portfolio heat, max position size, campaign allocation
  - [ ] Subtask 5.17: If risk limit exceeded → reject signal with rejection_reason
  - [ ] Subtask 5.18: After event loop: calculate metrics using MetricsCalculator
  - [ ] Subtask 5.19: Set look_ahead_bias_check = True (verified by unit tests)
  - [ ] Subtask 5.20: Return BacktestResult with all data
  - [ ] Subtask 5.21: Performance optimization: use pandas vectorization for volume/spread ratios
  - [ ] Subtask 5.22: Unit tests: verify event-driven execution, verify 10,000 bars in <5 seconds (pytest)

- [ ] **Task 6: Backend - Look-Ahead Bias Validation** (AC: 8)
  - [ ] Subtask 6.1: Create `LookAheadBiasDetector` class in `backend/src/backtesting/bias_detector.py`
  - [ ] Subtask 6.2: Implement `detect_look_ahead_bias(trades, bars) -> bool`
  - [ ] Subtask 6.3: Verify entry_timestamp < exit_timestamp (chronological order)
  - [ ] Subtask 6.4: Verify entry_price matches bar.open (no "perfect" entry at bar.low)
  - [ ] Subtask 6.5: Verify pattern_bar_timestamp <= detection_time
  - [ ] Subtask 6.6: Verify test_bar_timestamp > pattern_bar_timestamp
  - [ ] Subtask 6.7: Return True if all checks pass
  - [ ] Subtask 6.8: Unit tests: create synthetic trades with intentional bias → verify detector catches them (pytest)
  - [ ] Subtask 6.9: Integration into BacktestEngine: run after backtest, set look_ahead_bias_check field

- [ ] **Task 7: Backend - Metrics Calculator** (AC: 10)
  - [ ] Subtask 7.1: Create `MetricsCalculator` class in `backend/src/backtesting/metrics.py`
  - [ ] Subtask 7.2: Implement `calculate_metrics(equity_curve, trades, initial_capital) -> BacktestMetrics`
  - [ ] Subtask 7.3: Calculate total_return_pct: ((final_value - initial_capital) / initial_capital) * 100
  - [ ] Subtask 7.4: Calculate CAGR: ((final_value / initial_capital) ^ (1 / years)) - 1
  - [ ] Subtask 7.5: Calculate Sharpe ratio: (avg_daily_return - risk_free_rate) / std_dev * sqrt(252)
  - [ ] Subtask 7.6: Calculate max_drawdown: track peak, calculate max % drop from peak
  - [ ] Subtask 7.7: Calculate max_drawdown_duration_days
  - [ ] Subtask 7.8: Calculate win_rate: winning_trades / total_trades
  - [ ] Subtask 7.9: Calculate avg_r_multiple: sum(r_multiple) / total_trades
  - [ ] Subtask 7.10: Calculate profit_factor: sum(winning_pnl) / abs(sum(losing_pnl))
  - [ ] Subtask 7.11: Count total_trades, winning_trades, losing_trades
  - [ ] Subtask 7.12: Unit tests: verify metrics with known datasets, test edge cases (pytest)

- [ ] **Task 8: Backend - Backtest API Endpoint** (AC: 7)
  - [ ] Subtask 8.1: Create `POST /api/v1/backtest/run` route in `backend/src/api/routes/backtest.py`
  - [ ] Subtask 8.2: Request body: BacktestConfig model
  - [ ] Subtask 8.3: Validate config: date range, symbol exists, initial_capital > 0
  - [ ] Subtask 8.4: Execute BacktestEngine.run_backtest() as BackgroundTask
  - [ ] Subtask 8.5: Return immediately with backtest_run_id and status: RUNNING
  - [ ] Subtask 8.6: Create `GET /api/v1/backtest/results/{backtest_run_id}` route
  - [ ] Subtask 8.7: Return BacktestResult if completed, status: RUNNING if in progress, 404 if not found
  - [ ] Subtask 8.8: Create `GET /api/v1/backtest/results` route for listing (paginated)
  - [ ] Subtask 8.9: Query parameters: symbol (optional filter), limit, offset
  - [ ] Subtask 8.10: Store BacktestResult in database via BacktestRepository
  - [ ] Subtask 8.11: Unit tests: test endpoints with mock BacktestEngine (pytest)
  - [ ] Subtask 8.12: Integration test: run full backtest via API, retrieve results (pytest)

- [ ] **Task 9: Backend - Backtest Repository** (AC: 10)
  - [ ] Subtask 9.1: Create `BacktestRepository` class in `backend/src/repositories/backtest_repository.py`
  - [ ] Subtask 9.2: Implement `save_result(result: BacktestResult) -> UUID`
  - [ ] Subtask 9.3: Store BacktestResult in backtest_results table
  - [ ] Subtask 9.4: Store equity_curve as JSONB (serialize List[EquityCurvePoint])
  - [ ] Subtask 9.5: Store trades as JSONB (serialize List[BacktestTrade])
  - [ ] Subtask 9.6: Store config as JSONB
  - [ ] Subtask 9.7: Implement `get_result(backtest_run_id) -> Optional[BacktestResult]`
  - [ ] Subtask 9.8: Deserialize JSONB fields back to Pydantic models
  - [ ] Subtask 9.9: Implement `list_results(symbol, limit, offset) -> List[BacktestResult]`
  - [ ] Subtask 9.10: Filter by symbol if provided, order by created_at DESC
  - [ ] Subtask 9.11: Unit tests: verify save/retrieve with full BacktestResult, test pagination (pytest)

- [ ] **Task 10: Backend - Integration with Pattern Detection Engine** (AC: 1, 6)
  - [ ] Subtask 10.1: Create `BarSequence` interface in `backend/src/backtesting/bar_sequence.py`
  - [ ] Subtask 10.2: BarSequence provides: get_bars(start_index, end_index), get_bar(index), length()
  - [ ] Subtask 10.3: Implementation 1: `LiveBarSequence` - real-time bars from market data service
  - [ ] Subtask 10.4: Implementation 2: `BacktestBarSequence` - historical bars with chronological access enforcement
  - [ ] Subtask 10.5: BacktestBarSequence only returns bars[0:current_index+1] (prevents look-ahead)
  - [ ] Subtask 10.6: Modify SpringDetector, SOSDetector, UTADDetector to accept BarSequence
  - [ ] Subtask 10.7: Update PatternDetectionEngine to use BarSequence
  - [ ] Subtask 10.8: Update SignalGenerator to use BarSequence
  - [ ] Subtask 10.9: Unit tests: verify BarSequence prevents future data access (pytest)

- [ ] **Task 11: Backend - Performance Benchmarking** (AC: 9)
  - [ ] Subtask 11.1: Create benchmark test in `backend/tests/benchmarks/test_backtest_performance.py`
  - [ ] Subtask 11.2: Generate synthetic OHLCV dataset: 10,000 bars with realistic price/volume
  - [ ] Subtask 11.3: Run BacktestEngine.run_backtest() with synthetic data
  - [ ] Subtask 11.4: Measure execution time using time.perf_counter()
  - [ ] Subtask 11.5: Assert execution_time < 5 seconds (NFR7: 100+ bars/second)
  - [ ] Subtask 11.6: Profile hot paths using cProfile or py-spy
  - [ ] Subtask 11.7: Optimize using pandas vectorization for volume/spread ratios
  - [ ] Subtask 11.8: Cache intermediate calculations: 20-bar rolling averages
  - [ ] Subtask 11.9: Re-run benchmark, verify <5 second target met
  - [ ] Subtask 11.10: Add benchmark to CI pipeline: fail if performance regresses >10% (pytest-benchmark)

- [ ] **Task 12: Backend - Database Migration** (AC: 10)
  - [ ] Subtask 12.1: Create Alembic migration: `{timestamp}_add_backtest_tables.py`
  - [ ] Subtask 12.2: Add columns to backtest_results table: equity_curve JSONB, trades JSONB, execution_time_seconds NUMERIC
  - [ ] Subtask 12.3: Add indexes for performance: idx_backtest_symbol, idx_backtest_created_at
  - [ ] Subtask 12.4: Run migration: `alembic upgrade head`
  - [ ] Subtask 12.5: Verify schema matches architecture/9-database-schema.md

- [ ] **Task 13: Backend - Type Generation and OpenAPI Update** (AC: 7)
  - [ ] Subtask 13.1: Run `pydantic-to-typescript` to generate TypeScript types
  - [ ] Subtask 13.2: Verify generated types in `frontend/src/types/`: BacktestConfig.ts, BacktestResult.ts, etc.
  - [ ] Subtask 13.3: Update FastAPI OpenAPI schema with /api/v1/backtest/* endpoints
  - [ ] Subtask 13.4: Verify OpenAPI docs at http://localhost:8000/docs

- [ ] **Task 14: Integration Testing** (AC: All)
  - [ ] Subtask 14.1: Integration test: run full backtest with labeled pattern dataset (pytest)
  - [ ] Subtask 14.2: Load labeled patterns from `backend/tests/fixtures/labeled_patterns.json`
  - [ ] Subtask 14.3: Run backtest on symbols/dates from labeled dataset
  - [ ] Subtask 14.4: Verify detected patterns match labeled patterns (within tolerance)
  - [ ] Subtask 14.5: Verify trades generated for valid patterns
  - [ ] Subtask 14.6: Verify equity curve shows expected P&L trajectory
  - [ ] Subtask 14.7: Verify metrics calculated correctly: win_rate, avg_r_multiple, max_drawdown
  - [ ] Subtask 14.8: Verify look_ahead_bias_check = True
  - [ ] Subtask 14.9: Integration test: verify backtest results stored and retrievable via API (pytest)
  - [ ] Subtask 14.10: Integration test: verify performance target with real pattern detection (pytest)

## Dev Notes

### Epic Context
This story is part of Epic 12 (Backtesting & Validation Framework) which delivers the system validation infrastructure that proves the edge exists before live deployment (NFR18, NFR21). Story 12.1 implements the foundational event-driven backtesting engine that will be used by subsequent stories for detector accuracy testing (12.3), walk-forward validation (12.4), and regression testing automation (12.7).

### Tech Stack - Backtesting
[Source: docs/architecture/3-tech-stack.md]

**Core Technologies:**
- Backend Framework: FastAPI 0.109+ with BackgroundTasks for long-running backtests
- Database: PostgreSQL 15+ with JSONB for storing equity curves and trade lists
- Data Processing: pandas 2.2+ for vectorized OHLCV calculations, numpy 1.26+ for numerical operations
- Testing: pytest 8.0+ with pytest-mock, factory-boy for generating synthetic OHLCV data
- Performance: Target 100+ bars/second (NFR7), use pandas vectorization to meet <5 second target for 10,000 bars

**Python Libraries:**
- `Decimal` type for all financial calculations (prices, P&L, commission, slippage) to prevent floating-point precision errors
- SQLAlchemy 2.0+ async for database operations
- Pydantic 2.5+ for data validation and TypeScript type generation

### Data Models - Backtesting
[Source: docs/architecture/4-data-models.md, Epic 12 requirements]

**New Pydantic Models** (defined in `backend/src/models/backtest.py`):

All models use `Decimal` for financial values and `datetime` with UTC timezone enforcement.

```python
from decimal import Decimal
from datetime import datetime, date
from typing import List, Optional, Literal, Dict
from pydantic import BaseModel, Field
from uuid import UUID

class BacktestConfig(BaseModel):
    symbol: str
    start_date: date
    end_date: date
    initial_capital: Decimal = Field(default=Decimal("100000"))
    max_position_size: Decimal = Field(default=Decimal("0.02"))  # 2% per trade
    commission_per_share: Decimal = Field(default=Decimal("0.005"))  # IB retail
    slippage_model: Literal["PERCENTAGE", "FIXED"] = "PERCENTAGE"
    slippage_percentage: Decimal = Field(default=Decimal("0.0002"))  # 0.02%
    risk_limits: Dict  # {"max_portfolio_heat": 0.10, "max_campaign_risk": 0.05}

class BacktestOrder(BaseModel):
    order_id: UUID
    symbol: str
    order_type: Literal["MARKET", "LIMIT"]
    side: Literal["BUY", "SELL"]
    quantity: int
    limit_price: Optional[Decimal] = None
    created_bar_timestamp: datetime
    filled_bar_timestamp: Optional[datetime] = None
    fill_price: Optional[Decimal] = None
    commission: Decimal = Decimal("0")
    slippage: Decimal = Decimal("0")
    status: Literal["PENDING", "FILLED", "REJECTED"]

class BacktestTrade(BaseModel):
    trade_id: UUID
    symbol: str
    entry_timestamp: datetime
    exit_timestamp: datetime
    entry_price: Decimal
    exit_price: Decimal
    quantity: int
    pnl: Decimal  # Realized P&L after commission and slippage
    commission_total: Decimal
    slippage_total: Decimal
    r_multiple: Decimal
    pattern_type: str

class BacktestMetrics(BaseModel):
    total_return_pct: Decimal
    cagr: Decimal
    sharpe_ratio: Decimal
    max_drawdown: Decimal
    max_drawdown_duration_days: int
    win_rate: Decimal
    avg_r_multiple: Decimal
    profit_factor: Decimal
    total_trades: int
    winning_trades: int
    losing_trades: int

class BacktestResult(BaseModel):
    backtest_run_id: UUID
    symbol: str
    timeframe: str
    start_date: date
    end_date: date
    config: BacktestConfig
    equity_curve: List[EquityCurvePoint]
    trades: List[BacktestTrade]
    metrics: BacktestMetrics
    look_ahead_bias_check: bool
    execution_time_seconds: float
    created_at: datetime
```

### File Locations
[Source: docs/architecture/10-unified-project-structure.md]

**Backend Files to Create:**

```
backend/
├── src/
│   ├── api/routes/
│   │   └── backtest.py                     # CREATE: API endpoints
│   ├── models/
│   │   └── backtest.py                     # CREATE: Pydantic models
│   ├── repositories/
│   │   └── backtest_repository.py          # CREATE: Database access
│   ├── backtesting/                        # CREATE: New module
│   │   ├── engine.py                       # CREATE: BacktestEngine
│   │   ├── slippage_calculator.py          # CREATE: Slippage + Commission
│   │   ├── order_simulator.py              # CREATE: Order fills
│   │   ├── position_manager.py             # CREATE: Position tracking
│   │   ├── metrics.py                      # CREATE: Metrics calculation
│   │   ├── bias_detector.py                # CREATE: Look-ahead bias validation
│   │   └── bar_sequence.py                 # CREATE: BarSequence abstraction
│   └── pattern_engine/
│       └── *.py                            # MODIFY: Accept BarSequence
├── tests/
│   ├── unit/                               # CREATE: Unit tests
│   ├── integration/                        # CREATE: Integration tests
│   └── benchmarks/                         # CREATE: Performance benchmarks
└── alembic/versions/
    └── {timestamp}_add_backtest_tables.py  # CREATE: Migration
```

### Technical Constraints

**Event-Driven Architecture (AC1, AC6):**
BacktestEngine MUST process bars sequentially. Pattern detectors receive ONLY historical bars up to current bar index.

**Order Fill Simulation (AC2):**
Market orders submitted on bar N are filled at bar N+1 open price + slippage.

**Slippage Model (AC4):**
- Liquidity-based: avg_volume > $1M → 0.02%, else 0.05%
- Market impact: quantity > 10% bar volume → add 0.01% per 10% increment
- Buy: fill_price = next_bar.open * (1 + total_slippage)
- Sell: fill_price = next_bar.open * (1 - total_slippage)

**Risk Limit Enforcement (AC5):**
Before submitting order, check portfolio heat (10%), campaign allocation (5%), position size (2%). Reject if exceeded.

**Performance (AC9):**
Target: 10,000 bars in <5 seconds = 2,000 bars/second.
Optimizations: pandas vectorization, caching 20-bar rolling averages, minimal database queries.

**Look-Ahead Bias Detection (AC8):**
Validate: chronological order, entry prices match bar.open, pattern detection times valid, test confirmations after patterns.

### Testing

**Unit Tests (pytest):**
[Source: docs/architecture/12-testing-strategy.md]
- Location: `backend/tests/unit/test_*.py`
- Coverage: 80% minimum
- Test: slippage, commission, order fills, position management, metrics, bias detection

**Integration Tests (pytest):**
- Location: `backend/tests/integration/test_backtest_engine.py`
- Full end-to-end backtest with labeled pattern dataset
- Verify patterns, trades, equity curve, metrics, API storage/retrieval

**Performance Benchmarks (pytest-benchmark):**
- Location: `backend/tests/benchmarks/test_backtest_performance.py`
- 10,000 synthetic bars, assert execution_time < 5 seconds
- Run in CI, fail if regression >10%

### Coding Standards
[Source: docs/architecture/15-coding-standards.md]

- Use `Decimal` for ALL financial calculations (NEVER float)
- Use `datetime` with UTC timezone
- Classes: PascalCase, Functions: snake_case
- Complete type annotations, run mypy in strict mode

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story draft created with comprehensive technical details from PRD Epic 12 and Architecture docs | Scrum Master (Bob) |

## Dev Agent Record

### Agent Model Used
_To be populated by dev agent during implementation_

### Debug Log References
_To be populated by dev agent during implementation_

### Completion Notes List
_To be populated by dev agent during implementation_

### File List
_To be populated by dev agent during implementation_

## QA Results
_To be populated by QA agent during testing_
