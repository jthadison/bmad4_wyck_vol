# Story 0.6: Asset-Class Integration Testing

## Status
Done
**Done**

**Priority:** ðŸŸ¡ HIGH
**Estimate:** 9 story points
**Dependencies:** Story 0.5 (Detector Refactoring), Story 5.6 (Multi-Spring Detection)

**Epic:** Epic 0 - Asset-Class Abstraction Layer
**Sprint:** Sprint 1 (Week 3 - Full Week)

## Story

**As a** developer,
**I want** comprehensive integration tests for multi-asset scenarios,
**so that** stock and forex confidence scoring work correctly end-to-end.

## Context

Epic 0 Stories 0.1-0.5 have created the asset-class abstraction layer:
- `ConfidenceScorer` abstract base class (Story 0.1)
- `StockConfidenceScorer` preserving existing logic (Story 0.2)
- `ForexConfidenceScorer` with adapted scoring (Story 0.3)
- `ScorerFactory` for auto-detection (Story 0.4)
- Refactored detectors using factory (Story 0.5)

Now we need comprehensive integration tests to validate the entire system works correctly across asset classes, with proper confidence score differentiation, position sizing implications, multi-spring campaign validation, and acceptable performance.

## Acceptance Criteria

1. **Create integration test suite:** `backend/tests/integration/pattern_engine/test_multi_asset_confidence.py`

2. **Test stock spring detection end-to-end** (AAPL, SPY):
   - Detect spring with `symbol="AAPL"`
   - Verify `asset_class="stock"`, `volume_reliability="HIGH"`
   - Verify max confidence 100 (stock ceiling)
   - Verify component weights (Story 5.4 formula):
     - Volume Quality: 40 points
     - Penetration Depth: 35 points
     - Recovery Speed: 25 points
     - Creek Strength Bonus: +10 points (if applicable)
     - Volume Trend Bonus: +10 points (if declining)
   - Compare against known historical AAPL spring (March 2020 example)

3. **Test forex spring detection end-to-end** (EUR/USD, GBP/USD):
   - Detect spring with `symbol="EUR/USD"`
   - Verify `asset_class="forex"`, `volume_reliability="LOW"`
   - Verify max confidence 85 (forex ceiling)
   - Verify volume weight 10 points (forex formula)
   - Ensure confidence never exceeds 85 even with perfect pattern:
     - Define "perfect pattern": 1.5% penetration, 0.3x volume, 1-bar recovery, 80+ Creek strength, DECLINING volume trend
     - Expected raw score: 120 points (40+35+25+10+10)
     - Forex normalized: (120/120) * 85 = 85 (CAPPED)

4. **Test CFD index spring detection** (US30, NAS100):
   - Detect spring with `symbol="US30"`
   - Verify `asset_class="forex"` (CFDs treated as forex)
   - Verify tick volume handling (10pts max)
   - Test with NAS100, SPX500 symbols

5. **Test stock SOS detection end-to-end**:
   - Detect SOS with `symbol="SPY"`
   - Verify stock scoring (35pts volume, max 100+ confidence)
   - Test LPS bonus (+15pts for stock):
     - Direct SOS entry: Baseline 65 (5% stop)
     - LPS entry: Baseline 75 (+10 for 3% stop)
   - Verify LPS entry scores 10+ points higher than direct entry

6. **Test forex SOS detection end-to-end**:
   - Detect SOS with `symbol="GBP/USD"`
   - Verify forex scoring (10pts volume, max 85 confidence)
   - Test LPS bonus (+10pts for forex):
     - Direct SOS entry: Baseline 60 (5% pips)
     - LPS entry: Baseline 70 (+10 for 3% pips)
   - Verify forex baselines are 5 points lower than stocks (tick volume discount)

7. **Verify confidence score differences WITH position sizing implications:**
   - Stock max: 100
   - Forex max: 85
   - Stock volume weight: 40 points (Spring) / 35 points (SOS)
   - Forex volume weight: 10 points
   - **Position Sizing Analysis:**
     - Calculate confidence tier and multiplier for identical patterns
     - Show account risk % for $100k account, 2% max risk
     - Document position size difference in USD and percentage
     - Explain why forex requires smaller positions (tick volume lacks institutional confirmation)
   - Document differences in test output with educational commentary

8. **Performance benchmarks:**
   - Spring detection: <150ms for 500-bar sequence
   - SOS detection: <150ms for 500-bar sequence
   - ScorerFactory overhead: <1ms per symbol
   - Memory: No leaks from scorer caching

9. **Test multi-spring campaigns across asset classes:**
   - Stock 3-spring DECLINING volume campaign:
     - Volume trend: DECLINING (0.6x â†’ 0.5x â†’ 0.3x)
     - Risk level: LOW (professional accumulation)
     - Best spring: Lowest volume (Spring 3)
   - Forex 3-spring DECLINING volume campaign:
     - Same campaign structure as stock
     - Each spring confidence caps at 85
     - Campaign characteristics identical (volume trend, risk level)
   - Stock vs forex campaign comparison:
     - Campaign structure identical (volume trend, risk level, spring count)
     - Individual spring confidence differs (stock higher)
   - RISING volume campaign (distribution warning):
     - Volume trend: RISING (0.3x â†’ 0.5x â†’ 0.65x)
     - Risk level: HIGH (distribution warning)
     - Best spring: FIRST (lowest volume in rising trend)
   - Verify `SpringHistory.volume_trend` and `risk_level` work identically across asset classes

10. **Verify minimum confidence threshold enforcement:**
    - Patterns scoring <70 confidence are rejected (or don't generate signals)
    - Threshold is consistent across asset classes (no special treatment for forex)
    - Boundary cases: 69 rejected, 70 accepted
    - Test that signal generation enforces minimum threshold

## Tasks / Subtasks

### **Task 1: Create integration test module** (AC: 1)

- [ ] Create file: `backend/tests/integration/pattern_engine/test_multi_asset_confidence.py`
- [ ] Add imports:
  ```python
  import pytest
  import time
  import gc
  from decimal import Decimal
  from backend.src.pattern_engine.detectors.spring_detector import (
      detect_spring, SpringDetector, calculate_spring_confidence
  )
  from backend.src.pattern_engine.detectors.sos_detector import (
      detect_sos, calculate_sos_confidence
  )
  from backend.src.pattern_engine.scoring.scorer_factory import detect_asset_class
  from backend.src.models.wyckoff_phase import WyckoffPhase
  # ... other imports
  ```
- [ ] Create test fixtures for stock, forex, and CFD market data
- [ ] Create helper functions:
  - `create_spring_bars()` - Generate spring pattern fixtures
  - `create_perfect_spring_bars()` - Generate perfect spring for ceiling tests
  - `create_three_spring_campaign()` - Generate multi-spring campaigns
  - `get_confidence_tier()` - Map confidence to position multiplier

### **Task 2: Stock spring integration tests** (AC: 2)

- [ ] Test AAPL spring detection:
  ```python
  def test_stock_spring_detection_aapl():
      # Setup: AAPL market data with spring pattern
      spring = detect_spring(range, bars, WyckoffPhase.C, symbol="AAPL")

      assert spring is not None
      assert spring.asset_class == "stock"
      assert spring.volume_reliability == "HIGH"

      # Calculate confidence
      confidence = calculate_spring_confidence(spring, creek, [])
      assert confidence.total_score <= 100
      assert confidence.total_score >= 70  # Minimum for signal
  ```

- [ ] Test stock spring component scores (Amendment 1):
  ```python
  def test_stock_spring_component_scores():
      """Verify Spring uses 40pts volume weight for stocks."""
      spring = detect_spring(range, bars, WyckoffPhase.C, symbol="AAPL")
      confidence = calculate_spring_confidence(spring, creek, [])

      # Verify component score structure
      assert "volume_quality" in confidence.component_scores
      assert confidence.component_scores["volume_quality"] <= 40
      assert confidence.component_scores["penetration_depth"] <= 35
      assert confidence.component_scores["recovery_speed"] <= 25

      # Bonuses (if applicable)
      if "creek_strength_bonus" in confidence.component_scores:
          assert confidence.component_scores["creek_strength_bonus"] <= 10
      if "volume_trend_bonus" in confidence.component_scores:
          assert confidence.component_scores["volume_trend_bonus"] <= 10
  ```

- [ ] Test perfect stock spring (Amendment 2):
  ```python
  def test_stock_perfect_spring_confidence_100():
      """Perfect pattern should hit 100 for stocks."""
      # Create perfect spring fixture
      creek_level = Decimal("100.00")
      perfect_bars = create_perfect_spring_bars(
          creek_level=creek_level,
          penetration_pct=Decimal("0.015"),  # 1.5%
          volume_ratio=Decimal("0.29"),      # 0.29x (ultra-low)
          recovery_bars=1,                    # Immediate
          symbol="AAPL"
      )

      creek = create_strong_creek(
          price=creek_level,
          strength_score=85,
          touch_count=4,
          volume_trend="DECREASING"
      )

      spring = detect_spring(range, perfect_bars, WyckoffPhase.C, "AAPL")
      confidence = calculate_spring_confidence(spring, creek, [])

      assert confidence.total_score == 100, (
          f"Perfect stock spring should score 100, got {confidence.total_score}"
      )
  ```

- [ ] Test SPY spring detection (similar structure)
- [ ] Test with historical March 2020 AAPL data (if available)

### **Task 3: Forex spring integration tests** (AC: 3)

- [ ] Test EUR/USD spring detection:
  ```python
  def test_forex_spring_detection_eurusd():
      spring = detect_spring(range, bars, WyckoffPhase.C, symbol="EUR/USD")

      assert spring is not None
      assert spring.asset_class == "forex"
      assert spring.volume_reliability == "LOW"

      confidence = calculate_spring_confidence(spring, creek, [])
      assert confidence.total_score <= 85  # Forex max
      assert confidence.total_score >= 70  # Still meets minimum
  ```

- [ ] Test GBP/USD spring detection

- [ ] Test perfect forex spring confidence cap (Amendment 2):
  ```python
  def test_forex_perfect_spring_confidence_cap():
      """
      Test that PERFECT spring pattern caps at 85 for forex.

      Perfect Spring Definition (Wyckoff textbook example):
      - Penetration: 1.5% below Creek (ideal 1-2% range)
      - Volume: 0.3x average (ultra-low, <0.3x tier = 40pts)
      - Recovery: 1 bar (immediate demand = 25pts)
      - Creek Strength: 80+ (3+ successful tests = 10pts bonus)
      - Volume Trend: DECLINING across 3+ tests (10pts bonus)

      Expected Raw Score: 40 + 35 + 25 + 10 + 10 = 120 points

      Stock Normalized: (120/120) * 100 = 100 confidence
      Forex Normalized: (120/120) * 85 = 85 confidence (CAPPED)

      This test PROVES the humility tax in action.
      """
      # Create perfect spring fixture
      creek_level = Decimal("1.1000")
      perfect_bars = create_perfect_spring_bars(
          creek_level=creek_level,
          penetration_pct=Decimal("0.015"),  # 1.5%
          volume_ratio=Decimal("0.29"),      # 0.29x (ultra-low)
          recovery_bars=1,                    # Immediate
          symbol="EUR/USD"
      )

      # Create Creek with 80+ strength
      creek = create_strong_creek(
          price=creek_level,
          strength_score=85,
          touch_count=4,
          volume_trend="DECREASING"
      )

      # Detect spring
      spring = detect_spring(range, perfect_bars, WyckoffPhase.C, "EUR/USD")
      assert spring is not None

      # Calculate confidence
      confidence = calculate_spring_confidence(spring, creek, [])

      # CRITICAL: Forex perfect pattern caps at 85, not 100
      assert confidence.total_score == 85, (
          f"Perfect forex spring should cap at 85, got {confidence.total_score}"
      )

      # Document components
      logger.info(
          "perfect_spring_forex_cap_test",
          volume_score=confidence.component_scores["volume_quality"],
          penetration_score=confidence.component_scores["penetration_depth"],
          recovery_score=confidence.component_scores["recovery_speed"],
          creek_bonus=confidence.component_scores.get("creek_strength_bonus", 0),
          volume_trend_bonus=confidence.component_scores.get("volume_trend_bonus", 0),
          raw_score=sum(confidence.component_scores.values()),
          normalized_score=confidence.total_score,
          message="Perfect pattern demonstrates forex 85-point ceiling"
      )
  ```

### **Task 4: CFD index integration tests** (AC: 4)

- [ ] Test US30 (Dow Jones CFD):
  ```python
  def test_cfd_spring_detection_us30():
      spring = detect_spring(range, bars, WyckoffPhase.C, symbol="US30")

      assert spring is not None
      assert spring.asset_class == "forex"  # CFDs use forex scoring
      assert spring.volume_reliability == "LOW"

      confidence = calculate_spring_confidence(spring, creek, [])
      assert confidence.total_score <= 85
  ```
- [ ] Test NAS100, SPX500
- [ ] Verify CFD symbols correctly detected as forex by factory

### **Task 5: Stock SOS integration tests** (AC: 5)

- [ ] Test SPY SOS detection:
  ```python
  def test_stock_sos_detection_spy():
      sos = detect_sos(range, bars, volume_analysis, WyckoffPhase.D, symbol="SPY")

      assert sos is not None
      assert sos.asset_class == "stock"

      confidence = calculate_sos_confidence(sos, ice, "DIRECT")
      assert confidence.total_score >= 70
      # Verify volume weight 35pts
  ```

- [ ] Test stock SOS LPS entry bonus (Amendment 6):
  ```python
  def test_stock_sos_lps_entry_bonus():
      """
      Test LPS entry receives proper baseline adjustment for stocks.

      Story 6.5 Confidence Scoring:
      - Direct SOS entry: Baseline 65 (higher risk, 5% stop)
      - LPS entry: Baseline 75 (+10 for lower risk, 3% stop)
      """
      # Detect SOS breakout
      sos = detect_sos(range, bars, volume_analysis, WyckoffPhase.D, symbol="SPY")
      assert sos is not None
      assert sos.asset_class == "stock"

      # Calculate confidence for direct SOS entry
      direct_confidence = calculate_sos_confidence(
          sos=sos,
          ice=range.ice,
          entry_type="DIRECT",  # 5% stop, baseline 65
      )

      # Calculate confidence for LPS entry (pullback after SOS)
      lps_confidence = calculate_sos_confidence(
          sos=sos,
          ice=range.ice,
          entry_type="LPS",  # 3% stop, baseline 75
      )

      # LPS should score 10 points higher (lower risk premium)
      assert lps_confidence.total_score >= direct_confidence.total_score + 10
  ```

### **Task 6: Forex SOS integration tests** (AC: 6)

- [ ] Test GBP/USD SOS detection:
  ```python
  def test_forex_sos_detection_gbpusd():
      sos = detect_sos(range, bars, volume_analysis, WyckoffPhase.D, symbol="GBP/USD")

      assert sos is not None
      assert sos.asset_class == "forex"

      confidence = calculate_sos_confidence(sos, ice, "DIRECT")
      assert confidence.total_score <= 85
      # Verify volume weight 10pts
  ```

- [ ] Test forex SOS baseline (60 direct, 70 LPS vs stock 65 direct, 75 LPS)

- [ ] Test forex SOS LPS entry bonus (Amendment 6):
  ```python
  def test_forex_sos_lps_entry_bonus():
      """
      Test LPS entry receives proper baseline adjustment for forex.

      Story 6.5 Confidence Scoring:
      - Direct SOS entry: Baseline 60 (higher risk, 5% pips)
      - LPS entry: Baseline 70 (+10 for lower risk, 3% pips)

      NOTE: Forex baselines are 5 points lower than stocks due to
      tick volume reliability.
      """
      sos = detect_sos(range, bars, volume_analysis, WyckoffPhase.D, symbol="GBP/USD")
      assert sos is not None
      assert sos.asset_class == "forex"

      # Calculate confidence for both entry types
      direct_confidence = calculate_sos_confidence(
          sos=sos,
          ice=range.ice,
          entry_type="DIRECT",  # Baseline 60
      )

      lps_confidence = calculate_sos_confidence(
          sos=sos,
          ice=range.ice,
          entry_type="LPS",  # Baseline 70
      )

      # LPS should score 10 points higher
      assert lps_confidence.total_score >= direct_confidence.total_score + 10

      # Both should cap at 85 for forex
      assert direct_confidence.total_score <= 85
      assert lps_confidence.total_score <= 85
  ```

### **Task 7: Confidence score comparison tests** (AC: 7, 10)

- [ ] Create comparison test with same pattern structure:
  ```python
  def test_stock_vs_forex_confidence_comparison():
      # Same pattern structure, different symbols
      stock_spring = detect_spring(pattern, symbol="AAPL")
      forex_spring = detect_spring(pattern, symbol="EUR/USD")

      # Stock should score higher (volume confirmation)
      stock_conf = calculate_spring_confidence(stock_spring, creek, [])
      forex_conf = calculate_spring_confidence(forex_spring, creek, [])

      assert stock_conf.total_score > forex_conf.total_score

      # Document differences
      print(f"Stock: {stock_conf.total_score}/100 (volume: HIGH)")
      print(f"Forex: {forex_conf.total_score}/85 (volume: LOW)")
  ```

- [ ] Add position sizing comparison test (Amendment 3):
  ```python
  def test_stock_vs_forex_confidence_with_position_sizing():
      """
      Compare identical spring patterns with position sizing implications.

      This test demonstrates WHY forex patterns require smaller positions
      even when the underlying pattern structure is identical.
      """
      # Same pattern structure, different symbols
      creek_level = Decimal("100.00")
      identical_pattern_bars = create_spring_bars(
          creek_level=creek_level,
          penetration_pct=Decimal("0.02"),  # 2% penetration
          volume_ratio=Decimal("0.4"),      # 0.4x volume (GOOD tier)
          recovery_bars=2,
      )

      # Detect with stock symbol
      stock_spring = detect_spring(
          stock_range, identical_pattern_bars, WyckoffPhase.C, symbol="AAPL"
      )
      stock_confidence = calculate_spring_confidence(stock_spring, stock_range.creek, [])

      # Detect with forex symbol
      forex_spring = detect_spring(
          forex_range, identical_pattern_bars, WyckoffPhase.C, symbol="EUR/USD"
      )
      forex_confidence = calculate_spring_confidence(forex_spring, forex_range.creek, [])

      # Stock should score higher (volume confirmation)
      assert stock_confidence.total_score > forex_confidence.total_score

      # Calculate confidence tiers and multipliers
      stock_tier, stock_multiplier = get_confidence_tier(
          stock_confidence.total_score, stock_spring.asset_class
      )
      forex_tier, forex_multiplier = get_confidence_tier(
          forex_confidence.total_score, forex_spring.asset_class
      )

      # Calculate position sizes for $100k account, 2% max risk
      account_size = Decimal("100000")
      max_risk_pct = Decimal("0.02")

      stock_position_risk = account_size * max_risk_pct * Decimal(str(stock_multiplier))
      forex_position_risk = account_size * max_risk_pct * Decimal(str(forex_multiplier))

      # Document differences (EducationalValue++)
      print("\n" + "="*70)
      print("RISK COMPARISON: IDENTICAL PATTERN, DIFFERENT ASSET CLASSES")
      print("="*70)
      print(f"\nðŸ“Š Pattern Structure (Identical):")
      print(f"  - Penetration: {stock_spring.penetration_pct:.2%} below Creek")
      print(f"  - Volume: {stock_spring.volume_ratio:.2f}x average")
      print(f"  - Recovery: {stock_spring.recovery_bars} bars")
      print(f"\nðŸ“ˆ Stock (AAPL) - HIGH Volume Reliability:")
      print(f"  - Confidence: {stock_confidence.total_score:.1f}/100")
      print(f"  - Quality Tier: {stock_tier}")
      print(f"  - Position Multiplier: {stock_multiplier:.2f}")
      print(f"  - Account Risk: ${stock_position_risk:,.2f} ({stock_multiplier * 2:.1f}%)")
      print(f"  - Volume Interpretation: REAL institutional shares traded")
      print(f"\nðŸ’± Forex (EUR/USD) - LOW Volume Reliability:")
      print(f"  - Confidence: {forex_confidence.total_score:.1f}/85")
      print(f"  - Quality Tier: {forex_tier}")
      print(f"  - Position Multiplier: {forex_multiplier:.2f}")
      print(f"  - Account Risk: ${forex_position_risk:,.2f} ({forex_multiplier * 2:.1f}%)")
      print(f"  - Volume Interpretation: TICK volume (activity only)")
      print(f"\nâš ï¸  Position Size Difference:")
      position_diff_pct = (stock_multiplier - forex_multiplier) * 2
      position_diff_usd = stock_position_risk - forex_position_risk
      print(f"  - {position_diff_pct:.1f}% of account (${position_diff_usd:,.2f})")
      print(f"  - Reason: Tick volume lacks institutional confirmation")
      print("="*70 + "\n")

      # Assertions for test validation
      assert stock_multiplier > forex_multiplier, (
          "Stock multiplier must be higher due to HIGH volume reliability"
      )
      assert stock_position_risk > forex_position_risk, (
          "Stock position should be larger for identical pattern"
      )
  ```

- [ ] Add minimum confidence threshold test (Amendment 5):
  ```python
  def test_minimum_confidence_threshold_enforcement():
      """
      Test that 70 minimum confidence is enforced for ALL asset classes.

      Story 0.5 AC 15: Patterns below 70 confidence should be rejected
      regardless of asset class (no special treatment for forex).
      """
      # Create marginal spring (scores ~69 confidence)
      marginal_bars = create_spring_bars(
          creek_level=Decimal("100.00"),
          penetration_pct=Decimal("0.045"),  # Deep penetration (4.5%)
          volume_ratio=Decimal("0.65"),      # High volume (near 0.7 limit)
          recovery_bars=5,                    # Slow recovery
      )

      # Test stock rejection
      stock_spring = detect_spring(
          stock_range, marginal_bars, WyckoffPhase.C, symbol="AAPL"
      )
      if stock_spring is not None:
          stock_confidence = calculate_spring_confidence(stock_spring, creek, [])
          if stock_confidence.total_score < 70:
              logger.warning(
                  "stock_below_threshold",
                  confidence=stock_confidence.total_score,
                  message="Stock spring detected but below 70 threshold"
              )

      # Test forex rejection
      forex_spring = detect_spring(
          forex_range, marginal_bars, WyckoffPhase.C, symbol="EUR/USD"
      )
      if forex_spring is not None:
          forex_confidence = calculate_spring_confidence(forex_spring, creek, [])
          if forex_confidence.total_score < 70:
              logger.warning(
                  "forex_below_threshold",
                  confidence=forex_confidence.total_score,
                  message="Forex spring detected but below 70 threshold"
              )

      # Both should fail threshold (or be rejected at detection)
      # NOTE: Current implementation may reject at detection time
      # OR may detect pattern but reject at signal generation time
  ```

- [ ] Create report showing scoring differences

### **Task 8: Performance benchmarks** (AC: 8)

- [ ] Benchmark spring detection:
  ```python
  import time

  def test_spring_detection_performance():
      bars = generate_test_bars(500)  # 500-bar sequence

      start = time.time()
      spring = detect_spring(range, bars, WyckoffPhase.C, symbol="AAPL")
      elapsed_ms = (time.time() - start) * 1000

      assert elapsed_ms < 150, f"Spring detection too slow: {elapsed_ms}ms"
  ```
- [ ] Benchmark SOS detection (similar)
- [ ] Benchmark ScorerFactory overhead:
  ```python
  def test_scorer_factory_performance():
      start = time.time()
      for symbol in ["AAPL", "EUR/USD", "GBP/USD", "US30"] * 100:
          detect_asset_class(symbol)
      elapsed_ms = (time.time() - start) / 400 * 1000

      assert elapsed_ms < 1, f"Factory too slow: {elapsed_ms}ms per call"
  ```
- [ ] Test scorer caching (verify singleton pattern working)

### **Task 9: Memory leak testing** (AC: 8)

- [ ] Test scorer caching doesn't leak:
  ```python
  import gc

  def test_scorer_cache_no_memory_leak():
      initial_count = len(gc.get_objects())

      # Create scorers repeatedly
      for _ in range(1000):
          detect_spring(range, bars, WyckoffPhase.C, symbol="AAPL")

      gc.collect()
      final_count = len(gc.get_objects())

      # Allow some growth, but not 1000x
      assert final_count < initial_count * 1.1
  ```

### **Task 10: Documentation** (AC: 7)

- [ ] Create document: `docs/architecture/multi-asset-integration-test-report.md`
- [ ] Document test results (all passing)
- [ ] Document performance benchmarks (all < targets)
- [ ] Document confidence score differences (stock vs forex)
- [ ] Document position sizing implications with examples
- [ ] Document multi-spring campaign validation results
- [ ] Include test data fixtures locations

### **Task 11: Multi-Spring Campaign Integration Tests** (AC: 9)

- [ ] Test stock 3-spring accumulation campaign (DECLINING volume):
  ```python
  def test_stock_multi_spring_accumulation_campaign():
      """
      Test 3-spring accumulation with DECLINING volume (professional pattern).

      Campaign Structure:
      - Spring 1 (Bar 25): 0.6x volume, 2.0% penetration
      - Spring 2 (Bar 40): 0.5x volume, 2.5% penetration (deeper, lower volume)
      - Spring 3 (Bar 55): 0.3x volume, 3.0% penetration (deepest, lowest volume)

      Expected:
      - Volume Trend: DECLINING (0.6 â†’ 0.5 â†’ 0.3)
      - Risk Level: LOW (professional accumulation)
      - Best Spring: Spring 3 (lowest volume per Wyckoff hierarchy)
      """
      symbol = "AAPL"
      bars = create_three_spring_campaign(
          symbol=symbol,
          volumes=[Decimal("0.6"), Decimal("0.5"), Decimal("0.3")],
          penetrations=[Decimal("0.02"), Decimal("0.025"), Decimal("0.03")],
      )

      detector = SpringDetector()
      history = detector.detect_all_springs(range, bars, WyckoffPhase.C)

      assert history.spring_count == 3, "Should detect 3 springs"
      assert history.volume_trend == "DECLINING", "Volume should decline (professional)"
      assert history.risk_level == "LOW", "Declining volume = LOW risk"

      # Best spring = lowest volume (Wyckoff hierarchy)
      assert history.best_spring.volume_ratio == Decimal("0.3")

      # All springs should be stock asset class
      for spring in history.springs:
          assert spring.asset_class == "stock"
          assert spring.volume_reliability == "HIGH"
  ```

- [ ] Test forex 3-spring accumulation campaign (DECLINING volume):
  ```python
  def test_forex_multi_spring_accumulation_campaign():
      """
      Same campaign structure, forex symbol - verify confidence capping.

      CRITICAL TEST: Each spring in campaign should cap at 85 confidence.
      """
      symbol = "EUR/USD"
      bars = create_three_spring_campaign(
          symbol=symbol,
          volumes=[Decimal("0.6"), Decimal("0.5"), Decimal("0.3")],
          penetrations=[Decimal("0.02"), Decimal("0.025"), Decimal("0.03")],
      )

      detector = SpringDetector()
      history = detector.detect_all_springs(range, bars, WyckoffPhase.C)

      # Same campaign characteristics
      assert history.spring_count == 3
      assert history.volume_trend == "DECLINING"  # Trend detection unchanged
      assert history.risk_level == "LOW"  # Risk level unchanged

      # Best spring same selection logic
      assert history.best_spring.volume_ratio == Decimal("0.3")

      # BUT: All springs cap at 85 confidence
      for spring in history.springs:
          assert spring.asset_class == "forex"
          assert spring.volume_reliability == "LOW"

          # Calculate confidence for each spring
          confidence = calculate_spring_confidence(spring, range.creek, [])
          assert confidence.total_score <= 85, (
              f"Forex spring confidence {confidence.total_score} exceeds 85 cap"
          )

      # Best spring confidence also capped
      best_confidence = calculate_spring_confidence(
          history.best_spring, range.creek, []
      )
      assert best_confidence.total_score <= 85
  ```

- [ ] Test stock vs forex campaign comparison:
  ```python
  def test_stock_vs_forex_campaign_comparison():
      """
      Compare identical 3-spring campaigns across asset classes.

      Demonstrates that campaign STRUCTURE (volume trend, risk level) is
      independent of asset class, but individual spring CONFIDENCE differs.
      """
      # Create identical campaigns
      stock_history = create_and_detect_campaign("AAPL")
      forex_history = create_and_detect_campaign("EUR/USD")

      # Campaign structure identical
      assert stock_history.volume_trend == forex_history.volume_trend
      assert stock_history.risk_level == forex_history.risk_level
      assert stock_history.spring_count == forex_history.spring_count

      # But confidence scores differ (stock higher)
      stock_best_conf = calculate_spring_confidence(
          stock_history.best_spring, creek, []
      )
      forex_best_conf = calculate_spring_confidence(
          forex_history.best_spring, creek, []
      )

      assert stock_best_conf.total_score > forex_best_conf.total_score
      assert stock_best_conf.total_score <= 100
      assert forex_best_conf.total_score <= 85
  ```

- [ ] Test distribution warning campaign (RISING volume):
  ```python
  def test_forex_rising_volume_campaign_warning():
      """
      Test 3-spring campaign with RISING volume (distribution warning).

      Campaign Structure:
      - Spring 1: 0.3x volume
      - Spring 2: 0.5x volume (RISING)
      - Spring 3: 0.65x volume (RISING - warning)

      Expected:
      - Volume Trend: RISING (0.3 â†’ 0.5 â†’ 0.65)
      - Risk Level: HIGH (distribution warning)
      - This pattern should be AVOIDED by traders
      """
      symbol = "EUR/USD"
      bars = create_three_spring_campaign(
          symbol=symbol,
          volumes=[Decimal("0.3"), Decimal("0.5"), Decimal("0.65")],
          penetrations=[Decimal("0.02"), Decimal("0.025"), Decimal("0.03")],
      )

      detector = SpringDetector()
      history = detector.detect_all_springs(range, bars, WyckoffPhase.C)

      assert history.spring_count == 3
      assert history.volume_trend == "RISING", "Volume increasing (distribution)"
      assert history.risk_level == "HIGH", "Rising volume = HIGH risk"

      # Best spring is FIRST (lowest volume in RISING trend)
      assert history.best_spring.volume_ratio == Decimal("0.3")
  ```

- [ ] Verify SpringHistory fields work across asset classes

## Deliverables

- âœ… `backend/tests/integration/pattern_engine/test_multi_asset_confidence.py` - Integration test suite
- âœ… Performance benchmark results (all passing)
- âœ… Test data fixtures for multiple asset classes
- âœ… Multi-spring campaign test fixtures (3-spring scenarios with DECLINING/RISING volume)
- âœ… Helper functions: `get_confidence_tier()`, `create_perfect_spring_bars()`, `create_three_spring_campaign()`
- âœ… `docs/architecture/multi-asset-integration-test-report.md` - Documentation
  - Test results (all passing)
  - Performance benchmarks
  - Confidence score comparison with position sizing implications
  - Multi-spring campaign validation results
  - Educational commentary on volume reliability differences

## Definition of Done

- [ ] All acceptance criteria met (AC 1-10)
- [ ] All tasks completed (Tasks 1-11)
- [ ] All integration tests passing (stock, forex, CFD, multi-spring campaigns)
- [ ] Performance benchmarks passing (<150ms, <1ms factory)
- [ ] Confidence score differences verified and documented WITH position sizing implications
- [ ] Multi-spring campaigns tested across asset classes (DECLINING and RISING volume)
- [ ] Minimum confidence threshold (70) enforced consistently across asset classes
- [ ] Perfect pattern ceiling tests passing (stock 100, forex 85)
- [ ] LPS entry bonus tests passing (if Story 6.5 complete, otherwise defer to Story 6.6)
- [ ] No memory leaks from scorer caching
- [ ] Code passes mypy --strict
- [ ] Code passes flake8
- [ ] Documentation complete (includes position sizing implications and campaign analysis)
- [ ] Code reviewed by Wyckoff team
- [ ] Merged to main branch

## Notes

**Test Data Requirements:**

1. **Stock Test Data:**
   - AAPL historical data with spring pattern
   - SPY with SOS breakout pattern
   - 500+ bar sequences for performance testing
   - Multi-spring campaign sequences (3 springs, DECLINING volume)

2. **Forex Test Data:**
   - EUR/USD with spring pattern (tick volume data)
   - GBP/USD with SOS breakout (tick volume data)
   - CFD index data (US30, NAS100, SPX500)
   - Multi-spring campaign sequences (3 springs, various volume trends)

3. **Pattern Characteristics:**
   - Valid spring: 1-5% penetration, <0.7x volume, 1-5 bar recovery
   - Perfect spring: 1.5% penetration, 0.3x volume, 1-bar recovery, 80+ Creek strength, DECLINING volume trend
   - Valid SOS: >1% breakout, >1.5x volume, wide spread
   - Multi-spring campaigns: 3 springs with varying volume trends (DECLINING, RISING, MIXED)

**Expected Performance:**

| Operation | Target | Rationale |
|-----------|--------|-----------|
| Spring detection (500 bars) | <150ms | NFR1: <1s per symbol |
| SOS detection (500 bars) | <150ms | NFR1: <1s per symbol |
| ScorerFactory overhead | <1ms | Singleton caching working |
| Memory growth | <10% | No leaks from caching |

**Confidence Score Expectations:**

| Scenario | Stock Score | Forex Score | Difference |
|----------|-------------|-------------|------------|
| Perfect spring | 100 | 85 | -15 (volume discount) |
| Good spring | 85-95 | 70-80 | -10 to -15 |
| Perfect SOS | 100+ | 85 | -15+ (volume + bonuses) |
| Good SOS | 80-90 | 70-80 | -10 |

**Position Sizing Guidelines (Risk Management Integration):**

Helper function for confidence tier mapping:

```python
def get_confidence_tier(score: float, asset_class: str) -> tuple[str, float]:
    """
    Get confidence tier and position multiplier (from risk-management guidelines).

    Returns:
        tuple: (tier_name, multiplier)
    """
    if asset_class == "stock":
        if score >= 90:
            return ("EXCELLENT", 1.00)
        elif score >= 80:
            return ("GOOD", 0.75)
        elif score >= 70:
            return ("MARGINAL", 0.50)
        else:
            return ("REJECT", 0.00)
    else:  # forex
        if score >= 80:
            return ("EXCELLENT", 0.80)
        elif score >= 75:
            return ("GOOD", 0.60)
        elif score >= 70:
            return ("MARGINAL", 0.40)
        else:
            return ("REJECT", 0.00)
```

**Wyckoff Team Review (Richard):**

> "Integration testing validates that our architecture delivers on its promise: stock scoring preserved exactly (regression), forex scoring properly adapted (volume 10pts), and factory pattern working seamlessly (auto-detection). These tests are our confidence that Epic 0 succeeded."

**Wyckoff Team Amendments (2025-11-15):**

> "The original story was solid, but we identified 6 critical enhancements that dramatically increase the educational and validation value of this test suite:
>
> 1. **Component Score Validation** - Verify 40pts volume for springs (not just total)
> 2. **Perfect Pattern Definition** - Prove the 85-point forex ceiling with textbook example
> 3. **Position Sizing Integration** - Show WHY forex requires smaller positions (trader education)
> 4. **Multi-Spring Campaigns** - Validate Story 5.6 integration across asset classes
> 5. **Minimum Threshold Enforcement** - Ensure 70-point minimum is consistent
> 6. **LPS Entry Bonuses** - Validate risk-based baseline adjustments
>
> These amendments transform this from a basic validation suite into a comprehensive educational artifact that demonstrates the entire Wyckoff multi-asset philosophy in action."

---

**Story Created:** 2025-11-14
**Last Updated:** 2025-11-15
**Amendments Integrated:** 2025-11-15 (6 amendments from Wyckoff team)
**Status:** Ready for Development
