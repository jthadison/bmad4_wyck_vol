# Story 0.4: Confidence Scorer Factory

## Status
Done
**Done**

**Priority:** ðŸ”´ CRITICAL
**Estimate:** 3 story points
**Dependencies:** Story 0.1 (Base Interfaces), Story 0.2 (Stock Scorer), Story 0.3 (Forex Scorer)

**Epic:** Epic 0 - Asset-Class Abstraction Layer
**Sprint:** Sprint 1 (Week 2)

**Agent Model Used:** claude-sonnet-4-5-20250929

## Story

**As a** developer,
**I want** a factory pattern to automatically select the correct scorer for each asset class,
**so that** detectors seamlessly work with stocks and forex.

## Context

We have two confidence scorer implementations:
- `StockConfidenceScorer`: For stocks with real institutional volume (40pts volume, max 100 confidence)
- `ForexConfidenceScorer`: For forex with tick volume only (10pts volume, max 85 confidence)

Detectors (`spring_detector.py`, `sos_detector.py`) need to automatically select the correct scorer based on the asset class of the symbol being analyzed.

**Factory Pattern Benefits:**
- Centralized asset class detection (no scattered if/else in detectors)
- Easy to add new asset classes (futures, crypto) without touching existing code
- Singleton pattern for performance (one scorer instance per asset class, cached)
- Clear separation of concerns (detection logic vs scoring logic)

## Acceptance Criteria

1. **Create ScorerFactory class** in `backend/src/pattern_engine/scoring/scorer_factory.py`

2. **Method: `get_scorer(asset_class: str) -> ConfidenceScorer`**
   - Returns `StockConfidenceScorer` instance for `asset_class == "stock"`
   - Returns `ForexConfidenceScorer` instance for `asset_class == "forex"`
   - Raises `ValueError` for unsupported asset classes (futures, crypto not yet implemented)
   - Implements singleton pattern (caches scorer instances)

3. **Method: `detect_asset_class(symbol: str) -> str`**
   - **Forex pairs (contains "/"):** Returns `"forex"`
     - Examples: `"EUR/USD"`, `"GBP/JPY"`, `"AUD/CAD"`
   - **CFD indices (predefined list):** Returns `"forex"` (uses tick volume like forex)
     - List: `["US30", "NAS100", "SPX500", "GER40", "UK100", "JPN225"]`
     - Rationale: CFD indices use tick volume (no real institutional volume)
   - **Stocks (default):** Returns `"stock"`
     - Examples: `"AAPL"`, `"SPY"`, `"MSFT"`
   - **Future support (commented out):**
     - Futures: `["ES", "NQ", "YM", "CL", "GC"]` â†’ `"futures"`
     - Crypto: Contains `"BTC"`, `"ETH"`, `"SOL"` â†’ `"crypto"`

4. **Singleton pattern implementation:**
   ```python
   _scorer_cache: dict[str, ConfidenceScorer] = {}

   def get_scorer(asset_class: str) -> ConfidenceScorer:
       if asset_class in _scorer_cache:
           return _scorer_cache[asset_class]  # Return cached instance

       # Create new instance and cache it
       scorer = _create_scorer(asset_class)
       _scorer_cache[asset_class] = scorer
       return scorer
   ```

5. **Comprehensive logging:**
   - Log asset class detection: `"Asset class detected: {symbol} â†’ {asset_class}"`
   - Log scorer creation: `"Creating {asset_class} confidence scorer"`
   - Log scorer cache hits: `"Using cached {asset_class} confidence scorer"`
   - Use structlog for structured logging

6. **Error handling:**
   - Raise `ValueError` if `asset_class` not in `["stock", "forex"]`
   - Error message: `"Unsupported asset class: {asset_class}. Supported: stock, forex"`
   - Future: When futures/crypto implemented, add to supported list

## Tasks / Subtasks

### **Task 1: Create scorer factory module** (AC: 1)

- [x] Create file: `backend/src/pattern_engine/scoring/scorer_factory.py`
- [x] Add imports:
  ```python
  from typing import Optional
  from backend.src.pattern_engine.base.confidence_scorer import ConfidenceScorer
  from backend.src.pattern_engine.scoring.stock_scorer import StockConfidenceScorer
  from backend.src.pattern_engine.scoring.forex_scorer import ForexConfidenceScorer
  import structlog
  ```
- [x] Initialize logger: `logger = structlog.get_logger()`
- [x] Initialize cache: `_scorer_cache: dict[str, ConfidenceScorer] = {}`

### **Task 2: Implement detect_asset_class method** (AC: 3)

- [x] Create method signature:
  ```python
  def detect_asset_class(symbol: str) -> str:
      """
      Detect asset class from symbol.

      Examples:
          "EUR/USD" â†’ "forex" (contains slash)
          "US30" â†’ "forex" (CFD index - uses tick volume like forex)
          "AAPL" â†’ "stock" (default)
          "ES" â†’ "futures" (future support)
          "BTC/USD" â†’ "crypto" (future support)

      Args:
          symbol: Trading symbol

      Returns:
          Asset class: "stock", "forex", "futures", "crypto"
      """
  ```
- [x] Implement forex detection (contains "/"):
  ```python
  if "/" in symbol:
      logger.debug("asset_class_detected", symbol=symbol, asset_class="forex", reason="contains_slash")
      return "forex"
  ```
- [x] Implement CFD index detection:
  ```python
  cfd_indices = ["US30", "NAS100", "SPX500", "GER40", "UK100", "JPN225"]
  if symbol in cfd_indices:
      logger.debug("asset_class_detected", symbol=symbol, asset_class="forex", reason="cfd_index")
      return "forex"  # CFDs use tick volume, treat like forex
  ```
- [x] Implement futures detection (commented out for future):
  ```python
  # Future support - uncomment when futures implemented
  # futures_symbols = ["ES", "NQ", "YM", "CL", "GC", "ZB"]
  # if symbol in futures_symbols:
  #     return "futures"
  ```
- [x] Implement crypto detection (commented out for future):
  ```python
  # Future support - uncomment when crypto implemented
  # crypto_keywords = ["BTC", "ETH", "SOL", "USDT"]
  # if any(keyword in symbol for keyword in crypto_keywords):
  #     return "crypto"
  ```
- [x] Default to stock:
  ```python
  logger.debug("asset_class_detected", symbol=symbol, asset_class="stock", reason="default")
  return "stock"
  ```

### **Task 3: Implement get_scorer method with singleton pattern** (AC: 2, 4)

- [x] Create method signature:
  ```python
  def get_scorer(asset_class: str) -> ConfidenceScorer:
      """
      Get confidence scorer for asset class (singleton pattern).

      Args:
          asset_class: "stock", "forex", "futures", "crypto"

      Returns:
          ConfidenceScorer instance for asset class

      Raises:
          ValueError: If asset class not supported
      """
  ```
- [x] Check cache first:
  ```python
  if asset_class in _scorer_cache:
      logger.debug("scorer_cache_hit", asset_class=asset_class)
      return _scorer_cache[asset_class]
  ```
- [x] Create scorer if not cached:
  ```python
  logger.info("creating_scorer", asset_class=asset_class)
  scorer = _create_scorer(asset_class)
  _scorer_cache[asset_class] = scorer
  return scorer
  ```
- [x] Implement `_create_scorer` helper:
  ```python
  def _create_scorer(asset_class: str) -> ConfidenceScorer:
      if asset_class == "stock":
          return StockConfidenceScorer()
      elif asset_class == "forex":
          return ForexConfidenceScorer()
      else:
          raise ValueError(
              f"Unsupported asset class: {asset_class}. "
              f"Supported: stock, forex"
          )
  ```

### **Task 4: Add comprehensive logging** (AC: 5)

- [x] Log asset class detection (already in Task 2)
- [x] Log scorer creation:
  ```python
  logger.info(
      "creating_confidence_scorer",
      asset_class=asset_class,
      scorer_type=scorer.__class__.__name__,
      volume_reliability=scorer.volume_reliability,
      max_confidence=scorer.max_confidence
  )
  ```
- [x] Log cache hits (already in Task 3)
- [x] Add debug logs for symbol-to-asset-class mapping

### **Task 5: Add error handling** (AC: 6)

- [x] Validate asset_class in `get_scorer`:
  ```python
  supported_asset_classes = ["stock", "forex"]
  if asset_class not in supported_asset_classes:
      logger.error(
          "unsupported_asset_class",
          asset_class=asset_class,
          supported=supported_asset_classes
      )
      raise ValueError(
          f"Unsupported asset class: {asset_class}. "
          f"Supported: {', '.join(supported_asset_classes)}"
      )
  ```
- [x] Add docstrings with error documentation

### **Task 6: Unit tests for factory** (AC: Testing)

- [x] Create test file: `backend/tests/unit/pattern_engine/scoring/test_scorer_factory.py`
- [x] **Test asset class detection:**
  ```python
  def test_detect_asset_class_forex_pairs():
      assert detect_asset_class("EUR/USD") == "forex"
      assert detect_asset_class("GBP/JPY") == "forex"

  def test_detect_asset_class_cfd_indices():
      assert detect_asset_class("US30") == "forex"
      assert detect_asset_class("NAS100") == "forex"

  def test_detect_asset_class_stocks():
      assert detect_asset_class("AAPL") == "stock"
      assert detect_asset_class("SPY") == "stock"
  ```
- [x] **Test scorer factory:**
  ```python
  def test_get_scorer_stock():
      scorer = get_scorer("stock")
      assert isinstance(scorer, StockConfidenceScorer)
      assert scorer.asset_class == "stock"
      assert scorer.max_confidence == 100

  def test_get_scorer_forex():
      scorer = get_scorer("forex")
      assert isinstance(scorer, ForexConfidenceScorer)
      assert scorer.asset_class == "forex"
      assert scorer.max_confidence == 85
  ```
- [x] **Test singleton caching:**
  ```python
  def test_scorer_singleton_pattern():
      scorer1 = get_scorer("stock")
      scorer2 = get_scorer("stock")
      assert scorer1 is scorer2  # Same instance (cached)
  ```
- [x] **Test error handling:**
  ```python
  def test_get_scorer_unsupported_asset_class():
      with pytest.raises(ValueError, match="Unsupported asset class: futures"):
          get_scorer("futures")
  ```

### **Task 7: Documentation** (AC: Documentation)

- [x] Add module docstring explaining factory pattern
- [x] Add method docstrings with examples
- [x] Update `docs/architecture/asset-class-abstraction.md` with factory details
- [x] Document asset class detection logic (symbols â†’ asset classes)

## Deliverables

- âœ… `backend/src/pattern_engine/scoring/scorer_factory.py` - Factory implementation
- âœ… `backend/tests/unit/pattern_engine/scoring/test_scorer_factory.py` - Unit tests
- âœ… Updated architecture documentation

## Definition of Done

- [x] All acceptance criteria met
- [x] All tasks completed
- [x] Unit tests passing (100% coverage for factory)
- [x] Test asset class detection (forex pairs, CFDs, stocks)
- [x] Test scorer caching (singleton behavior)
- [x] Test error handling (unsupported asset classes)
- [x] Code passes mypy --strict
- [x] Code passes flake8/ruff
- [x] Docstrings complete
- [x] Architecture documentation updated
- [ ] Code reviewed by team
- [ ] Merged to main branch

## Notes

**Asset Class Detection Logic:**

```python
# Forex pairs (contains "/")
"EUR/USD" â†’ forex
"GBP/JPY" â†’ forex
"AUD/CAD" â†’ forex

# CFD indices (specific symbols)
"US30" â†’ forex (Dow Jones CFD - tick volume only)
"NAS100" â†’ forex (NASDAQ 100 CFD - tick volume only)
"SPX500" â†’ forex (S&P 500 CFD - tick volume only)
"GER40" â†’ forex (DAX CFD)
"UK100" â†’ forex (FTSE 100 CFD)
"JPN225" â†’ forex (Nikkei 225 CFD)

# Stocks (default)
"AAPL" â†’ stock
"SPY" â†’ stock
"MSFT" â†’ stock

# Future support (commented out)
"ES" â†’ futures (E-mini S&P 500)
"NQ" â†’ futures (E-mini NASDAQ)
"BTC/USD" â†’ crypto (Bitcoin)
```

**Singleton Pattern Benefits:**
- Performance: Create scorer once, reuse for all symbols of same asset class
- Memory: One `StockConfidenceScorer` instance for all stock symbols
- Consistency: Same scoring logic applied to all symbols of same asset class

**Factory Pattern Benefits:**
- Centralized detection: `detect_asset_class()` is single source of truth
- Easy extension: Add futures/crypto by implementing interface, update factory
- Decoupling: Detectors don't know about asset classes, just use factory

**Wyckoff Team Review (Richard):**
> "The factory pattern is the right architectural choice here. It centralizes the decision-making ('Is this symbol a stock or forex?') and abstracts it away from the detectors. When we add futures and crypto later, we just update the factory - the detectors don't change. This is clean software engineering applied to trading systems."

---

## Dev Agent Record

### Debug Log References
- No blocking issues encountered
- All tests passing (22/22 factory tests, 17/17 forex scorer tests)
- Validation: mypy --strict (0 issues), ruff (0 issues after auto-fix)

### Completion Notes
- Factory pattern implemented with module-level functions (not class-based) for simplicity
- Singleton caching working correctly (verified via tests)
- Asset class detection logic covers forex pairs, CFD indices, stock default
- Future-proofed with commented crypto/futures support
- Comprehensive structured logging with structlog
- 100% test coverage: 22 tests across 5 test classes
- Architecture documentation updated with Story 0.4 implementation notes
- No regressions in existing scorer tests

### File List
**New Files:**
- `backend/src/pattern_engine/scoring/scorer_factory.py` (204 lines)
- `backend/tests/unit/pattern_engine/scoring/test_scorer_factory.py` (268 lines)

**Modified Files:**
- `docs/architecture/asset-class-abstraction.md` (updated section 4 with Story 0.4 implementation)

### Change Log
1. Created `scorer_factory.py` with `detect_asset_class()`, `get_scorer()`, `_create_scorer()`
2. Implemented singleton pattern with module-level `_scorer_cache`
3. Added comprehensive structlog logging (debug for detection/cache hits, info for creation, error for unsupported)
4. Created 22 unit tests covering detection, factory, singleton, error handling, integration
5. Fixed import paths (backend.src â†’ src for consistency with codebase)
6. Fixed test assertions (volume_reliability is string "HIGH"/"LOW", not float)
7. Applied ruff auto-fix for import ordering
8. Updated architecture docs with implementation notes

---

**Story Created:** 2025-11-14
**Last Updated:** 2025-11-15
**Status:** Ready for Review
