# Story 25.3: Fix Signal Price Field Extraction for All Pattern Types

## Status
Done

## Story
**As a** developer,
**I want** signal price field extraction to correctly map pattern-specific field names to entry_price, stop_loss, and target for all 6 pattern types,
**So that** Spring, SOS, LPS, UTAD, SC, and AR signals are not rejected due to missing price fields.

## INVEST Checklist
| Criteria | Status | Notes |
|----------|--------|-------|
| Independent | ✅ | No dependencies on other Epic 25 stories |
| Negotiable | ✅ | Field mapping approach flexible |
| Valuable | ✅ | Signals rejected at price extraction; fix is prerequisite for any real signal |
| Estimable | ✅ | Scope bounded to lines 97–138 of orchestrator_facade.py |
| Small | ✅ | 3 points, targeted rewrite of one extractor function |
| Testable | ✅ | Each pattern type has explicit AC with expected field values |

## Story Points
3

## Priority
P0 Critical

## Type
Bug Fix

## Dependencies
None

## Background

In `backend/src/orchestrator/orchestrator_facade.py` lines 97–138, the price field extractor uses a generic fallback chain that does not account for pattern-specific field names. Spring patterns store their entry price in `recovery_price`, not `entry_price`. The extractor fails to find `entry_price`, `breakout_price`, or other generic names, then rejects the signal with "Rejecting signal — pattern must provide entry/stop/target".

Additionally, the last-resort target calculation is hardcoded as `creek * 1.12`, which is an arbitrary multiplier with no Wyckoff basis. Targets must come from the pattern's own computed fields (Creek level, Ice level, Jump level) rather than formulas invented in the extractor.

All 6 pattern types need explicit, documented field mappings:
- **Spring**: `recovery_price` → entry, `spring_low * 0.995` → stop, `creek_level` → target
- **SOS**: breakout bar close → entry, `ice_level` → stop, `jump_level` → target
- **LPS**: pullback low → entry, `ice_level` → stop, `sos_high` → target
- **UTAD**: upthrust high → entry (short), `utad_high * 1.005` → stop, `ice_level` → target
- **SC**: SC low → entry, `sc_low * 0.99` → stop, `ar_high` → target
- **AR**: AR high → entry (short), `ar_high * 1.005` → stop, `sc_low` → target

## Acceptance Criteria

### AC1: Spring Price Extraction
```gherkin
Given a Spring pattern object with recovery_price=150.00, spring_low=148.00, creek_level=155.00
When the price extractor processes the Spring pattern
Then entry_price = 150.00 (recovery_price)
And stop_loss = 147.26 (spring_low * 0.995)
And target = 155.00 (creek_level)
And the signal is not rejected for missing price fields
```

### AC2: SOS Price Extraction
```gherkin
Given an SOS pattern object with breakout bar close=162.00, ice_level=158.00, jump_level=170.00
When the price extractor processes the SOS pattern
Then entry_price = 162.00 (breakout bar close)
And stop_loss = 158.00 (ice_level)
And target = 170.00 (jump_level)
And the signal is not rejected for missing price fields
```

### AC3: LPS Price Extraction
```gherkin
Given an LPS pattern object with pullback_low=159.00, ice_level=158.00, sos_high=165.00
When the price extractor processes the LPS pattern
Then entry_price = 159.00
And stop_loss = 158.00 (ice_level)
And target = 165.00 (sos_high)
And the signal is not rejected for missing price fields
```

### AC4: UTAD Price Extraction (Short)
```gherkin
Given a UTAD pattern object with utad_high=180.00, ice_level=160.00
When the price extractor processes the UTAD pattern
Then entry_price = 180.00 (short entry at upthrust high)
And stop_loss = 180.90 (utad_high * 1.005, above entry for short)
And target = 160.00 (ice_level, below entry for short)
And the signal is not rejected for missing price fields
```

### AC5: No Hardcoded Target Multipliers
```gherkin
Given any pattern type processed by the extractor
When the target price is computed
Then the target value comes from a named field on the pattern object (creek_level, jump_level, ice_level, etc.)
And no formula of the form "level * 1.12" or any other arbitrary multiplier appears in the extractor
```

### AC6: Rejection Logged with Specific Missing Field Names
```gherkin
Given a pattern that genuinely has no price fields (malformed/incomplete)
When the extractor cannot find entry, stop, or target
Then the signal is rejected with a log message that names which specific fields were searched
And the message is actionable (e.g., "Spring pattern missing recovery_price and spring_low")
```

## Tasks / Subtasks

- [ ] **Task 1**: Read all detector output schemas
  - [ ] Read `backend/src/pattern_engine/detectors/spring/detector.py` — document all fields
  - [ ] Read `backend/src/pattern_engine/detectors/sos_detector.py` — document all fields
  - [ ] Read `backend/src/pattern_engine/detectors/lps_detector.py` — document all fields
  - [ ] Read `backend/src/pattern_engine/detectors/utad_detector.py` — document all fields
  - [ ] Identify field names for SC and AR patterns

- [ ] **Task 2**: Read the current broken extractor
  - [ ] Read `backend/src/orchestrator/orchestrator_facade.py` lines 97–138
  - [ ] Document the current fallback chain
  - [ ] Identify the `creek * 1.12` hardcoded target

- [ ] **Task 3**: Write explicit per-pattern field mappings
  - [ ] Create mapping dict or match/case block: pattern_type → (entry_field, stop_field, target_field)
  - [ ] Implement Spring mapping
  - [ ] Implement SOS mapping
  - [ ] Implement LPS mapping
  - [ ] Implement UTAD mapping
  - [ ] Implement SC mapping
  - [ ] Implement AR mapping
  - [ ] Remove all hardcoded multiplier formulas

- [ ] **Task 4**: Improve rejection log message
  - [ ] Log which fields were searched and not found
  - [ ] Include pattern_type in rejection log

- [ ] **Task 5**: Write unit tests — one per pattern type
  - [ ] Spring: recovery_price → entry_price assertion
  - [ ] SOS: breakout close → entry_price assertion
  - [ ] LPS: pullback_low → entry_price assertion
  - [ ] UTAD: utad_high → entry_price assertion
  - [ ] Malformed pattern: rejection log includes field names

- [ ] **Task 6**: Run quality gates
  - [ ] `ruff check` + `ruff format`
  - [ ] `mypy src/`
  - [ ] `pytest tests/ -x --cov`

## Dev Notes

### Key Files to Modify
- `backend/src/orchestrator/orchestrator_facade.py` (lines 97–138) — replace the generic fallback extractor with an explicit per-pattern mapping

### Key Files to Reference (read-only)
- `backend/src/pattern_engine/detectors/spring/detector.py` — Spring return type and field names
- `backend/src/pattern_engine/detectors/sos_detector.py` — SOS return type and field names
- `backend/src/pattern_engine/detectors/lps_detector.py` — LPS return type and field names
- `backend/src/pattern_engine/detectors/utad_detector.py` — UTAD return type and field names

### Approach
Read all detector files first to build a complete picture of field names before touching the extractor. Replace the generic fallback chain with a dispatch on `pattern.pattern_type` (or equivalent discriminator). Each branch extracts the correct named fields. Do not introduce any arithmetic formulas for targets — targets must be read directly from pattern fields. If a field is missing, reject with a message listing exactly which fields were searched.

## Testing

### Test File Location
`backend/tests/unit/orchestrator/test_price_field_extractor.py`

### Testing Framework
pytest 8.0+ with pytest-asyncio

### Test Requirements
1. One parametrized test per pattern type asserting correct (entry, stop, target) extraction
2. Test for malformed pattern asserting rejection log contains searched field names
3. Test asserting no hardcoded multiplier is present (regex check on extractor source)
4. 90%+ coverage on the modified extractor function

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|

## Review
- Wayne (Entry Analyst) — Verify entry price logic matches Wyckoff entry rules for each pattern type
- Sam (Level Mapper) — Verify Creek, Ice, and Jump level field names match what the level mapper produces
