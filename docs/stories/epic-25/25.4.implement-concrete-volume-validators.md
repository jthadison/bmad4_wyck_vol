# Story 25.4: Implement Concrete Volume Validators for All Pattern Types

## Status
Done

## Story
**As a** developer,
**I want** concrete volume validation implementations for Spring, SOS, LPS, and UTAD patterns,
**So that** the non-negotiable volume rules (Springs < 0.7x, SOS > 1.5x) are actually enforced in the signal validation chain.

## INVEST Checklist
| Criteria | Status | Notes |
|----------|--------|-------|
| Independent | ✅ | Abstract base exists; no cross-story dependencies |
| Negotiable | ✅ | Implementation approach (class vs. function) flexible |
| Valuable | ✅ | Volume validation is non-negotiable per CLAUDE.md — currently bypassed entirely |
| Estimable | ✅ | 4 concrete classes with clear threshold specs |
| Small | ⚠️ | 5 points — 4 validators + wiring; slightly larger but still focused |
| Testable | ✅ | Each threshold has explicit pass/fail ACs with numeric values |

## Story Points
5

## Priority
P0 Critical

## Type
Feature

## Dependencies
None

## Background

`backend/src/signal_generator/validators/volume/base.py` defines `VolumeValidationStrategy` as an abstract base class. No concrete implementations exist anywhere in the codebase. The validation chain includes a `VolumeValidator()` call, but with no concrete strategies wired, volume checks are effectively bypassed and every signal passes volume validation regardless of actual volume.

CLAUDE.md states clearly that volume validation is "Non-Negotiable":
- Springs MUST have low volume (< 0.7x average) — violations reject signal
- SOS breakouts MUST have high volume (> 1.5x average) — violations reject signal
- "Volume precedes price" is the foundational principle

This story implements four concrete validators and wires them into the orchestrator pipeline:

1. **SpringVolumeValidator** — rejects if `volume_ratio >= 0.7`
2. **SOSVolumeValidator** — rejects if `volume_ratio <= 1.5`
3. **LPSVolumeValidator** — moderate volume on pullback (configurable range)
4. **UTADVolumeValidator** — high volume on upthrust, low volume on failure bar

Thresholds must be sourced from `backend/src/pattern_engine/timeframe_config.py` constants (`SPRING_VOLUME_THRESHOLD`, `SOS_VOLUME_THRESHOLD`), not hardcoded literals.

## Acceptance Criteria

### AC1: SpringVolumeValidator Rejects High Volume
```gherkin
Given a Spring pattern with volume_ratio = 0.8 (above the 0.7 threshold)
When SpringVolumeValidator.validate() is called
Then ValidationResult.FAIL is returned
And the failure reason states the volume_ratio and the threshold that was violated
```

### AC2: SpringVolumeValidator Passes Low Volume
```gherkin
Given a Spring pattern with volume_ratio = 0.5 (below the 0.7 threshold)
When SpringVolumeValidator.validate() is called
Then ValidationResult.PASS is returned
```

### AC3: SOSVolumeValidator Rejects Low Volume
```gherkin
Given an SOS pattern with volume_ratio = 1.2 (below the 1.5 threshold)
When SOSVolumeValidator.validate() is called
Then ValidationResult.FAIL is returned
And the failure reason states the volume_ratio and the threshold that was violated
```

### AC4: SOSVolumeValidator Passes High Volume
```gherkin
Given an SOS pattern with volume_ratio = 1.8 (above the 1.5 threshold)
When SOSVolumeValidator.validate() is called
Then ValidationResult.PASS is returned
```

### AC5: Thresholds Sourced from timeframe_config
```gherkin
Given any volume validator class
When the validator reads its threshold value
Then the threshold is imported from SPRING_VOLUME_THRESHOLD or SOS_VOLUME_THRESHOLD in timeframe_config.py
And no numeric threshold literal (0.7, 1.5, etc.) appears hardcoded in the validator source
```

### AC6: LPS and UTAD Validators Implemented
```gherkin
Given an LPS pattern or a UTAD pattern
When the corresponding concrete validator's validate() method is called
Then the method executes volume checks (not a no-op or NotImplementedError)
And returns ValidationResult.PASS or ValidationResult.FAIL based on the pattern's volume_ratio
```

### AC7: Validators Wired into Pipeline
```gherkin
Given the validation chain in orchestrator_facade.py
When it processes a Spring signal with volume_ratio = 0.8
Then SpringVolumeValidator is selected based on pattern_type
And the signal is rejected before reaching the risk stage
And a "volume validation failed" log entry is written
```

## Tasks / Subtasks

- [ ] **Task 1**: Read existing abstract base and validation chain
  - [ ] Read `backend/src/signal_generator/validators/volume/base.py`
  - [ ] Read `backend/src/pattern_engine/timeframe_config.py` — confirm constant names
  - [ ] Read validation chain in `backend/src/orchestrator/orchestrator_facade.py` — find VolumeValidator call site

- [ ] **Task 2**: Implement SpringVolumeValidator
  - [ ] Create `backend/src/signal_generator/validators/volume/spring_validator.py`
  - [ ] Implement `validate(pattern) -> ValidationResult`
  - [ ] Use `SPRING_VOLUME_THRESHOLD` from timeframe_config
  - [ ] Return FAIL with descriptive reason if `volume_ratio >= threshold`

- [ ] **Task 3**: Implement SOSVolumeValidator
  - [ ] Create `backend/src/signal_generator/validators/volume/sos_validator.py`
  - [ ] Implement `validate(pattern) -> ValidationResult`
  - [ ] Use `SOS_VOLUME_THRESHOLD` from timeframe_config
  - [ ] Return FAIL with descriptive reason if `volume_ratio <= threshold`

- [ ] **Task 4**: Implement LPSVolumeValidator
  - [ ] Create `backend/src/signal_generator/validators/volume/lps_validator.py`
  - [ ] Implement moderate-volume check for pullback confirmation
  - [ ] Document the threshold rationale in docstring

- [ ] **Task 5**: Implement UTADVolumeValidator
  - [ ] Create `backend/src/signal_generator/validators/volume/utad_validator.py`
  - [ ] Check high volume on upthrust bar, low volume on failure bar
  - [ ] Use fields from UTAD pattern (read utad_detector.py first)

- [ ] **Task 6**: Wire validators into pipeline via factory/dispatch
  - [ ] Create `backend/src/signal_generator/validators/volume/factory.py` with `get_validator(pattern_type) -> VolumeValidationStrategy`
  - [ ] Wire the factory call into the validation chain in orchestrator_facade.py

- [ ] **Task 7**: Write unit tests
  - [ ] Spring: volume_ratio=0.8 → FAIL; volume_ratio=0.5 → PASS
  - [ ] SOS: volume_ratio=1.2 → FAIL; volume_ratio=1.8 → PASS
  - [ ] LPS: volume tests per implemented threshold
  - [ ] UTAD: volume tests per implemented threshold
  - [ ] Integration: Spring signal with volume_ratio=0.8 rejected before risk stage

- [ ] **Task 8**: Run quality gates
  - [ ] `ruff check` + `ruff format`
  - [ ] `mypy src/`
  - [ ] `pytest tests/ -x --cov`

## Dev Notes

### Key Files to Modify
- `backend/src/signal_generator/validators/volume/` — create spring_validator.py, sos_validator.py, lps_validator.py, utad_validator.py, factory.py
- `backend/src/orchestrator/orchestrator_facade.py` — wire factory call into validation chain

### Key Files to Reference (read-only)
- `backend/src/signal_generator/validators/volume/base.py` — abstract interface to implement
- `backend/src/pattern_engine/timeframe_config.py` — SPRING_VOLUME_THRESHOLD and SOS_VOLUME_THRESHOLD constants
- `backend/src/pattern_engine/detectors/sos_detector.py` — volume_ratio field on SOS pattern

### Approach
Read the abstract base first to understand the interface contract. Read timeframe_config.py to confirm constant names. Implement each validator as a minimal concrete class inheriting from the abstract base. Wire them through a factory keyed on pattern_type. Keep each validator file short (under 50 lines). Do not add logic beyond the volume check — no phase validation, no price validation.

## Testing

### Test File Location
`backend/tests/unit/signal_generator/validators/volume/`

### Testing Framework
pytest 8.0+ with pytest-asyncio

### Test Requirements
1. Parametrized test: Spring validator with volume_ratio values [0.3, 0.5, 0.69, 0.7, 0.71, 0.9] → expected PASS/FAIL
2. Parametrized test: SOS validator with volume_ratio values [1.0, 1.2, 1.49, 1.5, 1.51, 2.0] → expected PASS/FAIL
3. Unit test: threshold values read from timeframe_config (monkeypatch constant, verify validator picks it up)
4. Integration test: Spring signal with volume_ratio=0.8 rejected at volume stage (does not reach risk stage)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|

## Review
- Victoria (Volume Analyst) — Verify thresholds and failure logic against classical Wyckoff volume rules
- William (Wyckoff Mentor) — Validate that volume strategy alignment matches institutional Wyckoff methodology
