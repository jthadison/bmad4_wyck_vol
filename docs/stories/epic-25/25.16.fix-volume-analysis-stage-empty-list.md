# Story 25.16: Fix VolumeAnalysisStage Empty List

## Status
Done

## Story
**As a** developer,
**I want** `VolumeAnalysisStage.run()` to return actual volume analysis data for the bars it receives,
**So that** the concrete volume validators implemented in 25.4 receive real volume data to check rather than an empty list that causes all signals to pass volume validation silently.

## INVEST Checklist
| Criteria | Status | Notes |
|----------|--------|-------|
| Independent | ✅ | Contained within volume_analysis_stage.py and its analyzer dependency |
| Negotiable | ✅ | Internal implementation approach flexible within the existing analyzer interface |
| Valuable | ✅ | Without this fix, 25.4's validators are wired but never receive data — volume rules remain unenforced on real signals |
| Estimable | ✅ | Scope bounded to one stage file and its direct analyzer dependency |
| Small | ✅ | 3 points — read, diagnose, fix, test |
| Testable | ✅ | Non-empty return value with known bar input is directly assertable |

## Story Points
3

## Priority
P0 Critical

## Type
Bug Fix

## Dependencies
None

## Background

`backend/src/orchestrator/stages/volume_analysis_stage.py:93` calls `volume_analyzer.analyze()` which returns an empty list by default. Downstream validators receive no volume data, log a WARN (not FAIL), and allow signals through without any volume check. This means:

- A Spring signal with volume_ratio=0.8 (should be rejected by SpringVolumeValidator) passes silently because the stage produces no data for the validator to inspect
- The non-negotiable volume rules in CLAUDE.md are effectively bypassed even after 25.4 implements the concrete validators

This issue is distinct from 25.4 (which addresses the absence of concrete validator implementations). This story addresses the upstream problem: the stage itself is not producing the volume data that validators consume.

The root cause is likely one of:
1. `volume_analyzer.analyze()` is a stub returning `[]` (similar pattern to the phase validator stub)
2. The `analyze()` method exists but the stage passes incorrect or empty bar data to it
3. The stage discards the return value before passing it downstream (same pattern as B1 in the QA assessment)

The exact cause must be determined by reading the files before any fix is applied.

## Acceptance Criteria

### AC1: Stage Returns Non-Empty Volume Data for Valid Bars
```gherkin
Given a sequence of 30 OHLCV bars with varying volume values
When VolumeAnalysisStage.run() is called with those bars
Then a non-empty list of volume analysis results is returned
And each result contains at least volume_ratio for its corresponding bar
```

### AC2: Volume Data Available to Validators
```gherkin
Given VolumeAnalysisStage produces volume data for a set of bars
When the next pipeline stage (volume validator) runs
Then it receives the volume data from the stage output
And does not log a WARN due to missing volume data
```

### AC3: Spring Signal with High Volume Rejected
```gherkin
Given a Spring pattern bar with volume_ratio = 0.8 (above the 0.7 threshold)
And VolumeAnalysisStage now produces correct volume data
When the full pipeline validation chain runs
Then the SpringVolumeValidator (from 25.4) receives the volume_ratio
And the signal is rejected at the volume stage
And a "volume validation failed" log entry is written
```

### AC4: Empty Bars Handled Gracefully
```gherkin
Given an empty list of bars passed to VolumeAnalysisStage
When run() is called
Then an empty list is returned
And no exception is raised
```

### AC5: Volume Data Structure Compatible with Validators
```gherkin
Given the volume data returned by VolumeAnalysisStage
When SpringVolumeValidator or SOSVolumeValidator reads it
Then the validator can access volume_ratio without AttributeError or KeyError
And the data structure matches what the validators expect
```

## Tasks / Subtasks

- [ ] **Task 1**: Read all relevant files before touching any code
  - [ ] Read `backend/src/orchestrator/stages/volume_analysis_stage.py` in full — identify line 93 and the analyze() call
  - [ ] Read the return value of `volume_analyzer.analyze()` — determine if it is a stub, if it returns empty, or if the return is discarded
  - [ ] Read the `VolumeAnalyzer` class (or equivalent) that `analyze()` belongs to — confirm whether it is an abstract base or has a concrete implementation
  - [ ] Read downstream pipeline stage to understand what data structure it expects from volume analysis

- [ ] **Task 2**: Diagnose the exact failure mode
  - [ ] Confirm which of the three likely causes applies (stub, empty input, discarded return)
  - [ ] Document the diagnosis in a code comment before making any change

- [ ] **Task 3**: Fix the stage
  - [ ] If `analyze()` is a stub: implement it to compute volume_ratio for each bar using a trailing average (align with the 20-bar lookback from timeframe_config.py)
  - [ ] If the return value is discarded: add the correct append/assignment to pass results downstream
  - [ ] If empty bar input: trace where bars are passed into the stage and fix the input

- [ ] **Task 4**: Confirm data structure compatibility
  - [ ] Read the concrete volume validators from 25.4 (if already merged) or their planned interface from the 25.4 story
  - [ ] Confirm the volume data returned by the stage matches the field names the validators expect
  - [ ] If field names mismatch, fix in the stage (not in the validators)

- [ ] **Task 5**: Write unit tests
  - [ ] Test: 30 bars with varying volumes → non-empty list returned from stage
  - [ ] Test: volume_ratio present and correct in each result (use bars with known volume values)
  - [ ] Test: empty bar input → empty list returned, no exception
  - [ ] Integration test: full pipeline with Spring bars (volume_ratio=0.8) → signal rejected at volume stage (not at risk stage)

- [ ] **Task 6**: Run quality gates
  - [ ] `ruff check` + `ruff format`
  - [ ] `mypy src/`
  - [ ] `pytest tests/ -x --cov`

## Dev Notes

### Key Files to Modify
- `backend/src/orchestrator/stages/volume_analysis_stage.py` — fix the analyze() call and/or result handling (primary file)
- Possibly the `VolumeAnalyzer` class if it is a stub — complete its `analyze()` method

### Key Files to Reference (read-only)
- `backend/src/pattern_engine/timeframe_config.py` — 20-bar lookback window constant
- `backend/src/signal_generator/validators/volume/base.py` — validator interface to confirm expected input structure
- `backend/src/signal_generator/validators/volume/` (25.4 files if merged) — confirm field names used by concrete validators

### Approach
Read the stage file and the analyzer class before writing a single line. The fix is likely one of: (a) a missing append/extend after the analyze() call (same pattern as B1), or (b) the analyzer class needs a concrete implementation. Do not implement complex volume analysis logic — compute trailing average volume_ratio using the same 20-bar lookback already defined in timeframe_config.py. Keep the fix minimal and contained to the stage and its direct dependency.

## Testing

### Test File Location
`backend/tests/unit/orchestrator/stages/test_volume_analysis_stage.py`

### Testing Framework
pytest 8.0+ with pytest-asyncio

### Test Requirements
1. Unit test: 30 bars → non-empty list returned
2. Unit test: volume_ratio values match manual calculation for known bar volumes
3. Unit test: empty input → empty list, no crash
4. Integration test: Spring bars with volume_ratio=0.8 rejected at volume stage (not at risk stage or later)
5. 90%+ coverage on the modified stage file

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|

## Review
- Victoria (Volume Analyst) — Verify the volume_ratio calculation method in the stage matches the methodology used by pattern detectors
- Philip (Phase Identifier) — Verify stage output is correctly threaded into the pipeline context for downstream validators
