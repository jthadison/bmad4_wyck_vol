# Story 25.8: Implement Phase Validator

## Status
Done

## Story
**As a** developer,
**I want** a fully implemented phase validator that enforces Wyckoff phase-pattern alignment rules,
**So that** signals generated by detectors in the wrong Wyckoff phase are rejected before reaching risk validation.

## INVEST Checklist
| Criteria | Status | Notes |
|----------|--------|-------|
| Independent | ✅ | Depends on 25.1 and 25.2 for pipeline signals to test against, but implementation is self-contained |
| Negotiable | ✅ | Mapping approach and confidence threshold for late-Phase C SOS are flexible |
| Valuable | ✅ | Prevents catastrophic wrong-phase signals (Spring in Phase A) from reaching execution |
| Estimable | ✅ | Clear scope — one file, pattern-to-phase mapping + duration check |
| Small | ✅ | 5 points, single file implementation |
| Testable | ✅ | Each AC maps directly to a unit test with synthetic PhaseResult and signal objects |

## Story Points
5

## Priority
P1 Critical

## Type
Feature

## Dependencies
- Story 25.1 (pipeline must produce signals to test phase validation end-to-end)
- Story 25.2 (portfolio context wiring must be complete for full pipeline integration tests)

## Background

`backend/src/signal_generator/validators/phase_validator.py` currently contains only abstract method stubs. No phase-pattern alignment validation is enforced anywhere in the pipeline. This means the signal generator can emit a Spring signal during Phase A (catastrophically wrong — no accumulation has occurred yet), an SOS signal during Phase B (premature — Creek has not been established), or an LPS signal during Phase C (wrong — LPS requires a confirmed Phase D breakout to retest).

Per Wyckoff methodology (FR14 and the BMAD trading rules codified in CLAUDE.md): Springs are only valid in Phase C; SOS breakouts are only valid in Phase D (or late Phase C with confidence >= 85 and explicit warning); LPS retests are only valid in Phase D or E; UTAD upthrusts are only valid in Phase D; Selling Climax and Automatic Rally are Phase A patterns only. The Phase B minimum duration rule (10 bars) is a hard filter — Phase C patterns in a range with a Phase B of fewer than 10 bars indicate insufficient accumulation time and must be rejected.

The implementation must also fail safely when no phase data is available. A missing or unknown phase must result in a FAIL decision, not a pass-through. Silent pass-throughs on unknown phase data would allow unvalidated signals into execution.

## Acceptance Criteria

### AC1: Spring Rejected Outside Phase C
```gherkin
Given a Spring signal with current_phase = PHASE_B in the PhaseResult
When PhaseValidator.validate() is called with the signal
Then FAIL is returned
And the failure reason contains "Spring requires Phase C"
```

### AC2: Spring Accepted in Phase C
```gherkin
Given a Spring signal with current_phase = PHASE_C in the PhaseResult
And Phase B duration >= 10 bars
When PhaseValidator.validate() is called
Then PASS is returned
```

### AC3: SOS Accepted in Phase D
```gherkin
Given an SOS signal with current_phase = PHASE_D in the PhaseResult
When PhaseValidator.validate() is called
Then PASS is returned
```

### AC4: SOS Conditionally Accepted in Late Phase C
```gherkin
Given an SOS signal with current_phase = PHASE_C
And confidence >= 85 in the PhaseResult
When PhaseValidator.validate() is called
Then PASS is returned
And the result includes a warning "SOS in Phase C: elevated confidence override"
```

### AC5: LPS Rejected in Phase B
```gherkin
Given an LPS signal with current_phase = PHASE_B in the PhaseResult
When PhaseValidator.validate() is called
Then FAIL is returned
And the failure reason contains "LPS requires Phase D or E"
```

### AC6: UTAD Accepted Only in Phase D or E
```gherkin
Given a UTAD signal with current_phase = PHASE_C in the PhaseResult
When PhaseValidator.validate() is called
Then FAIL is returned
Given a UTAD signal with current_phase = PHASE_D in the PhaseResult
When PhaseValidator.validate() is called
Then PASS is returned
Given a UTAD signal with current_phase = PHASE_E in the PhaseResult
When PhaseValidator.validate() is called
Then PASS is returned
```

### AC7: Phase Duration Enforced for Phase C Patterns
```gherkin
Given a Spring signal with current_phase = PHASE_C
And Phase B duration = 7 bars (below the 10-bar minimum)
When PhaseValidator.validate() is called
Then FAIL is returned
And the failure reason contains "Phase B too short (7 bars, minimum 10)"
```

### AC8: Unknown Phase Fails Safely
```gherkin
Given a signal with no phase data available (PhaseResult is None or phase = UNKNOWN)
When PhaseValidator.validate() is called
Then FAIL is returned
And the failure reason contains "Phase data unavailable"
And no exception is raised
```

## Tasks / Subtasks

- [ ] **Task 1**: Read existing stub and base class
  - [ ] Read `backend/src/signal_generator/validators/phase_validator.py` in full
  - [ ] Read `backend/src/signal_generator/validators/base.py` for base class interface
  - [ ] Identify the return type of validate() (ValidationResult or similar)

- [ ] **Task 2**: Read phase types and PhaseResult structure
  - [ ] Read `backend/src/pattern_engine/phase_detection/types.py`
  - [ ] Identify PhaseResult fields: current_phase, phase_durations, confidence, etc.
  - [ ] Confirm Phase enum values: PHASE_A, PHASE_B, PHASE_C, PHASE_D, PHASE_E, UNKNOWN

- [ ] **Task 3**: Read orchestrator to understand how phase context is passed to validators
  - [ ] Read `backend/src/orchestrator/orchestrator_facade.py` sections that pass PhaseResult to the signal generator
  - [ ] Confirm where phase_result is attached to the signal context

- [ ] **Task 4**: Implement the phase-pattern mapping
  - [ ] Define ALLOWED_PHASES dict: PatternType → frozenset of allowed WyckoffPhase values
  - [ ] Map SPRING → {PHASE_C}
  - [ ] Map SOS → {PHASE_D} with conditional PHASE_C at confidence >= 85
  - [ ] Map LPS → {PHASE_D, PHASE_E}
  - [ ] Map UTAD → {PHASE_D, PHASE_E}
  - [ ] Map SC → {PHASE_A}
  - [ ] Map AR → {PHASE_A}

- [ ] **Task 5**: Implement validate() method
  - [ ] Guard: if phase_result is None or phase == UNKNOWN, return FAIL with "Phase data unavailable"
  - [ ] Look up allowed phases for signal.pattern_type
  - [ ] Check current_phase against allowed set
  - [ ] If SOS and PHASE_C: check confidence >= 85, return PASS with warning if met, else FAIL
  - [ ] Check Phase B duration >= 10 bars for any Phase C pattern (Spring)
  - [ ] Return PASS or FAIL with descriptive reason string

- [ ] **Task 6**: Write unit tests
  - [ ] AC1: Spring in Phase B → FAIL
  - [ ] AC2: Spring in Phase C, Phase B >= 10 bars → PASS
  - [ ] AC3: SOS in Phase D → PASS
  - [ ] AC4: SOS in Phase C with confidence >= 85 → PASS with warning
  - [ ] AC4b: SOS in Phase C with confidence = 70 → FAIL
  - [ ] AC5: LPS in Phase B → FAIL
  - [ ] AC6: UTAD in Phase C → FAIL, UTAD in Phase D → PASS
  - [ ] AC7: Spring in Phase C but Phase B = 7 bars → FAIL with duration reason
  - [ ] AC8: No phase data → FAIL, no crash

- [ ] **Task 7**: Run quality gates
  - [ ] `ruff check` + `ruff format`
  - [ ] `mypy src/`
  - [ ] `pytest tests/ -x --cov`

## Dev Notes

### Key Files to Modify
- `backend/src/signal_generator/validators/phase_validator.py` — replace stub with full implementation

### Key Files to Reference (read-only)
- `backend/src/pattern_engine/phase_detection/types.py` — WyckoffPhase enum and PhaseResult dataclass
- `backend/src/orchestrator/orchestrator_facade.py` — how phase context is threaded into signal generation
- `backend/src/signal_generator/validators/base.py` — base validator interface and ValidationResult type

### Approach
Implement as a lookup-table pattern: define a dict mapping PatternType to a frozenset of allowed WyckoffPhase values. The validate() method checks the signal's pattern_type against this map, then checks the current phase in the PhaseResult. The Phase B duration check is a secondary guard applied only when the primary phase check passes for Phase C patterns. The SOS late-Phase C override is a special case handled inline with a confidence threshold check. Keep all logic in a single method — do not abstract into sub-validators. Fail safely on any missing data.

## Testing

### Test File Location
`backend/tests/unit/signal_generator/validators/test_phase_validator.py`

### Testing Framework
pytest 8.0+ with pytest-asyncio

### Test Requirements
1. Unit test for each AC (minimum 10 test cases)
2. Test covers all 6 pattern types against at least 2 phases each
3. Test covers Phase B duration edge cases (9 bars = fail, 10 bars = pass, 11 bars = pass)
4. Test covers confidence threshold boundary for SOS late-Phase C (84 = fail, 85 = pass)
5. 90%+ coverage on `phase_validator.py`

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|

## Review
- Philip (Phase Identifier) — Verify phase transition rules match Wyckoff methodology exactly
- William (Wyckoff Mentor) — Validate that the phase-pattern alignment rules reflect classical Wyckoff and the BMAD trading philosophy
