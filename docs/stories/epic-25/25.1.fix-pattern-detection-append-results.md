# Story 25.1: Fix Pattern Detection — Append Results to Pipeline

## Status
Done

## Story
**As a** developer,
**I want** pattern detectors to append their results to the pipeline output list,
**So that** the orchestrator pipeline returns detected patterns instead of always returning an empty list.

## INVEST Checklist
| Criteria | Status | Notes |
|----------|--------|-------|
| Independent | ✅ | No dependencies on other Epic 25 stories |
| Negotiable | ✅ | Append location flexible within stage |
| Valuable | ✅ | Unblocks entire signal pipeline — zero signals without this fix |
| Estimable | ✅ | Clear scope — missing append calls after each detector |
| Small | ✅ | 2 points, single-file fix |
| Testable | ✅ | Integration test with Spring-pattern bars validates fix |

## Story Points
2

## Priority
P0 Critical

## Type
Bug Fix

## Dependencies
None

## Background

The `PatternDetectionStage` in `backend/src/orchestrator/stages/pattern_detection_stage.py` calls Spring, SOS, UTAD, and LPS detectors conditionally based on the current Wyckoff phase. However, detected patterns are never appended to the `patterns: list[Pattern] = []` variable. The list is initialized and returned empty regardless of what the detectors find.

This is a single-line (or few-line) bug: append calls are missing after each successful detector call. Every downstream stage (volume validation, risk sizing, signal emission) receives zero patterns to act on, so the entire pipeline silently produces no signals.

## Acceptance Criteria

### AC1: Spring Pattern Appended
```gherkin
Given bars that represent a valid Phase C accumulation with a Spring pattern
When PatternDetectionStage.run() is called
Then Spring pattern objects returned by the Spring detector are appended to the output list
And the list returned to the next pipeline stage contains at least one Pattern
```

### AC2: SOS Pattern Appended
```gherkin
Given bars that represent a valid Phase D progression with an SOS breakout
When PatternDetectionStage.run() is called
Then SOS pattern objects returned by the SOS detector are appended to the output list
And the list returned to the next pipeline stage contains at least one Pattern
```

### AC3: Empty List Returned When No Patterns Detected
```gherkin
Given bars that contain no valid Wyckoff pattern (e.g., random noise)
When PatternDetectionStage.run() is called
Then an empty list is returned
And no exception is raised
```

### AC4: Integration Test Passes End-to-End
```gherkin
Given a full pipeline run using bars that contain a recognizable Spring pattern
When analyze_symbol() is called on the orchestrator facade
Then at least one signal is returned in the response
And the signal includes pattern_type = "SPRING"
```

## Tasks / Subtasks

- [ ] **Task 1**: Read and understand the broken stage
  - [ ] Read `backend/src/orchestrator/stages/pattern_detection_stage.py` in full
  - [ ] Identify every detector call site and confirm the missing append
  - [ ] Map which phase gates each detector call

- [ ] **Task 2**: Add append calls after each detector
  - [ ] Add `patterns.append(result)` or `patterns.extend(results)` after Spring detector call
  - [ ] Add append after SOS detector call
  - [ ] Add append after UTAD detector call
  - [ ] Add append after LPS detector call
  - [ ] Confirm None-guard before appending (detectors may return None when no pattern found)

- [ ] **Task 3**: Write unit tests
  - [ ] Test Spring append — Phase C bars → non-empty list returned
  - [ ] Test SOS append — Phase D bars → non-empty list returned
  - [ ] Test empty list — noise bars → empty list, no crash
  - [ ] Test integration — full analyze_symbol() call returns signal

- [ ] **Task 4**: Run quality gates
  - [ ] `ruff check` + `ruff format`
  - [ ] `mypy src/`
  - [ ] `pytest tests/ -x --cov`

## Dev Notes

### Key Files to Modify
- `backend/src/orchestrator/stages/pattern_detection_stage.py` — add missing append calls after each detector invocation

### Key Files to Reference (read-only)
- `backend/src/orchestrator/orchestrator_facade.py` — shows how the stage fits into the pipeline
- `backend/src/pattern_engine/detectors/spring/detector.py` — return type of Spring detector
- `backend/src/pattern_engine/detectors/sos_detector.py` — return type of SOS detector

### Approach
Read the file first. Locate every call to a pattern detector. Each call currently discards the return value or stores it in a local variable that is never appended to `patterns`. Add `patterns.append(result)` (with a None-guard) after each call. Do not refactor the phase-gating logic — preserve it exactly as-is to avoid regressions.

## Testing

### Test File Location
`backend/tests/unit/orchestrator/stages/test_pattern_detection_stage.py`

### Testing Framework
pytest 8.0+ with pytest-asyncio

### Test Requirements
1. Unit test: Phase C bars produce non-empty list from PatternDetectionStage
2. Unit test: Phase D bars produce non-empty list from PatternDetectionStage
3. Unit test: Noise bars produce empty list with no exception
4. Integration test: Full analyze_symbol() call returns at least one signal given Spring-pattern bars

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|

## Review
- Victoria (Volume Specialist) — Verify pattern objects have volume_ratio populated before they leave the stage
- Philip (Phase Identifier) — Verify phase gating logic is preserved exactly and Spring is only appended in Phase C
