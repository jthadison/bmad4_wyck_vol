# Story 7.2-FX: Forex Position Sizing

## Status
Done
**Ready for Development**

**Priority:** ðŸ”´ CRITICAL
**Estimate:** 11 story points (+3 SP for Wyckoff integration)
**Dependencies:** Epic 0 (Asset-Class Abstraction), Story 7.1 (Volume-Adjusted Risk)

**Epic:** Epic 7-FX - Forex Risk Management & Position Sizing
**Sprint:** Sprint 2 (Week 5-6)

## Story

**As a** forex trader,
**I want** position sizes calculated using lot/pip mechanics with margin validation,
**so that** I can safely size positions based on pip-based stop losses without exceeding margin.

## Context

Forex markets use fundamentally different position sizing mechanics than stocks, requiring integration with Wyckoff methodology for professional-grade risk management.

### Stock Position Sizing (Epic 7 Original)

- Position size = (account Ã— risk%) / (entry - stop)
- Risk measured in dollars per share
- No leverage or margin requirements
- Direct correlation between price and dollar risk

### Forex Position Sizing Requirements

- Position size = (account Ã— risk%) / (stop_pips Ã— pip_value Ã— lot_size)
- Risk measured in pips (price increments)
- Leverage and margin requirements critical
- Pip values vary by currency pair and account currency
- Lot sizes: Standard (100k), Mini (10k), Micro (1k)

### Wyckoff Integration (NEW - Story 7.1 Alignment)

This story integrates Story 7.1's Wyckoff risk framework with forex-specific mechanics:

**Pattern-Specific Base Risk:**
- Spring (SPRING): 0.5% base risk (tight stops, high R:R)
- Sign of Strength (SOS): 0.8% base risk (wider stops, breakout risk)
- Last Point of Support (LPS): 0.7% base risk (confirmation entry)

**Volume-Adjusted Risk (Law #3: Effort vs Result):**
- Tick volume ratio determines multiplier: 0.70x - 1.00x
- Climactic volume (â‰¥2.5x) = full allocation (1.00x)
- Weak volume (<1.5x) = reduced allocation (0.70x)

**Session-Based Risk (Institutional Participation):**
- London/NY overlap (12:00-16:00 UTC): 1.00x multiplier (highest volume)
- Single major session: 0.90x multiplier
- Asian session: 0.75x multiplier (retail-dominated, ranging markets)

**Pattern-Specific Pip Stops (Structural Stops):**
- Spring: 20-70 pips (tight stops below shake-out low)
- SOS: 50-150 pips (wider stops below range support)
- LPS: 25-80 pips (medium stops below pullback low)

**Spread-Adjusted Stops:**
- Structural stop + (broker spread / 2) = buffer zone
- Prevents premature stop-outs due to bid/ask spread

### Example: Before vs After

**BEFORE (Generic Forex):**
```
Account: $10,000, Risk: 1% = $100
EUR/USD Spring: entry 1.0850, stop 1.0820 (30 pips)
Position: 3.33 mini lots
Margin: $723

âŒ 1% risk is arbitrary (should be 0.5% for Spring)
âŒ No volume consideration
âŒ No session consideration
âŒ No spread adjustment
```

**AFTER (Wyckoff-Integrated):**
```
Account: $10,000
Pattern: Spring â†’ base risk 0.5%
Tick volume: 2500 (avg 1000) â†’ 2.5x ratio â†’ 1.00x volume_mult
Session: London/NY overlap (14:00 UTC) â†’ 1.00x session_mult
Effective risk: 0.5% Ã— 1.00 Ã— 1.00 = 0.5% = $50

EUR/USD Spring: entry 1.0850
Structural stop: 1.0820 (30 pips)
Spread adjustment: +0.75 pips â†’ Final: 1.08193 (30.75 pips)
Position: 1.63 mini lots
Margin: $353 (3.5% of account)

âœ… Pattern-appropriate risk (0.5% for Spring)
âœ… Volume-adjusted (climactic = full allocation)
âœ… Session-aware (London/NY overlap = 1.00x)
âœ… Spread-protected (structural stop + buffer)
```

This story adapts the position sizing logic from Story 7.1 to handle forex-specific calculations while maintaining full Wyckoff methodology compliance.

## Acceptance Criteria

1. **Create forex position sizing module:** `backend/src/risk_management/forex_position_sizer.py`

2. **Pip calculation for major pairs:**
   - EUR/USD, GBP/USD, AUD/USD, NZD/USD: 4-decimal precision (0.0001 pip)
   - USD/JPY, USD/CAD, USD/CHF: 2-decimal precision (0.01 pip)
   - Calculate stop loss in pips: `stop_pips = abs(entry - stop) / pip_size`

3. **Pip value calculation:**
   - Standard lot (100,000 units): EUR/USD pip = $10, USD/JPY pip = ~$9.20 (varies)
   - Mini lot (10,000 units): EUR/USD pip = $1
   - Micro lot (1,000 units): EUR/USD pip = $0.10
   - Support cross-currency pip value conversion (e.g., GBP/JPY for USD account)

4. **Lot size calculation:**
   ```python
   def calculate_lot_size(
       account_balance: Decimal,
       risk_percent: Decimal,
       stop_loss_pips: Decimal,
       pip_value_per_lot: Decimal,
       lot_type: str = "mini"  # standard, mini, micro
   ) -> Decimal:
       risk_dollars = account_balance * (risk_percent / 100)
       lot_size = risk_dollars / (stop_loss_pips * pip_value_per_lot)
       return round(lot_size, 2)  # Round to 2 decimals (0.01 lots)
   ```

5. **Margin requirement validation:**
   - Calculate required margin: `margin = (lot_size Ã— contract_size) / leverage`
   - Validate: `required_margin <= available_margin`
   - Reject signal if margin insufficient
   - Support configurable leverage (50:1, 100:1, 200:1, 500:1)

6. **Lot type optimization:**
   - Prefer smallest lot type that meets minimum trade size
   - Example: If calculation yields 0.05 standard lots, suggest 5 mini lots instead
   - Support fractional lots (e.g., 0.33 lots = 33,000 units)

7. **Currency conversion support:**
   - Account currency: USD, EUR, GBP, AUD, JPY
   - Convert pip values to account currency using current exchange rate
   - Example: GBP account trading EUR/USD needs GBP/USD rate for conversion

8. **ForexPositionSize data model with Wyckoff context:**
   ```python
   @dataclass
   class ForexPositionSize:
       """Forex-specific position sizing result with Wyckoff methodology integration."""
       # Forex Mechanics
       symbol: str
       lot_size: Decimal  # e.g., 0.33 standard lots or 3.3 mini lots
       lot_type: str  # "standard", "mini", "micro"
       contract_size: int  # 100000, 10000, 1000
       position_units: int  # lot_size Ã— contract_size
       stop_loss_pips: Decimal
       pip_value: Decimal  # per 1 standard lot in account currency
       risk_dollars: Decimal
       required_margin: Decimal
       leverage: Decimal
       account_currency: str
       entry_price: Decimal
       stop_price: Decimal
       margin_warning: Optional[str] = None
       created_at: datetime = None

       # Wyckoff Context (NEW - Story 7.1 integration)
       pattern_type: str = None  # "SPRING", "SOS", "LPS"
       wyckoff_phase: str = None  # "C", "D", "E" (from PhaseDetector)
       base_risk_percent: Decimal = None  # 0.5%, 0.7%, 0.8% from pattern type

       # Volume Analysis (NEW - Story 7.1 AC 11)
       tick_volume: int = None  # Tick volume on signal bar
       avg_tick_volume: int = None  # 20-bar average tick volume
       volume_ratio: Decimal = None  # tick_volume / avg_tick_volume
       volume_multiplier: Decimal = None  # 0.70x - 1.00x risk adjustment

       # Session Analysis (NEW - Forex-specific)
       signal_timestamp: datetime = None  # When signal generated (UTC)
       trading_session: str = None  # "London/NY Overlap", "London", "NY", "Asian"
       session_multiplier: Decimal = None  # 0.75x - 1.00x risk adjustment

       # Effective Risk (NEW - After all adjustments)
       effective_risk_percent: Decimal = None  # base Ã— volume_mult Ã— session_mult

       # R-Multiple (NEW - Risk/Reward validation)
       target_price: Optional[Decimal] = None
       r_multiple: Optional[Decimal] = None  # (target - entry) / (entry - stop)

       # Spread Adjustment (NEW - Forex-specific)
       broker_spread_pips: Decimal = None  # Typical spread for pair
       spread_adjusted_stop: Decimal = None  # Stop after spread buffer

       def to_dict(self) -> dict:
           """Convert to dictionary for JSON serialization and audit trail."""
           # Implementation in Task 8
   ```

9. **Integration with SpringSignal and SOSSignal:**
   - Add `position_size: ForexPositionSize` field to forex signals
   - Stop loss already in price terms, convert to pips automatically
   - Attach margin requirement warning if >20% of account

10. **Pattern-specific validation and error handling:**
    - Reject if stop_pips violates pattern-specific range (use WYCKOFF_PIP_STOP_RANGES):
      - Spring: 20-70 pips depending on pair volatility
      - SOS: 50-150 pips depending on pair volatility
      - LPS: 25-80 pips depending on pair volatility
    - Reject if required_margin > 50% of account (over-leveraged)
    - Reject if position_units < minimum_lot_size for broker
    - Apply spread buffer to structural stops (half of typical spread)
    - Log all rejections with specific reason and typical pip range for pattern/pair

11. **Integration with Story 7.1 Risk Allocation (Wyckoff Volume Compliance):**
    - Use pattern-specific base risk percentages:
      - Spring (SPRING): 0.5% base risk (tight stops, high R:R)
      - Sign of Strength (SOS): 0.8% base risk (wider stops, breakout)
      - Last Point of Support (LPS): 0.7% base risk (confirmation entry)

    - Apply tick volume multiplier (Law #3: Effort vs Result):
      - Calculate tick volume ratio vs 20-bar average
      - â‰¥2.5x volume: 1.00x multiplier (climactic, full allocation)
      - â‰¥2.3x volume: 0.95x multiplier (very strong volume)
      - â‰¥2.0x volume: 0.90x multiplier (ideal professional volume)
      - â‰¥1.8x volume: 0.85x multiplier (strong volume)
      - â‰¥1.5x volume: 0.75x multiplier (adequate volume)
      - <1.5x volume: 0.70x multiplier (weak volume, reduce risk)

    - Apply forex session multiplier (institutional activity):
      - London/NY overlap (12:00-16:00 UTC): 1.00x (highest volume)
      - Single major session: 0.90x (good volume)
      - Asian session: 0.75x (ranging markets, lower volume)

    - Final lot size calculation:
      ```python
      effective_risk = base_risk Ã— volume_multiplier Ã— session_multiplier
      lot_size = (account Ã— effective_risk) / (stop_pips Ã— pip_value)
      ```

    - Log all adjustments with structured logging for audit trail

## Tasks / Subtasks

### **Task 1: Create forex position sizing module** (AC: 1)

- [ ] Create file: `backend/src/risk_management/forex_position_sizer.py`
- [ ] Add imports:
  ```python
  from decimal import Decimal
  from dataclasses import dataclass
  from datetime import datetime
  from typing import Optional, Literal
  from backend.src.risk_management.position_sizer import PositionSizer
  ```

### **Task 2: Implement pip calculation with spread adjustment** (AC: 2, 10)

- [ ] Create pip size configuration:
  ```python
  PIP_SIZES = {
      # 4-decimal pairs (most majors)
      "EUR/USD": Decimal("0.0001"),
      "GBP/USD": Decimal("0.0001"),
      "AUD/USD": Decimal("0.0001"),
      "NZD/USD": Decimal("0.0001"),
      # 2-decimal pairs (JPY pairs)
      "USD/JPY": Decimal("0.01"),
      "EUR/JPY": Decimal("0.01"),
      "GBP/JPY": Decimal("0.01"),
      # Add more pairs as needed
  }

  def get_pip_size(symbol: str) -> Decimal:
      if symbol in PIP_SIZES:
          return PIP_SIZES[symbol]
      # Default: 4 decimals for pairs with USD, 2 for JPY
      if "JPY" in symbol:
          return Decimal("0.01")
      return Decimal("0.0001")
  ```

- [ ] Create typical spreads configuration:
  ```python
  TYPICAL_SPREADS = {
      # Major pairs (low spread)
      "EUR/USD": Decimal("1.5"),  # 1.5 pips
      "GBP/USD": Decimal("2.0"),  # 2.0 pips
      "USD/JPY": Decimal("1.0"),  # 1.0 pips
      "AUD/USD": Decimal("1.8"),  # 1.8 pips
      "USD/CAD": Decimal("2.0"),  # 2.0 pips
      "USD/CHF": Decimal("1.5"),  # 1.5 pips
      # Cross pairs (higher spread)
      "EUR/JPY": Decimal("2.5"),  # 2.5 pips
      "GBP/JPY": Decimal("3.0"),  # 3.0 pips
      "EUR/GBP": Decimal("2.0"),  # 2.0 pips
  }
  ```

- [ ] Implement spread-adjusted stop calculation (NEW):
  ```python
  def adjust_stop_for_spread(
      structural_stop: Decimal,
      entry_price: Decimal,
      symbol: str,
      direction: str  # "long" or "short"
  ) -> Decimal:
      """
      Adjust Wyckoff structural stop for forex broker spread.

      Wyckoff Principle: Stops must be at structural levels.
      Forex Reality: Broker spread can cause premature stop-outs.
      Solution: Widen stop by half the spread to create buffer zone.
      """
      spread_pips = TYPICAL_SPREADS.get(symbol, Decimal("2.0"))
      pip_size = get_pip_size(symbol)
      spread_distance = spread_pips * pip_size
      spread_buffer = spread_distance / Decimal("2")

      if direction == "long":
          adjusted_stop = structural_stop - spread_buffer
      else:  # short
          adjusted_stop = structural_stop + spread_buffer

      return adjusted_stop

  def calculate_stop_pips_with_spread(
      entry: Decimal,
      structural_stop: Decimal,
      symbol: str,
      direction: str
  ) -> Decimal:
      """Calculate stop loss in pips including spread adjustment."""
      adjusted_stop = adjust_stop_for_spread(
          structural_stop, entry, symbol, direction
      )
      stop_distance = abs(entry - adjusted_stop)
      pip_size = get_pip_size(symbol)
      stop_pips = stop_distance / pip_size
      return stop_pips.quantize(Decimal("0.1"))
  ```

- [ ] Unit test: EUR/USD entry 1.0850, stop 1.0820 = 30 pips structural
- [ ] Unit test: EUR/USD 30 pip structural â†’ ~30.8 pips after spread (1.5 spread / 2)
- [ ] Unit test: USD/JPY entry 148.50, stop 147.00 = 150 pips
- [ ] Unit test: GBP/USD 50 pip structural â†’ ~51 pips after spread (2.0 spread / 2)

### **Task 3: Implement pip value calculation** (AC: 3)

- [ ] Create pip value calculator:
  ```python
  def calculate_pip_value(
      symbol: str,
      lot_type: str,
      account_currency: str = "USD",
      exchange_rates: dict[str, Decimal] = None
  ) -> Decimal:
      """
      Calculate pip value in account currency.

      For EUR/USD traded in USD account:
      - Standard lot (100k EUR): 1 pip = $10
      - Mini lot (10k EUR): 1 pip = $1
      - Micro lot (1k EUR): 1 pip = $0.10
      """
      base_currency, quote_currency = symbol.split("/")

      # Contract sizes
      contract_sizes = {
          "standard": 100000,
          "mini": 10000,
          "micro": 1000
      }
      contract_size = contract_sizes[lot_type]

      pip_size = get_pip_size(symbol)

      # For pairs quoted in account currency (e.g., EUR/USD for USD account)
      if quote_currency == account_currency:
          pip_value = contract_size * pip_size
      # For pairs where account currency is base (e.g., USD/JPY for USD account)
      elif base_currency == account_currency:
          # Pip value varies with price
          current_rate = exchange_rates.get(symbol, Decimal("1.0"))
          pip_value = (contract_size * pip_size) / current_rate
      else:
          # Cross-currency conversion needed
          conversion_rate = exchange_rates.get(f"{quote_currency}/{account_currency}", Decimal("1.0"))
          pip_value = contract_size * pip_size * conversion_rate

      return pip_value.quantize(Decimal("0.01"))
  ```

- [ ] Unit test: EUR/USD standard lot = $10/pip
- [ ] Unit test: EUR/USD mini lot = $1/pip
- [ ] Unit test: USD/JPY standard lot â‰ˆ $9.20/pip (rate-dependent)

### **Task 4: Implement lot size calculation** (AC: 4)

- [ ] Create lot size calculator:
  ```python
  def calculate_lot_size(
      account_balance: Decimal,
      risk_percent: Decimal,
      stop_loss_pips: Decimal,
      pip_value_per_lot: Decimal,
      lot_type: str = "mini"
  ) -> Decimal:
      """
      Calculate position size in lots.

      Formula: lot_size = risk_dollars / (stop_pips Ã— pip_value)
      """
      risk_dollars = account_balance * (risk_percent / Decimal("100"))
      lot_size = risk_dollars / (stop_loss_pips * pip_value_per_lot)

      # Round to 2 decimals (0.01 lots)
      return lot_size.quantize(Decimal("0.01"))
  ```

- [ ] Unit test: $10k account, 1% risk, 30 pip stop, $1/pip â†’ 3.33 mini lots
- [ ] Unit test: $50k account, 2% risk, 50 pip stop, $10/pip â†’ 2.00 standard lots

### **Task 5: Implement margin validation** (AC: 5)

- [ ] Create margin calculator:
  ```python
  def calculate_required_margin(
      lot_size: Decimal,
      lot_type: str,
      symbol: str,
      leverage: Decimal,
      exchange_rates: dict[str, Decimal]
  ) -> Decimal:
      """
      Calculate margin requirement.

      Margin = (lot_size Ã— contract_size Ã— current_price) / leverage
      """
      contract_sizes = {
          "standard": 100000,
          "mini": 10000,
          "micro": 1000
      }
      contract_size = contract_sizes[lot_type]

      # Get current market price
      current_price = exchange_rates.get(symbol, Decimal("1.0"))

      # Total position value in quote currency
      position_value = lot_size * contract_size * current_price

      # Margin required
      required_margin = position_value / leverage

      return required_margin.quantize(Decimal("0.01"))

  def validate_margin(
      required_margin: Decimal,
      available_margin: Decimal
  ) -> tuple[bool, Optional[str]]:
      """Validate sufficient margin available."""
      if required_margin > available_margin:
          return False, f"Insufficient margin: need ${required_margin}, have ${available_margin}"

      if required_margin > (available_margin * Decimal("0.5")):
          return True, f"WARNING: Using {(required_margin/available_margin*100):.1f}% of available margin"

      return True, None
  ```

- [ ] Unit test: 0.33 lots, 50:1 leverage, EUR/USD 1.0850 â†’ $715 margin
- [ ] Unit test: Reject if required_margin > available_margin

### **Task 6: Implement lot type optimization** (AC: 6)

- [ ] Create lot type optimizer:
  ```python
  def optimize_lot_type(
      target_lot_size: Decimal,
      initial_lot_type: str = "standard"
  ) -> tuple[Decimal, str]:
      """
      Convert to smallest practical lot type.

      Example: 0.05 standard lots â†’ 5 mini lots (cleaner)
      """
      if initial_lot_type == "standard":
          # If less than 0.1 standard, convert to mini
          if target_lot_size < Decimal("0.1"):
              return target_lot_size * 10, "mini"

      if initial_lot_type == "mini":
          # If less than 0.1 mini, convert to micro
          if target_lot_size < Decimal("0.1"):
              return target_lot_size * 10, "micro"

      return target_lot_size, initial_lot_type
  ```

- [ ] Unit test: 0.05 standard lots â†’ 5 mini lots
- [ ] Unit test: 0.08 mini lots â†’ 8 micro lots

### **Task 7: Implement currency conversion** (AC: 7)

- [ ] Create currency converter:
  ```python
  def convert_to_account_currency(
      amount: Decimal,
      from_currency: str,
      to_currency: str,
      exchange_rates: dict[str, Decimal]
  ) -> Decimal:
      """Convert amount between currencies."""
      if from_currency == to_currency:
          return amount

      # Try direct rate
      pair = f"{from_currency}/{to_currency}"
      if pair in exchange_rates:
          return amount * exchange_rates[pair]

      # Try inverse rate
      inverse_pair = f"{to_currency}/{from_currency}"
      if inverse_pair in exchange_rates:
          return amount / exchange_rates[inverse_pair]

      # Fallback: convert through USD
      if from_currency != "USD" and to_currency != "USD":
          usd_amount = convert_to_account_currency(amount, from_currency, "USD", exchange_rates)
          return convert_to_account_currency(usd_amount, "USD", to_currency, exchange_rates)

      raise ValueError(f"No exchange rate found for {from_currency}/{to_currency}")
  ```

- [ ] Unit test: Convert EUR pip value to GBP account currency

### **Task 8: Create ForexPositionSize data model** (AC: 8)

- [ ] Implement data model:
  ```python
  @dataclass
  class ForexPositionSize:
      """Forex-specific position sizing result."""
      symbol: str
      lot_size: Decimal  # e.g., 3.33
      lot_type: str  # "standard", "mini", "micro"
      contract_size: int  # 100000, 10000, 1000
      position_units: int  # lot_size Ã— contract_size
      stop_loss_pips: Decimal
      pip_value: Decimal  # per 1 standard lot in account currency
      risk_dollars: Decimal
      required_margin: Decimal
      leverage: Decimal
      account_currency: str
      entry_price: Decimal
      stop_price: Decimal
      margin_warning: Optional[str] = None
      created_at: datetime = None

      def __post_init__(self):
          if self.created_at is None:
              self.created_at = datetime.utcnow()

          # Calculate position_units
          contract_sizes = {"standard": 100000, "mini": 10000, "micro": 1000}
          self.position_units = int(self.lot_size * contract_sizes[self.lot_type])
  ```

- [ ] Unit test: Create ForexPositionSize instance, verify all fields populated

### **Task 9: Integrate with signal models** (AC: 9)

- [ ] Update SpringSignal model:
  ```python
  @dataclass
  class SpringSignal:
      # ... existing fields ...
      position_size: Optional[ForexPositionSize] = None  # Forex-specific

      def calculate_position_size(
          self,
          account_balance: Decimal,
          risk_percent: Decimal,
          leverage: Decimal = Decimal("50"),
          account_currency: str = "USD"
      ) -> ForexPositionSize:
          """Calculate forex position size for this signal."""
          if self.asset_class != "forex":
              raise ValueError("Use standard PositionSize for non-forex signals")

          # Calculate pip-based position size
          # ... (implementation in forex_position_sizer.py)
  ```

- [ ] Update SOSSignal model (similar pattern)
- [ ] Unit test: Generate spring signal, calculate forex position size

### **Task 10: Implement pattern-specific validation** (AC: 10)

- [ ] Create Wyckoff pip stop ranges table:
  ```python
  WYCKOFF_PIP_STOP_RANGES = {
      "SPRING": {
          "EUR/USD": {"min": 20, "max": 50, "typical": 30},
          "GBP/USD": {"min": 30, "max": 70, "typical": 45},
          "USD/JPY": {"min": 25, "max": 60, "typical": 35},
          "AUD/USD": {"min": 25, "max": 60, "typical": 35},
          "USD/CAD": {"min": 25, "max": 60, "typical": 35},
          "NZD/USD": {"min": 30, "max": 70, "typical": 40},
      },
      "SOS": {
          "EUR/USD": {"min": 50, "max": 100, "typical": 70},
          "GBP/USD": {"min": 70, "max": 150, "typical": 100},
          "USD/JPY": {"min": 60, "max": 120, "typical": 85},
          "AUD/USD": {"min": 55, "max": 110, "typical": 75},
          "USD/CAD": {"min": 55, "max": 110, "typical": 75},
          "NZD/USD": {"min": 60, "max": 120, "typical": 85},
      },
      "LPS": {
          "EUR/USD": {"min": 25, "max": 60, "typical": 40},
          "GBP/USD": {"min": 35, "max": 80, "typical": 55},
          "USD/JPY": {"min": 30, "max": 70, "typical": 45},
          "AUD/USD": {"min": 30, "max": 70, "typical": 45},
          "USD/CAD": {"min": 30, "max": 70, "typical": 45},
          "NZD/USD": {"min": 35, "max": 75, "typical": 50},
      }
  }
  ```

- [ ] Create pattern-specific validator:
  ```python
  def validate_wyckoff_stop_pips(
      pattern_type: str,
      symbol: str,
      stop_pips: Decimal
  ) -> tuple[bool, Optional[str]]:
      """
      Validate stop is within Wyckoff structural range for pattern.

      Wyckoff Principle: Stops must be structural (below support/resistance),
      not arbitrary pip counts. Different patterns require different stop widths.
      """
      ranges = WYCKOFF_PIP_STOP_RANGES.get(pattern_type, {})
      range_data = ranges.get(symbol)

      if range_data is None:
          # Fallback for unlisted pairs: conservative range
          min_pips, max_pips = 15, 150
          typical = 50
      else:
          min_pips = range_data["min"]
          max_pips = range_data["max"]
          typical = range_data["typical"]

      if stop_pips < Decimal(str(min_pips)):
          return (
              False,
              f"{pattern_type} stop too tight: {stop_pips} pips < {min_pips} pip minimum "
              f"for {symbol} (typical: {typical} pips). Wyckoff principle: stops must be "
              f"below structural support."
          )

      if stop_pips > Decimal(str(max_pips)):
          return (
              False,
              f"{pattern_type} stop too wide: {stop_pips} pips > {max_pips} pip maximum "
              f"for {symbol} (typical: {typical} pips). Giving market too much room."
          )

      return True, None

  def validate_forex_position(
      stop_pips: Decimal,
      required_margin: Decimal,
      available_margin: Decimal,
      position_units: int,
      pattern_type: str = None,  # NEW: Pattern validation
      symbol: str = None,  # NEW: Pattern validation
      min_lot_size: int = 1000
  ) -> tuple[bool, Optional[str]]:
      """Validate forex position meets requirements (Wyckoff + Forex mechanics)."""

      # Pattern-specific stop validation (NEW)
      if pattern_type and symbol:
          is_valid, error = validate_wyckoff_stop_pips(pattern_type, symbol, stop_pips)
          if not is_valid:
              return False, error

      # Check margin requirement
      if required_margin > available_margin:
          return False, f"Insufficient margin: need ${required_margin}, have ${available_margin}"

      # Check over-leverage
      if required_margin > (available_margin * Decimal("0.5")):
          return False, f"Over-leveraged: using {(required_margin/available_margin*100):.1f}% of margin"

      # Check minimum position size
      if position_units < min_lot_size:
          return False, f"Position too small: {position_units} units < {min_lot_size} minimum"

      return True, None
  ```

- [ ] Unit test: SPRING EUR/USD 30 pips â†’ PASS (within 20-50 range)
- [ ] Unit test: SPRING EUR/USD 10 pips â†’ FAIL (too tight, below 20 minimum)
- [ ] Unit test: SOS GBP/USD 100 pips â†’ PASS (within 70-150 range)
- [ ] Unit test: SOS EUR/USD 200 pips â†’ FAIL (too wide, above 100 maximum)
- [ ] Unit test: Reject margin >50% of account
- [ ] Unit test: Reject position <1000 units

### **Task 11: Implement Wyckoff volume/session integration** (AC: 11) **NEW**

- [ ] Create forex volume multiplier function:
  ```python
  def get_forex_volume_multiplier(
      tick_volume: int,
      avg_tick_volume: int
  ) -> Decimal:
      """
      Calculate volume-adjusted risk multiplier for forex using tick volume.

      Wyckoff Law #3: "Effort (volume) must validate Result (price movement)."
      Higher tick volume = stronger institutional participation = higher confidence.

      Args:
          tick_volume: Tick volume on pattern formation bar
          avg_tick_volume: Average tick volume over last 20 bars

      Returns:
          Risk multiplier (0.70x - 1.00x)
      """
      if avg_tick_volume == 0:
          return Decimal("1.0")  # No volume data, use full allocation

      volume_ratio = Decimal(str(tick_volume)) / Decimal(str(avg_tick_volume))

      # Same tiers as Story 7.1 (5-tier system)
      if volume_ratio >= Decimal("2.5"):
          return Decimal("1.00")  # Climactic volume (full commitment)
      elif volume_ratio >= Decimal("2.3"):
          return Decimal("0.95")  # Very strong volume
      elif volume_ratio >= Decimal("2.0"):
          return Decimal("0.90")  # Ideal professional volume
      elif volume_ratio >= Decimal("1.8"):
          return Decimal("0.85")  # Strong volume
      elif volume_ratio >= Decimal("1.5"):
          return Decimal("0.75")  # Adequate volume
      else:
          return Decimal("0.70")  # Weak volume (reduce risk)
  ```

- [ ] Create forex session multiplier function:
  ```python
  def get_forex_session_multiplier(
      symbol: str,
      timestamp: datetime
  ) -> Decimal:
      """
      Adjust risk based on forex trading session.

      Wyckoff Principle: Composite Operator (institutional banks) most active
      during major session overlaps. Springs/SOS during high-volume sessions
      have higher probability of success.

      Trading Sessions (UTC):
      - Asian (Tokyo): 0:00-9:00 UTC - Lower volume, ranging markets
      - London: 7:00-16:00 UTC - High volume, trend initiation
      - New York: 12:00-21:00 UTC - High volume, trend continuation
      - London/NY overlap: 12:00-16:00 UTC - HIGHEST institutional activity

      Args:
          symbol: Currency pair (e.g., "EUR/USD")
          timestamp: Signal timestamp (UTC)

      Returns:
          Session multiplier (0.75x - 1.00x)
      """
      hour_utc = timestamp.hour

      # London/NY overlap (12:00-16:00 UTC) - HIGHEST volume
      if 12 <= hour_utc < 16:
          return Decimal("1.00")  # Full risk allocation (Composite Operator active)

      # London session (7:00-16:00 UTC) or NY session (12:00-21:00 UTC)
      if (7 <= hour_utc < 16) or (12 <= hour_utc < 21):
          return Decimal("0.90")  # Slight reduction (single-session activity)

      # Asian session (0:00-9:00 UTC) - Lower volume, ranging markets
      return Decimal("0.75")  # Conservative sizing (retail-dominated)
  ```

- [ ] Create integrated Wyckoff lot size calculator:
  ```python
  def calculate_forex_lot_size_with_wyckoff_adjustments(
      account_balance: Decimal,
      pattern_type: str,  # "SPRING", "SOS", "LPS"
      stop_loss_pips: Decimal,
      pip_value_per_lot: Decimal,
      tick_volume: int,
      avg_tick_volume: int,
      signal_timestamp: datetime,
      symbol: str,
      lot_type: str = "mini"
  ) -> tuple[Decimal, dict]:
      """
      Calculate forex lot size with full Wyckoff methodology integration.

      Combines:
      - Story 7.1 pattern-specific base risk (Spring 0.5%, SOS 0.8%, LPS 0.7%)
      - Story 7.1 volume-adjusted multipliers (0.70x - 1.00x)
      - Forex session multipliers (0.75x - 1.00x)

      Formula:
          effective_risk = base_risk Ã— volume_multiplier Ã— session_multiplier
          lot_size = (account Ã— effective_risk) / (stop_pips Ã— pip_value)

      Returns:
          (lot_size, adjustment_details)
      """
      # Get base risk from Story 7.1 pattern allocations
      base_risk_pct = {
          "SPRING": Decimal("0.5"),  # 0.5% (tight stops, high R:R)
          "SOS": Decimal("0.8"),     # 0.8% (wider stops, breakout risk)
          "LPS": Decimal("0.7")      # 0.7% (medium stops, confirmation entry)
      }.get(pattern_type, Decimal("0.5"))

      # Get volume multiplier (Story 7.1 integration)
      volume_multiplier = get_forex_volume_multiplier(tick_volume, avg_tick_volume)

      # Get session multiplier (forex-specific)
      session_multiplier = get_forex_session_multiplier(symbol, signal_timestamp)

      # Calculate effective risk
      effective_risk_pct = base_risk_pct * volume_multiplier * session_multiplier

      # Calculate lot size
      risk_dollars = account_balance * (effective_risk_pct / Decimal("100"))
      lot_size = risk_dollars / (stop_loss_pips * pip_value_per_lot)
      lot_size = lot_size.quantize(Decimal("0.01"))  # Round to 0.01 lots

      # Return lot size + adjustment details for logging
      adjustment_details = {
          "base_risk_percent": str(base_risk_pct),
          "volume_multiplier": str(volume_multiplier),
          "session_multiplier": str(session_multiplier),
          "effective_risk_percent": str(effective_risk_pct),
          "risk_dollars": str(risk_dollars),
          "volume_ratio": str(Decimal(str(tick_volume)) / Decimal(str(avg_tick_volume)))
              if avg_tick_volume > 0 else "N/A"
      }

      return lot_size, adjustment_details
  ```

- [ ] Unit test: Forex volume multiplier 2.5x â†’ 1.00x (climactic)
- [ ] Unit test: Forex volume multiplier 1.2x â†’ 0.70x (weak)
- [ ] Unit test: Session multiplier London/NY overlap (14:00 UTC) â†’ 1.00x
- [ ] Unit test: Session multiplier Asian session (03:00 UTC) â†’ 0.75x
- [ ] Unit test: Full Wyckoff calculation - Spring + climactic volume + overlap â†’ full allocation
- [ ] Unit test: Full Wyckoff calculation - SOS + weak volume + Asian â†’ reduced allocation

## Deliverables

- âœ… `backend/src/risk_management/forex_position_sizer.py` - Forex position sizing module with Wyckoff integration
- âœ… `ForexPositionSize` data model with pip/lot/margin calculations + Wyckoff context fields
- âœ… Pattern-specific pip stop ranges (WYCKOFF_PIP_STOP_RANGES table)
- âœ… Spread-adjusted stop calculation functions
- âœ… Forex volume multiplier integration (Story 7.1 compliance)
- âœ… Forex session multiplier functions (London/NY overlap detection)
- âœ… Integration with SpringSignal and SOSSignal (forex signals only)
- âœ… Unit tests: 41+ tests (original 15 + 26 Wyckoff enhancements)
  - Pip calculation: 4 tests (including spread adjustment)
  - Pattern-specific validation: 6 tests
  - Volume/session multipliers: 6 tests
  - Wyckoff lot sizing: 2 tests
  - Original forex mechanics: 15 tests
  - Data model: 8 tests
- âœ… Integration tests: 6 scenarios
  - EUR/USD, USD/JPY, GBP/USD (original 3)
  - Spring + climactic volume + London/NY overlap (NEW)
  - SOS + weak volume + Asian session (NEW)
  - Pattern stop validation rejection (NEW)

## Definition of Done

- [ ] All acceptance criteria met (AC 1-11)
- [ ] All tasks completed (Tasks 1-11)
- [ ] Pip calculation accurate for 4-decimal and 2-decimal pairs
- [ ] Spread-adjusted stop calculation working correctly
- [ ] Pattern-specific pip stop validation enforced (WYCKOFF_PIP_STOP_RANGES)
- [ ] Volume multiplier integration with tick volume (Story 7.1 compliance)
- [ ] Session multiplier functions (London/NY overlap detection)
- [ ] Lot size calculation produces correct fractional lots with Wyckoff adjustments
- [ ] Margin validation prevents over-leveraged positions (<50% margin usage)
- [ ] Currency conversion working for multi-currency accounts
- [ ] ForexPositionSize model includes all Wyckoff context fields
- [ ] Code passes mypy --strict
- [ ] Code passes flake8
- [ ] Unit tests passing (41+ tests, 90%+ coverage)
- [ ] Integration tests passing (6 scenarios: 3 original + 3 Wyckoff)
- [ ] Code reviewed by Wyckoff team (William, Victoria, Rachel)
- [ ] Structured logging added for all risk adjustments
- [ ] Merged to main branch

## Notes

**Pip Value Reference Table** (Standard Lots, USD Account):

| Pair | Pip Size | Pip Value | Notes |
|------|----------|-----------|-------|
| EUR/USD | 0.0001 | $10.00 | Fixed (quote = USD) |
| GBP/USD | 0.0001 | $10.00 | Fixed (quote = USD) |
| AUD/USD | 0.0001 | $10.00 | Fixed (quote = USD) |
| USD/JPY | 0.01 | ~$9.20 | Varies with rate |
| USD/CAD | 0.0001 | ~$7.50 | Varies with rate |
| EUR/JPY | 0.01 | ~$9.20 | Needs conversion |
| GBP/JPY | 0.01 | ~$9.20 | Needs conversion |

**Lot Size Examples:**

Account: $10,000, Risk: 1% = $100

| Pair | Entry | Stop | Pips | Pip Value | Lot Size |
|------|-------|------|------|-----------|----------|
| EUR/USD | 1.0850 | 1.0820 | 30 | $1 (mini) | 3.33 mini lots |
| GBP/USD | 1.2650 | 1.2600 | 50 | $1 (mini) | 2.00 mini lots |
| USD/JPY | 148.50 | 147.50 | 100 | $0.92 (mini) | 1.09 mini lots |

**Margin Calculation Examples:**

Leverage: 50:1

| Position | Lot Size | Contract Size | Pair | Price | Margin Required |
|----------|----------|---------------|------|-------|-----------------|
| 3.33 mini | 3.33 | 10,000 | EUR/USD | 1.0850 | $723 |
| 2.00 mini | 2.00 | 10,000 | GBP/USD | 1.2650 | $506 |
| 0.50 standard | 0.50 | 100,000 | USD/JPY | 148.50 | $1,485 |

**Volume/Session Multiplier Examples (NEW):**

Account: $10,000, Pattern: Spring (base risk 0.5%)

| Tick Volume | Volume Ratio | Volume Mult | Session (UTC) | Session Mult | Effective Risk | Risk $ |
|-------------|--------------|-------------|---------------|--------------|----------------|--------|
| 2500 (avg 1000) | 2.5x | 1.00x | 14:00 (London/NY) | 1.00x | 0.50% | $50 |
| 2000 (avg 1000) | 2.0x | 0.90x | 14:00 (London/NY) | 1.00x | 0.45% | $45 |
| 1500 (avg 1000) | 1.5x | 0.75x | 14:00 (London/NY) | 1.00x | 0.38% | $38 |
| 1200 (avg 1000) | 1.2x | 0.70x | 14:00 (London/NY) | 1.00x | 0.35% | $35 |
| 2500 (avg 1000) | 2.5x | 1.00x | 10:00 (London only) | 0.90x | 0.45% | $45 |
| 2500 (avg 1000) | 2.5x | 1.00x | 03:00 (Asian) | 0.75x | 0.38% | $38 |
| 1200 (avg 1000) | 1.2x | 0.70x | 03:00 (Asian) | 0.75x | 0.26% | $26 |

**Pattern-Specific Pip Stop Ranges (NEW):**

| Pattern | EUR/USD | GBP/USD | USD/JPY | Rationale |
|---------|---------|---------|---------|-----------|
| SPRING | 20-50 pips | 30-70 pips | 25-60 pips | Tight stops below shake-out low (Phase C test) |
| SOS | 50-100 pips | 70-150 pips | 60-120 pips | Wider stops below range support (Phase D breakout) |
| LPS | 25-60 pips | 35-80 pips | 30-70 pips | Medium stops below pullback low (Phase D confirmation) |

**Wyckoff Team Review:**

**William (Wyckoff Mentor) - Methodology Compliance:**

> "This enhanced version achieves A- grade (92/100) by integrating full Wyckoff methodology with forex mechanics. The pattern-specific pip stops honor structural support/resistance levels - a Spring at 25 pips on EUR/USD is structurally sound, while generic 5-200 pip range was arbitrary. The volume/session multipliers apply Law #3 (Effort vs Result) to tick volume, ensuring climactic Springs get full allocation while weak-volume patterns get reduced risk. The spread adjustment prevents the amateur mistake of structural stops getting hit by bid/ask spread. This is professional-grade forex sizing that Richard Wyckoff would approve of."

**Victoria (Volume Specialist) - Tick Volume Integration:**

> "Applying Story 7.1's volume multiplier framework to forex tick volume is methodologically sound. While forex lacks centralized exchange volume, tick volume (number of price changes) is a reliable proxy for institutional activity. A 2.5x tick volume Spring during London/NY overlap shows Composite Operator absorption - this deserves full 0.5% allocation. A weak 1.3x volume Spring during Asian session lacks professional participation - 0.35% effective risk (0.5% Ã— 0.70) is appropriate. The session multipliers correctly identify when the 'smart money' is active."

**Rachel (Risk Specialist) - Pattern-Specific Stops:**

> "The WYCKOFF_PIP_STOP_RANGES table is a game-changer. Generic pip ranges ignore volatility differences between pairs and structural requirements of patterns. EUR/USD Spring stops (20-50 pips) vs GBP/USD Spring stops (30-70 pips) reflect real volatility. SOS stops (50-150 pips) are wider because you're placing stops below the entire range, not just the Spring low. The spread buffer (half the spread) prevents premature stop-outs - a 30-pip structural stop on EUR/USD becomes 30.75 pips to account for the 1.5-pip spread. This prevents the disaster of getting stopped at 1.08195 when your stop was 1.0820. The 50% margin rule saved my account during the 2015 Swiss franc crisis - this is non-negotiable."

**QA Assessment (Story 7.2-FX Enhancement Review):**

> **Before Enhancement:** B+ (87/100) - Excellent forex mechanics, missing Wyckoff integration
> **After Enhancement:** A- (92/100) - Production-ready Wyckoff-compliant forex sizing
> **Story Point Increase:** 8 SP â†’ 11 SP (+3 SP for Wyckoff integration)
> **Additional Effort:** ~16 hours (pattern stops 4h + volume integration 8h + spread adjustment 2h + data model 2h)
> **Test Increase:** 15 tests â†’ 41 tests (+26 tests for Wyckoff features)
> **Recommendation:** âœ… IMPLEMENT ALL ENHANCEMENTS TOGETHER - Do not ship forex sizing without Wyckoff integration, as it would violate methodology consistency with Story 7.1.

**Integration Notes:**

- **Story 7.1 Dependency:** Uses pattern base risk (0.5%/0.7%/0.8%) and volume multiplier framework
- **Story 7.4 Benefit:** Enhanced ForexPositionSize model with Wyckoff fields enables campaign risk tracking
- **Data Provider Requirements:** Tick volume data (most forex brokers provide this) and UTC timestamps

---

**Story Created:** 2025-11-14
**Last Updated:** 2025-11-16 (Enhanced with Wyckoff integration per QA review)
**Status:** Ready for Development
