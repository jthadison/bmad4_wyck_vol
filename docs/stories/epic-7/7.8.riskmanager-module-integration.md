# Story 7.8: RiskManager Module Integration

## Status
Done

## Story
**As a** developer,
**I want** a unified RiskManager that validates all risk constraints and calculates position sizes,
**so that** the orchestrator can ensure all signals meet risk requirements.

## Acceptance Criteria
1. Class: `RiskManager` with method `validate_and_size(signal, portfolio_context, trading_range) -> PositionSizing`
2. Validation pipeline: pattern risk → phase prerequisites (Story 7.9, includes volume validation) → R-multiple → structural stop → position size → portfolio heat → campaign risk → correlated risk
3. PositionSizing dataclass: shares, entry, stop, target, risk_amount, risk_pct, r_multiple, validation_pipeline, phase_validation (explicit field from Story 7.9)
4. Rejection returns: None if any validation fails, with detailed rejection reasons
5. Approval returns: PositionSizing object with all calculated values
6. Thread-safe: multiple concurrent validation requests supported
7. Unit test: end-to-end validation with synthetic signal and portfolio
8. Integration test: validate signals for full campaign (Spring → ST → SOS → LPS) including ST position sizing and campaign allocation
9. Performance: validation in <10ms per signal (phase validation adds ~0.5ms)
10. API compatibility: PositionSizing serializable to JSON
11. Early rejection: phase validation failure short-circuits before R-multiple calculation
12. Signal source: Signal object contains preliminary stop from pattern detector (Story 7.7), Step 4 validates and may adjust stop based on buffer constraints

## Tasks / Subtasks

- [ ] Create PortfolioContext data model (AC: 1)
  - [ ] Define `PortfolioContext` Pydantic model in `backend/src/models/portfolio.py`
  - [ ] Fields: `account_equity: Decimal`, `open_positions: list[Position]`, `active_campaigns: list[Campaign]`, `sector_mappings: dict[str, SectorMapping]`
  - [ ] Add correlation config: `correlation_config: CorrelationConfig`
  - [ ] Add r_multiple config: `r_multiple_config: dict[str, RMultipleConfig]`
  - [ ] Use Decimal for all financial fields (NFR20 compliance)
  - [ ] Add JSON encoders for Decimal serialization

- [ ] Create ValidationResult data model (AC: 3, 4)
  - [ ] Define `ValidationResult` Pydantic model in `backend/src/models/validation.py` (new file)
  - [ ] Fields: `is_valid: bool`, `validation_step: str`, `rejection_reason: str | None`, `warnings: list[str]`
  - [ ] Define `ValidationPipeline` dataclass: `results: list[ValidationResult]`, `is_valid: bool`, `rejection_reason: str | None`
  - [ ] Method: `add_result(result: ValidationResult) -> None`
  - [ ] Method: `get_first_failure() -> ValidationResult | None`
  - [ ] Property: `all_warnings: list[str]` - aggregates warnings from all steps

- [ ] Update PositionSizing model with validation results (AC: 3)
  - [ ] Update `PositionSizing` model in `backend/src/models/position_sizing.py` (from Story 7.2)
  - [ ] Add field: `r_multiple: Decimal` (calculated in validation pipeline)
  - [ ] Add field: `validation_pipeline: ValidationPipeline` (full validation history)
  - [ ] Add field: `phase_validation: PhaseValidation | None` (explicit field from Story 7.9 for audit trail)
  - [ ] Add field: `portfolio_heat_after: Decimal` (projected heat after position)
  - [ ] Add field: `campaign_risk_after: Decimal | None` (projected campaign risk if applicable)
  - [ ] Add field: `correlated_risks: dict[str, Decimal]` (sector/asset_class/geography risks)
  - [ ] Ensure all Decimal fields have JSON encoders

- [ ] Create RiskManager class with initialization (AC: 1, 6)
  - [ ] Create file: `backend/src/risk_management/risk_manager.py`
  - [ ] Import all validation modules from Stories 7.1-7.9
  - [ ] Define `RiskManager` class with async __init__
  - [ ] Load dependencies:
    - `risk_allocator: RiskAllocator` (Story 7.1)
    - `position_calculator` (Story 7.2)
    - `portfolio_heat_calculator` (Story 7.3)
    - `campaign_risk_calculator` (Story 7.4)
    - `correlation_validator` (Story 7.5)
    - `r_multiple_validator` (Story 7.6)
    - `stop_calculator` (Story 7.7)
    - `phase_validator` (Story 7.9)
  - [ ] Add thread lock: `asyncio.Lock()` for thread-safe concurrent access (AC: 6)
  - [ ] Add structured logging with structlog
  - [ ] Validate all dependencies loaded successfully in __init__

- [ ] Implement Step 1: Pattern risk validation (AC: 2)
  - [ ] Create method: `async _validate_pattern_risk(pattern_type: str, signal: Signal) -> ValidationResult`
  - [ ] Call `risk_allocator.get_pattern_risk_pct(pattern_type)` from Story 7.1
  - [ ] Validate risk_pct ≤ 2.0% (FR18 per-trade maximum)
  - [ ] Return ValidationResult with is_valid=True or False
  - [ ] Log validation step with structlog

- [ ] Implement Step 2: Phase prerequisite validation (AC: 2, 11, 12) [NEW from Story 7.9]
  - [ ] Create method: `async _validate_phase_prerequisites(pattern: Pattern, trading_range: TradingRange, mode: str) -> ValidationResult`
  - [ ] Call `validate_phase_prerequisites()` from Story 7.9
  - [ ] Check if Wyckoff phase prerequisites are met (Spring needs PS/SC/AR, SOS needs Spring+ST, etc.)
  - [ ] Phase validation INCLUDES volume prerequisites (PS/SC climax for Spring, volume surge for SOS)
  - [ ] SHORT-CIRCUIT: If phase validation fails, return immediately without continuing to R-multiple
  - [ ] Capture missing prerequisites in rejection_reason
  - [ ] Return ValidationResult with is_valid, rejection_reason, warnings
  - [ ] Store PhaseValidation result for inclusion in PositionSizing.phase_validation field
  - [ ] Log phase validation status with detected events and missing events

- [ ] Implement Step 3: R-multiple validation (AC: 2, 12)
  - [ ] Create method: `async _validate_r_multiple(entry: Decimal, stop: Decimal, target: Decimal, pattern_type: str) -> ValidationResult`
  - [ ] Call `validate_r_multiple()` from Story 7.6
  - [ ] Use Signal.stop (preliminary stop from pattern detector) for R-multiple calculation
  - [ ] Check if R-multiple meets minimum requirements for pattern type (Spring 3.0R, SOS 2.5R, LPS 2.5R, UTAD 3.5R)
  - [ ] Capture warnings (below ideal but acceptable)
  - [ ] Return ValidationResult with is_valid, rejection_reason, warnings
  - [ ] Log R-multiple calculation and validation status

- [ ] Implement Step 4: Structural stop calculation (AC: 2, 12) [Clarified from Story 7.7]
  - [ ] Create method: `async _calculate_structural_stop(pattern: Pattern, trading_range: TradingRange) -> ValidationResult`
  - [ ] Call `calculate_structural_stop()` from Story 7.7
  - [ ] Validate Signal.stop (preliminary stop from pattern detector) is structural (not arbitrary percentage)
  - [ ] Validate stop buffer is 1-10% from entry
  - [ ] If buffer <1%, widen stop to 1% minimum (automatic adjustment)
  - [ ] If buffer >10%, reject signal (unrealistic risk)
  - [ ] Return ValidationResult with is_valid, adjusted_stop (if modified), rejection_reason
  - [ ] Log structural stop validation and any adjustments applied

- [ ] Implement Step 5: Position size calculation (AC: 2, 3)
  - [ ] Create method: `async _calculate_position_size(account_equity: Decimal, pattern_type: str, entry: Decimal, stop: Decimal, risk_pct: Decimal) -> tuple[int, Decimal, Decimal]`
  - [ ] Call `calculate_position_size()` from Story 7.2
  - [ ] Calculate shares, risk_amount, actual_risk_pct
  - [ ] Validate shares ≥ 1 (minimum position)
  - [ ] Validate position_value ≤ 20% account_equity
  - [ ] Return (shares, risk_amount, actual_risk_pct)
  - [ ] Log position sizing details

- [ ] Implement Step 6: Portfolio heat validation (AC: 2)
  - [ ] Create method: `async _validate_portfolio_heat(current_positions: list[Position], new_position_risk: Decimal) -> ValidationResult`
  - [ ] Call `calculate_portfolio_heat()` from Story 7.3
  - [ ] Calculate current heat + new position risk
  - [ ] Validate projected heat ≤ 10.0% (FR18 portfolio maximum)
  - [ ] Check proximity warning (heat ≥ 8.0%)
  - [ ] Return ValidationResult with is_valid, warnings
  - [ ] Log portfolio heat calculation

- [ ] Implement Step 7: Campaign risk validation (AC: 2)
  - [ ] Create method: `async _validate_campaign_risk(campaign_id: UUID | None, current_positions: list[Position], new_position_risk: Decimal, pattern_type: str) -> ValidationResult`
  - [ ] If campaign_id is None, skip validation (return is_valid=True)
  - [ ] Call `calculate_campaign_risk(campaign_id, open_positions)` from Story 7.4
  - [ ] Calculate projected campaign risk: current + new_position_risk
  - [ ] Validate projected risk ≤ 5.0% (FR18 campaign maximum)
  - [ ] Validate BMAD allocation: Spring 25%, ST 20%, SOS 35%, LPS 20%
  - [ ] Check proximity warning (campaign risk ≥ 4.0%)
  - [ ] Return ValidationResult with is_valid, warnings
  - [ ] Log campaign risk calculation

- [ ] Implement Step 8: Correlated risk validation (AC: 2)
  - [ ] Create method: `async _validate_correlated_risk(new_position: Signal, new_position_risk: Decimal, open_positions: list[Position], correlation_config: CorrelationConfig) -> ValidationResult`
  - [ ] Call `validate_correlated_risk()` from Story 7.5
  - [ ] Validate all correlation levels: sector, asset_class, geography
  - [ ] Check if ANY level exceeds 6.0% (strict mode rejects)
  - [ ] Capture warnings from permissive mode or proximity alerts
  - [ ] Return ValidationResult with is_valid, rejection_reason, warnings
  - [ ] Log correlation validation results

- [ ] Implement main validate_and_size method (AC: 1, 2, 3, 4, 5, 6, 11, 12)
  - [ ] Signature: `async def validate_and_size(signal: Signal, portfolio_context: PortfolioContext, trading_range: TradingRange) -> PositionSizing | None`
  - [ ] Use asyncio.Lock to ensure thread-safe access (AC: 6)
  - [ ] Create ValidationPipeline to track all validation steps
  - [ ] Execute validation pipeline in order (AC: 2):
    1. Pattern risk validation
    2. **Phase prerequisite validation (Story 7.9)** ← NEW - includes volume validation
    3. R-multiple validation (uses Signal.stop from pattern detector)
    4. Structural stop validation (validates Signal.stop, may adjust if buffer constraints violated)
    5. Position size calculation (uses validated/adjusted stop from Step 4)
    6. Portfolio heat validation
    7. Campaign risk validation (if campaign_id present)
    8. Correlated risk validation
  - [ ] SHORT-CIRCUIT on first failure (AC: 11): return None immediately if phase validation fails
  - [ ] Short-circuit on any failure: return None with rejection_reason (AC: 4)
  - [ ] If all validations pass: construct PositionSizing object (AC: 5)
  - [ ] Populate PositionSizing with: shares, entry, stop, target, risk_amount, risk_pct, r_multiple, validation_pipeline, phase_validation (explicit field)
  - [ ] Log validation pipeline summary (success or failure)
  - [ ] Return PositionSizing or None

- [ ] Add performance monitoring (AC: 9)
  - [ ] Add timing decorator: `@measure_execution_time` to validate_and_size
  - [ ] Log execution time with structlog
  - [ ] Add warning if validation takes >10ms
  - [ ] Track validation step timings individually
  - [ ] Log performance metrics: total_time, step_times, validation_count

- [ ] Add comprehensive error handling
  - [ ] Wrap each validation step in try/except
  - [ ] Catch Decimal arithmetic errors (division by zero, overflow)
  - [ ] Catch validation errors from individual modules
  - [ ] Log exceptions with full context: signal_id, pattern_type, step, error
  - [ ] Return ValidationResult with is_valid=False and error message
  - [ ] Ensure exceptions don't crash validation pipeline

- [ ] Write unit tests for individual validation steps (AC: 7)
  - [ ] Create test file: `backend/tests/unit/risk_management/test_risk_manager.py`
  - [ ] Test _validate_pattern_risk with all pattern types
  - [ ] Test _validate_r_multiple with passing and failing R-multiples
  - [ ] Test _calculate_position_size with various account sizes
  - [ ] Test _validate_portfolio_heat at limit (10.0%) and over limit
  - [ ] Test _validate_campaign_risk with None campaign_id (skip validation)
  - [ ] Test _validate_correlated_risk with multi-level correlation scenarios
  - [ ] Use pytest fixtures for Signal and PortfolioContext test data

- [ ] Write unit tests for validate_and_size end-to-end (AC: 7)
  - [ ] Test case: All validations pass → returns PositionSizing
  - [ ] Test case: Pattern risk exceeds 2.0% → returns None with rejection
  - [ ] Test case: R-multiple below minimum → returns None with rejection
  - [ ] Test case: Portfolio heat would exceed 10% → returns None with rejection
  - [ ] Test case: Campaign risk would exceed 5% → returns None with rejection
  - [ ] Test case: Correlated risk exceeds 6% (strict mode) → returns None with rejection
  - [ ] Test case: Warning but approval (R below ideal, heat at 9%) → returns PositionSizing with warnings
  - [ ] Verify ValidationPipeline captures all steps
  - [ ] Verify rejection_reason is descriptive and actionable

- [ ] Write integration test for full campaign validation (AC: 8)
  - [ ] Create test: `backend/tests/integration/risk_management/test_full_campaign_validation.py`
  - [ ] Setup: Create TradingRange with PS, SC, AR events in event_history
  - [ ] Setup: Create mock Spring signal (25% campaign allocation, 0.5% risk)
  - [ ] Validate Spring with trading_range → should pass phase validation and position sizing
  - [ ] Add Spring event to trading_range.event_history
  - [ ] Setup: Add Secondary Test event to trading_range.event_history
  - [ ] Setup: Create mock ST signal (20% campaign allocation, 0.6% risk, same campaign_id)
  - [ ] Validate ST with Spring event → should pass (validates Spring)
  - [ ] Verify ST campaign allocation is 20% of 3% total budget = 0.6% risk
  - [ ] Add ST event to trading_range.event_history
  - [ ] Setup: Create mock SOS signal (35% campaign allocation, 1.0% risk, same campaign_id)
  - [ ] Validate SOS with Spring+ST events → should pass phase validation
  - [ ] Add SOS event to trading_range.event_history
  - [ ] Setup: Create mock LPS signal (20% campaign allocation, 0.6% risk, same campaign_id)
  - [ ] Validate LPS with Spring+ST+SOS events → should pass (pullback after breakout)
  - [ ] Verify campaign risk accumulation: 0.5% + 0.6% + 1.0% + 0.6% = 2.7% total
  - [ ] Verify all four signals (Spring, ST, SOS, LPS) created PositionSizing objects
  - [ ] Verify ValidationPipeline for each shows all 8 steps passed including phase validation
  - [ ] Verify each PositionSizing has phase_validation field populated

- [ ] Write integration test for rejection scenarios (AC: 8, 11)
  - [ ] Test: SOS without Secondary Test → rejected at phase validation (short-circuit)
  - [ ] Test: Spring without PS/SC/AR → rejected at phase validation (short-circuit)
  - [ ] Test: Portfolio at 9.5% heat + new 1.0% position → rejected (heat exceeds 10% limit)
  - [ ] Test: Campaign at 4.8% risk + new 0.5% position → rejected (campaign risk 5.3% exceeds 5% limit)
  - [ ] Test: 3 tech stocks at 5.7% correlation + new tech 0.5% → rejected (strict mode, exceeds 6%)
  - [ ] Test: R-multiple 2.3R for SOS (minimum 2.5R) → rejected
  - [ ] Test: Structural stop buffer 11% from entry → rejected (exceeds 10% maximum)
  - [ ] Verify rejection reasons are specific to validation step that failed
  - [ ] Verify ValidationPipeline shows which step failed
  - [ ] Verify phase validation failures short-circuit (R-multiple not calculated)

- [ ] Write performance test (AC: 9)
  - [ ] Create test: `backend/tests/integration/risk_management/test_validation_performance.py`
  - [ ] Generate 100 random signals with varying parameters
  - [ ] Execute validate_and_size for all 100 signals
  - [ ] Measure average execution time per validation
  - [ ] Assert: average time <10ms per signal
  - [ ] Assert: 95th percentile <15ms
  - [ ] Assert: no validation >50ms (catch performance regressions)
  - [ ] Log performance statistics: min, max, mean, median, p95, p99

- [ ] Add JSON serialization support (AC: 10)
  - [ ] Verify PositionSizing.model_dump_json() works correctly
  - [ ] Test Decimal fields serialize as strings
  - [ ] Test ValidationPipeline serializes with all results
  - [ ] Create FastAPI response model example
  - [ ] Verify pydantic-to-typescript generates correct TypeScript interface
  - [ ] Test round-trip: Python → JSON → TypeScript parsing

- [ ] Add structured logging throughout (Architecture requirement)
  - [ ] Log validation pipeline start: signal_id, pattern_type, symbol
  - [ ] Log each validation step: step_name, is_valid, execution_time
  - [ ] Log warnings: step_name, warning_message, values
  - [ ] Log rejection: step_name, rejection_reason, values
  - [ ] Log validation success: signal_id, shares, risk_amount, r_multiple, total_time
  - [ ] Log validation failure: signal_id, failed_step, rejection_reason, total_time
  - [ ] Use structlog with consistent field names across all logs

- [ ] Update RiskManager service.py integration point (AC: 1)
  - [ ] Update `backend/src/risk_management/service.py` to instantiate RiskManager
  - [ ] Expose `validate_and_size` as public API for signal generator
  - [ ] Add singleton pattern or dependency injection for RiskManager instance
  - [ ] Ensure RiskManager initialized once at application startup
  - [ ] Add health check endpoint to verify RiskManager ready

## Dev Notes

### Previous Story Insights

**From Story 7.1 (Pattern-Specific Risk Allocation):**
- Provides `RiskAllocator.get_pattern_risk_pct(pattern_type) -> Decimal`
- Risk percentages: Spring 0.5%, SOS 1.0%, LPS 0.6%, UTAD 0.5%
- User overrides supported within FR18 limits (≤2.0% per trade)
- Configuration loaded from `backend/config/risk_allocation.yaml`

**From Story 7.2 (Position Size Calculation):**
- Provides `calculate_position_size(account_equity, pattern, entry, stop) -> PositionSizing`
- Uses Decimal arithmetic with 8 decimal places
- Formula: shares = (account_equity × risk_pct) / (entry - stop)
- Rounds down to whole shares (never exceeds risk)
- Validates: shares ≥ 1, position_value ≤ 20% account_equity
- Returns PositionSizing dataclass

**From Story 7.3 (Portfolio Heat Tracking):**
- Provides `calculate_portfolio_heat(open_positions) -> Decimal`
- Maximum portfolio heat: 10.0% (FR18)
- Proximity warnings at 8.0% (80% capacity)
- Heat = Σ(position_risk_pct) across all open positions

**From Story 7.4 (Campaign Risk Tracking):**
- Provides `calculate_campaign_risk(campaign_id, open_positions) -> Decimal`
- Maximum campaign risk: 5.0% (FR18)
- Proximity warnings at 4.0% (80% capacity)
- Tracks Spring (25%) + ST (20%) + SOS (35%) + LPS (20%) allocations within campaign
- BMAD allocation revised to reflect Wyckoff phase importance

**From Story 7.5 (Correlated Risk Limits):**
- Provides `validate_correlated_risk(new_position, new_position_risk, open_positions, config) -> tuple[bool, str | None, list[str]]`
- Maximum correlated risk: 6.0% (FR18)
- Multi-level correlation: sector, asset_class, geography
- Enforcement modes: strict (reject), permissive (warn)
- Proximity warnings at 4.8% (80% capacity)

**From Story 7.6 (R-Multiple Validation):**
- Provides `validate_r_multiple(entry, stop, target, pattern_type) -> RMultipleValidation`
- Minimum requirements: Spring 3.0R, SOS 2.5R, LPS 2.5R, UTAD 3.0R (SOS updated from 2.0R)
- Ideal thresholds: Spring 4.0R, SOS 3.5R, LPS 3.5R, UTAD 4.0R
- Maximum thresholds: Spring/UTAD 10.0R, SOS/LPS 8.0R
- Returns is_valid, r_multiple, rejection_reason, warning

**From Story 7.7 (Structural Stop Loss Placement):**
- Provides `calculate_structural_stop(pattern, pattern_data, levels) -> Stop`
- Stop placement rules: Spring 2% below spring_low, SOS 5% below Ice, LPS 3% below Ice, UTAD 2% above UTAD high
- Validates stop buffer is 1-10% from entry (reasonable range)
- Returns structural stop with invalidation reason

**From Story 7.9 (Phase Completion Validation):** ← NEW
- Provides `validate_phase_prerequisites(pattern, trading_range, mode) -> PhaseValidation`
- Spring requires: PS, SC, AR detected in Phase A-B
- SOS requires: Spring + Secondary Test (Phase C complete)
- LPS requires: SOS occurred first (Phase D pullback)
- UTAD requires: Distribution schematic (PSY, BC, AR, LPSY)
- Returns is_valid, missing_prerequisites, sequence_violations
- **CRITICAL**: Must run BEFORE R-multiple validation to prevent false entries

**Key Pattern:** All validation modules follow consistent signature:
```python
def validate_xxx(...) -> ValidationResult | tuple[bool, str | None, list[str]]
```

This story integrates them into a unified pipeline with proper Wyckoff phase validation.

### Data Models

**PortfolioContext Model** [New for this story]

Create in `backend/src/models/portfolio.py`:

```python
from decimal import Decimal
from pydantic import BaseModel, Field
from typing import List
from uuid import UUID

class PortfolioContext(BaseModel):
    """
    Complete portfolio state for risk validation.

    Provides all context needed for RiskManager to validate a new signal.
    """
    account_equity: Decimal = Field(..., decimal_places=2, max_digits=18, description="Current account equity")
    open_positions: List[Position] = Field(default_factory=list, description="All currently open positions")
    active_campaigns: List[Campaign] = Field(default_factory=list, description="All active campaigns")
    sector_mappings: dict[str, SectorMapping] = Field(..., description="Symbol -> sector mapping from config")
    correlation_config: CorrelationConfig = Field(..., description="Correlation risk configuration")

    class Config:
        json_encoders = {Decimal: str}
```

**ValidationResult Model** [New for this story]

Create in `backend/src/models/validation.py`:

```python
from decimal import Decimal
from pydantic import BaseModel, Field
from typing import List

class ValidationResult(BaseModel):
    """Result of a single validation step in the risk pipeline."""
    is_valid: bool = Field(..., description="Whether validation passed")
    validation_step: str = Field(..., description="Name of validation step")
    rejection_reason: str | None = Field(default=None, description="Reason for rejection if failed")
    warnings: List[str] = Field(default_factory=list, description="Warning messages (non-blocking)")
    execution_time_ms: float | None = Field(default=None, description="Step execution time")

    class Config:
        json_encoders = {Decimal: str}

class ValidationPipeline(BaseModel):
    """Complete validation pipeline execution history."""
    results: List[ValidationResult] = Field(default_factory=list)
    is_valid: bool = Field(default=True, description="Overall validation status")
    rejection_reason: str | None = Field(default=None, description="First rejection reason")

    def add_result(self, result: ValidationResult) -> None:
        """Add validation result and update overall status."""
        self.results.append(result)
        if not result.is_valid:
            self.is_valid = False
            if self.rejection_reason is None:
                self.rejection_reason = f"{result.validation_step}: {result.rejection_reason}"

    def get_first_failure(self) -> ValidationResult | None:
        """Get first failed validation step."""
        for result in self.results:
            if not result.is_valid:
                return result
        return None

    @property
    def all_warnings(self) -> List[str]:
        """Aggregate all warnings from all steps."""
        warnings = []
        for result in self.results:
            warnings.extend(result.warnings)
        return warnings

    class Config:
        json_encoders = {Decimal: str}
```

**Updated PositionSizing Model** [From Story 7.2, enhanced]

Update `backend/src/models/position_sizing.py`:

```python
from decimal import Decimal
from pydantic import BaseModel, Field

class PositionSizing(BaseModel):
    """Position sizing calculation result with full validation history."""
    # Core position data
    shares: int = Field(..., ge=1, description="Number of shares")
    entry: Decimal = Field(..., decimal_places=8, max_digits=18)
    stop: Decimal = Field(..., decimal_places=8, max_digits=18)
    target: Decimal = Field(..., decimal_places=8, max_digits=18)

    # Risk calculations
    risk_amount: Decimal = Field(..., decimal_places=2, max_digits=12, description="Dollar amount at risk")
    risk_pct: Decimal = Field(..., decimal_places=4, max_digits=10, description="Percentage of account at risk")
    actual_risk: Decimal = Field(..., decimal_places=2, max_digits=12, description="Actual dollar risk")

    # R-multiple
    r_multiple: Decimal = Field(..., decimal_places=2, max_digits=6, description="Risk-reward ratio")

    # Portfolio projections
    portfolio_heat_after: Decimal = Field(..., decimal_places=4, max_digits=6, description="Projected portfolio heat after position")
    campaign_risk_after: Decimal | None = Field(default=None, decimal_places=4, max_digits=6, description="Projected campaign risk after position")
    correlated_risks: dict[str, Decimal] = Field(default_factory=dict, description="Correlation risks by type")

    # Validation metadata
    validation_pipeline: ValidationPipeline = Field(..., description="Full validation execution history")
    phase_validation: PhaseValidation | None = Field(default=None, description="Wyckoff phase prerequisite validation result (Story 7.9)")
    pattern_type: str = Field(..., max_length=10)
    account_equity: Decimal = Field(..., decimal_places=2, max_digits=18)
    position_value: Decimal = Field(..., decimal_places=2, max_digits=18, description="Total position cost")

    class Config:
        json_encoders = {Decimal: str}
```

### File Locations

**Project Structure Reference** [Source: architecture/10-unified-project-structure.md]

Create/modify these files:
```
backend/src/
├── models/
│   ├── portfolio.py                 # MODIFY: Add PortfolioContext
│   ├── position_sizing.py           # MODIFY: Enhance with validation_pipeline
│   └── validation.py                # NEW: ValidationResult, ValidationPipeline
├── risk_management/
│   ├── risk_manager.py              # NEW: RiskManager class
│   └── service.py                   # MODIFY: Export RiskManager
└── api/routes/
    └── risk.py                      # NEW: Risk validation endpoint (optional)
```

Test files:
```
backend/tests/
├── unit/risk_management/
│   └── test_risk_manager.py         # NEW: Unit tests for validation steps
└── integration/risk_management/
    ├── test_full_campaign_validation.py  # NEW: Campaign integration test
    ├── test_rejection_scenarios.py       # NEW: Rejection testing
    └── test_validation_performance.py    # NEW: Performance benchmarks
```

### API Specifications

**No New Public Endpoints Required** [Source: architecture/5-api-specification.md]

RiskManager is an internal service used by Signal Generator. However, validation results are exposed via existing Signal endpoints:

**GET /api/v1/signals/{signal_id}**

Enhanced response includes validation details:
```json
{
  "id": "uuid",
  "symbol": "AAPL",
  "pattern_type": "SPRING",
  "entry": "100.00",
  "stop": "95.00",
  "target": "120.00",
  "shares": 100,
  "risk_amount": "500.00",
  "risk_pct": "0.5",
  "r_multiple": "4.00",
  "portfolio_heat_after": "9.2",
  "campaign_risk_after": "2.1",
  "correlated_risks": {
    "sector_Technology": "4.5",
    "asset_class_stock": "8.5",
    "geography_US": "9.0"
  },
  "validation_pipeline": {
    "is_valid": true,
    "rejection_reason": null,
    "results": [
      {"validation_step": "pattern_risk", "is_valid": true, "execution_time_ms": 0.2},
      {"validation_step": "r_multiple", "is_valid": true, "warnings": ["Below ideal 4.0R"], "execution_time_ms": 0.5},
      {"validation_step": "position_size", "is_valid": true, "execution_time_ms": 0.3},
      {"validation_step": "portfolio_heat", "is_valid": true, "execution_time_ms": 1.2},
      {"validation_step": "campaign_risk", "is_valid": true, "execution_time_ms": 0.8},
      {"validation_step": "correlated_risk", "is_valid": true, "execution_time_ms": 1.5}
    ]
  }
}
```

**Internal Error Response** (when validation rejects signal)

Logged to audit trail, not returned to user API:
```json
{
  "event_type": "SIGNAL_REJECTED",
  "entity_id": "signal_uuid",
  "rejection_reason": "PORTFOLIO_HEAT_LIMIT_EXCEEDED",
  "details": {
    "validation_step": "portfolio_heat",
    "current_heat": "9.5",
    "new_position_risk": "1.0",
    "projected_heat": "10.5",
    "limit": "10.0"
  }
}
```

### Integration Notes

**Signal Generation Workflow Integration** [Source: architecture/8-core-workflows.md]

RiskManager integrates into signal generation approval chain:

```
Pattern Detected → Signal Generator → RiskManager.validate_and_size():
  Step 1: Pattern Risk Validation (Story 7.1)
  Step 2: Phase Prerequisite Validation (Story 7.9) ← NEW - SHORT-CIRCUITS IF FAILS
  Step 3: R-Multiple Validation (Story 7.6)
  Step 4: Structural Stop Calculation (Story 7.7)
  Step 5: Position Size Calculation (Story 7.2)
  Step 6: Portfolio Heat Validation (Story 7.3)
  Step 7: Campaign Risk Validation (Story 7.4)
  Step 8: Correlated Risk Validation (Story 7.5)
  → If ALL pass: Return PositionSizing
  → If ANY fails: Return None with rejection_reason
```

**Signal Generator Modification** [Source: architecture/10-unified-project-structure.md]

In `backend/src/signal_generator/generator.py`:

```python
from risk_management.risk_manager import RiskManager
from models.portfolio import PortfolioContext

class SignalGenerator:
    def __init__(self):
        self.risk_manager = RiskManager()
        # ... other dependencies

    async def generate_signal(self, pattern: Pattern) -> Signal | None:
        # 1. Fetch portfolio context
        portfolio_context = await self._build_portfolio_context()

        # 2. Create preliminary signal from pattern
        signal = Signal(
            pattern_id=pattern.id,
            symbol=pattern.symbol,
            pattern_type=pattern.pattern_type,
            entry=pattern.entry_price,
            stop=pattern.stop_loss,
            target=pattern.target_price,
            # ... other fields
        )

        # 3. Validate and calculate position size
        position_sizing = await self.risk_manager.validate_and_size(
            signal=signal,
            portfolio_context=portfolio_context
        )

        if position_sizing is None:
            # Validation failed - log and reject signal
            logger.error("signal_rejected_risk_validation",
                         pattern_id=pattern.id,
                         symbol=pattern.symbol,
                         rejection_reason=position_sizing.validation_pipeline.rejection_reason)
            return None

        # 4. Populate signal with validated position sizing
        signal.shares = position_sizing.shares
        signal.risk_amount = position_sizing.risk_amount
        signal.risk_pct = position_sizing.risk_pct
        signal.r_multiple = position_sizing.r_multiple

        # 5. Log validation warnings if any
        if position_sizing.validation_pipeline.all_warnings:
            logger.warning("signal_approved_with_warnings",
                           signal_id=signal.id,
                           warnings=position_sizing.validation_pipeline.all_warnings)

        # 6. Persist signal and return
        await self.signal_repository.save(signal)
        return signal
```

### Testing Requirements

**Testing Framework** [Source: architecture/12-testing-strategy.md]
- Backend testing: pytest (8.0+)
- Unit tests: `backend/tests/unit/risk_management/test_risk_manager.py`
- Integration tests: `backend/tests/integration/risk_management/`
- Use pytest fixtures for Signal, PortfolioContext, Position test data
- Parametrized tests for multiple validation scenarios

**Test Coverage Requirements** [Source: architecture/12-testing-strategy.md#Backend-Testing]
- Unit test each validation step method independently
- Unit test validate_and_size with all pass/fail combinations
- Integration test full campaign validation (Spring → SOS → LPS)
- Integration test all rejection scenarios
- Performance test: 100 validations <10ms average

**Mock Data Strategy**

Create pytest fixtures:

```python
import pytest
from decimal import Decimal

@pytest.fixture
def portfolio_context():
    """Standard portfolio context for testing."""
    return PortfolioContext(
        account_equity=Decimal("100000.00"),
        open_positions=[],
        active_campaigns=[],
        sector_mappings=load_test_sector_mappings(),
        correlation_config=CorrelationConfig(
            max_correlated_risk=Decimal("6.0"),
            enforcement_mode="strict",
            sector_mappings={}
        )
    )

@pytest.fixture
def spring_signal():
    """Spring signal for testing."""
    return Signal(
        symbol="AAPL",
        pattern_type="SPRING",
        entry=Decimal("100.00"),
        stop=Decimal("95.00"),
        target=Decimal("120.00")
    )

@pytest.fixture
def risk_manager():
    """RiskManager instance for testing."""
    return RiskManager()
```

### Technical Constraints

**Thread Safety** (AC: 6) [Source: architecture/3-tech-stack.md - FastAPI async]
- FastAPI handles concurrent requests asynchronously
- RiskManager must be thread-safe for concurrent validate_and_size calls
- Use `asyncio.Lock()` to protect shared state (if any)
- Each validation should be stateless (no shared mutable state)

**Performance Requirements** (AC: 9)
- Target: <10ms per validate_and_size call
- Breakdown estimation:
  - Pattern risk validation: <0.5ms
  - R-multiple validation: <0.5ms
  - Position size calculation: <1ms
  - Portfolio heat calculation: <2ms (iterate positions)
  - Campaign risk calculation: <2ms
  - Correlated risk validation: <3ms (multi-level correlation)
  - Total: ~9ms (within budget)

**Optimization Strategies:**
- Use Decimal sparingly (only for financial calculations)
- Cache sector mappings (don't reload on each validation)
- Use list comprehensions instead of loops where possible
- Avoid unnecessary object creation
- Short-circuit on first failure (don't continue pipeline)

**Decimal Precision** [Source: architecture/15-coding-standards.md#Critical-Fullstack-Rules]
- MUST use Python `Decimal` type for all risk calculations
- NEVER use `float` for prices or percentages
- Use 8 decimal places for intermediate calculations
- Use 2 decimal places for final display values

### Logging and Observability

**Structured Logging** [Source: architecture/3-tech-stack.md - structlog 24.1+]

Log validation pipeline events:

```python
import structlog
logger = structlog.get_logger()

# Pipeline start
logger.info("validation_pipeline_start",
            signal_id=str(signal.id),
            symbol=signal.symbol,
            pattern_type=signal.pattern_type,
            entry=str(signal.entry),
            stop=str(signal.stop),
            target=str(signal.target))

# Step completion
logger.debug("validation_step_complete",
             step="pattern_risk",
             is_valid=True,
             execution_time_ms=0.2)

# Warning (non-blocking)
logger.warning("validation_warning",
               step="r_multiple",
               warning="R-multiple 3.5 below ideal 4.0 for SPRING",
               r_multiple=str(r_multiple),
               ideal_r=str(ideal_r))

# Rejection (blocking)
logger.error("validation_rejected",
             step="portfolio_heat",
             rejection_reason="Portfolio heat would exceed 10% limit",
             current_heat=str(current_heat),
             new_position_risk=str(new_risk),
             projected_heat=str(projected_heat),
             limit="10.0")

# Pipeline success
logger.info("validation_pipeline_success",
            signal_id=str(signal.id),
            shares=position_sizing.shares,
            risk_amount=str(position_sizing.risk_amount),
            r_multiple=str(position_sizing.r_multiple),
            portfolio_heat_after=str(position_sizing.portfolio_heat_after),
            total_execution_time_ms=total_time,
            warnings_count=len(position_sizing.validation_pipeline.all_warnings))

# Pipeline failure
logger.error("validation_pipeline_failure",
             signal_id=str(signal.id),
             failed_step=first_failure.validation_step,
             rejection_reason=first_failure.rejection_reason,
             total_execution_time_ms=total_time)
```

### Validation Pipeline Execution Order

**Order Rationale (Updated with Phase Validation):**

1. **Pattern Risk** (fastest, ~0.2ms): Simple lookup, fail fast if risk allocation invalid
2. **Phase Prerequisites** (fast, ~0.5ms): Validate Wyckoff schematic sequence - CRITICAL SHORT-CIRCUIT POINT
3. **R-Multiple** (fast, ~0.5ms): Simple calculation, fail before expensive position sizing
4. **Structural Stop** (fast, ~0.3ms): Calculate and validate stop placement
5. **Position Size** (medium, ~1ms): Calculate shares only if prior validations pass
6. **Portfolio Heat** (medium, ~2ms): Check portfolio-level constraint
7. **Campaign Risk** (medium, ~2ms): Check campaign-level constraint (includes BMAD allocation)
8. **Correlated Risk** (slowest, ~3ms): Most complex validation, run last

**Total Expected Time: ~9.7ms** (within 10ms budget per AC 9)

**Short-Circuit Logic:**
- **Phase validation failure = immediate rejection** (don't calculate R-multiple for invalid phase sequence)
- Stop pipeline on first rejection (don't waste time on subsequent validations)
- Accumulate all warnings (don't stop on warnings)
- Log partial pipeline results for debugging

**Why Phase Validation is Step 2:**
- Must happen BEFORE R-multiple to prevent wasted computation
- SOS without Secondary Test should be rejected before any math
- Spring without PS/SC/AR is invalid regardless of R-multiple
- Early rejection prevents ~40% of false signals (per Wyckoff analysis)

### Dependencies

**Python Libraries** [Source: architecture/3-tech-stack.md]
- Python 3.11+ (async/await support)
- FastAPI 0.109+ (async web framework)
- Pydantic 2.5+ (data validation)
- pytest 8.0+ (testing)
- structlog 24.1+ (logging)
- asyncio (built-in for async locks)

**Internal Dependencies**
- Story 7.1: RiskAllocator (pattern risk percentages)
- Story 7.2: calculate_position_size (position sizing)
- Story 7.3: calculate_portfolio_heat (portfolio heat validation)
- Story 7.4: calculate_campaign_risk (campaign risk validation with updated BMAD allocation)
- Story 7.5: validate_correlated_risk (correlation validation)
- Story 7.6: validate_r_multiple (R-multiple validation with updated SOS threshold)
- Story 7.7: calculate_structural_stop (structural stop placement)
- **Story 7.9: validate_phase_prerequisites (Wyckoff phase validation)** ← NEW

**Related Stories**
- Story 8.1: Signal Generator integration (uses RiskManager.validate_and_size)
- Story 8.2: Approval Chain (RiskManager is one step in approval chain)

### Risk Mitigation Notes

**Why RiskManager Integration Matters** [Source: Epic 7 PRD]
- Centralizes all risk validation logic in one place
- Ensures consistent validation order across all signals
- Provides complete audit trail of validation decisions
- Prevents validation steps from being skipped or bypassed
- Makes testing easier (single entry point for all risk logic)

**Common Integration Pitfalls:**
1. **Inconsistent validation order**: Fixed by enforcing pipeline sequence
2. **Missing validation steps**: Prevented by required ValidationPipeline
3. **Race conditions**: Mitigated by asyncio.Lock and stateless validations
4. **Performance degradation**: Monitored via execution time logging
5. **Silent failures**: All rejections logged with full context

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-19 | 1.2 | **Wyckoff Team Review Enhancements**: (1) Added explicit `phase_validation: PhaseValidation` field to PositionSizing model (AC 3) for audit trail. (2) Documented volume validation is implicit in phase prerequisites (AC 2). (3) Clarified Signal.stop source: preliminary stop from pattern detector, validated/adjusted in Step 4 (AC 12). (4) Added ST signal to full campaign integration test with 20% allocation verification. (5) Added campaign rejection test case (4.8% + 0.5% = 5.3% exceeds 5% limit). (6) Added structural stop buffer rejection test (>10% buffer). (7) Updated validation pipeline description with stop flow: R-multiple uses Signal.stop, Step 4 validates/adjusts, position sizing uses validated stop. Addresses Wyckoff team recommendations from Story 7.8 review (grade: 9.5/10 → 9.8/10 after fixes). | William (Wyckoff Mentor) |
| 2025-10-19 | 1.1 | **Wyckoff Enhancement**: Integrated Story 7.9 (Phase Completion Validation) into validation pipeline as Step 2 (before R-multiple). Added short-circuit logic for phase failures. Updated AC 2, 3, 8, 9, 11. Added trading_range parameter to validate_and_size. Updated BMAD allocations (25/20/35/20), SOS R-multiple (2.5R), campaign sequence (Spring→ST→SOS→LPS). Added structural stop calculation as Step 4. Updated all test cases, dependency list, pipeline diagrams, and performance estimates (9.7ms total). | Wayne (Wyckoff Analyst) |
| 2025-10-19 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

## QA Results

### Review Date: 2025-12-16

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Status: NOT IMPLEMENTED**

**Story Status**: Draft

This story has not been implemented yet. The story file is comprehensive and well-documented, but no code has been written. The story requires:

1. Creation of RiskManager class as the unified validation orchestrator
2. Integration of all risk validation modules from Stories 7.1-7.7 and 7.9
3. Implementation of 8-step validation pipeline with proper short-circuit logic
4. Creation of PortfolioContext and ValidationResult data models
5. Performance optimization to meet <10ms validation requirement
6. Comprehensive test coverage (unit + integration + performance tests)

### Implementation Readiness Assessment

**Prerequisites Status**:

- Story 7.1 (Pattern-Specific Risk Allocation): ✓ COMPLETE
- Story 7.2 (Position Size Calculation): ✓ COMPLETE
- Story 7.3 (Portfolio Heat Tracking): ✓ COMPLETE
- Story 7.4 (Campaign Risk Tracking): ✓ COMPLETE
- Story 7.5 (Correlated Risk Limits): ✓ COMPLETE
- Story 7.6 (R-Multiple Validation): ✓ COMPLETE
- Story 7.7 (Structural Stop Loss Placement): ✓ COMPLETE
- **Story 7.9 (Phase Completion Validation): ✓ COMPLETE**

**All Dependencies Met** - Story 7.8 can now be implemented.

### Story Quality Assessment

Despite not being implemented, the story documentation itself is excellent:

**Strengths**:

1. **Clear Integration Architecture**: Well-defined 8-step validation pipeline with proper ordering rationale
2. **Comprehensive AC Coverage**: 15 acceptance criteria covering all aspects of integration
3. **Detailed Dev Notes**: Extensive technical guidance for implementation including data models, workflow diagrams, and integration points
4. **Performance Requirements**: Clear <10ms budget with breakdown by validation step
5. **Wyckoff Integration**: Story 7.9 properly integrated as Step 2 with short-circuit logic
6. **Test Strategy**: Detailed test requirements including unit, integration, and performance test specifications

**Story Documentation Grade: 9.0/10**

### Recommended Implementation Approach

When implementing Story 7.8, the developer should:

1. **Start with Data Models** (AC 1, 3):
   - Create PortfolioContext model in `backend/src/models/portfolio.py`
   - Create ValidationResult and ValidationPipeline models in `backend/src/models/validation.py`
   - Enhance PositionSizing model with validation_pipeline field

2. **Build RiskManager Skeleton** (AC 1, 6):
   - Create `backend/src/risk_management/risk_manager.py`
   - Initialize all validation module dependencies (Stories 7.1-7.7, 7.9)
   - Add asyncio.Lock for thread safety

3. **Implement Validation Steps** (AC 2, 11, 12):
   - Step 1: Pattern risk validation
   - Step 2: Phase prerequisite validation (Story 7.9) ← CRITICAL SHORT-CIRCUIT POINT
   - Step 3: R-multiple validation (uses Signal.stop from detector)
   - Step 4: Structural stop validation (validates/adjusts Signal.stop)
   - Step 5: Position size calculation (uses validated stop from Step 4)
   - Step 6: Portfolio heat validation
   - Step 7: Campaign risk validation
   - Step 8: Correlated risk validation

4. **Add Performance Monitoring** (AC 9):
   - Timing decorator for validate_and_size method
   - Step-by-step timing instrumentation
   - Warning if validation >10ms

5. **Write Tests** (AC 7, 8, 9):
   - Unit tests for each validation step
   - Integration test for full campaign (Spring → ST → SOS → LPS)
   - Rejection scenario tests
   - Performance benchmark test (100 signals <10ms average)

### Critical Implementation Notes

**Short-Circuit Logic** (AC 11):
Phase validation MUST occur at Step 2 (before R-multiple) and MUST short-circuit on failure. This prevents wasted computation on invalid Wyckoff patterns (SOS without Secondary Test, Spring without PS/SC/AR).

**Signal.stop Source** (AC 12):
The Signal object contains a preliminary stop from the pattern detector (Story 7.7). Step 4 validates this stop and may adjust it if buffer constraints are violated. Position sizing (Step 5) uses the validated/adjusted stop from Step 4.

**Performance Budget** (AC 9):
With all dependencies implemented, the total validation time should be approximately:

- Step 1 (Pattern risk): ~0.2ms
- Step 2 (Phase validation): ~0.5ms
- Step 3 (R-multiple): ~0.5ms
- Step 4 (Structural stop): ~0.3ms
- Step 5 (Position size): ~1.0ms
- Step 6 (Portfolio heat): ~2.0ms
- Step 7 (Campaign risk): ~2.0ms
- Step 8 (Correlated risk): ~3.0ms

**Total: ~9.5ms** (within 10ms budget)

### Gate Status

Gate: **NOT APPLICABLE** (Story not implemented)

No gate file created until implementation is complete.

### Recommended Status

**Implementation Required**

Story 7.8 should be assigned to a developer for implementation now that all prerequisite stories (7.1-7.7, 7.9) are complete. The story documentation is excellent and provides clear implementation guidance.

**Priority**: HIGH - This is the integration story that brings together all risk management validation into a unified API. Signal generation (Epic 8) depends on this story.

### Blocking Conditions

None. All dependencies are met. Ready for development assignment.
