# Story 7.2: Position Size Calculation with Fixed-Point Arithmetic

## Status
Ready for Review

## Story
**As a** risk manager,
**I want** to calculate position sizes using fixed-point arithmetic to prevent rounding errors,
**so that** risk limits are never violated due to floating point precision issues (NFR20).

## Acceptance Criteria
1. Use Python Decimal type with 8 decimal places for all calculations
2. Function: `calculate_position_size(account_equity, pattern, entry, stop) -> int` returns share count
3. Formula: shares = (account_equity × risk_pct) / (entry - stop)
4. Round down to whole shares (never round up, which would exceed risk)
5. Minimum position: 1 share (reject if calculation results in <1)
6. Maximum position value: 20% of account equity (FR18 implied constraint)
7. Validation: actual risk = shares × (entry - stop) must be ≤ intended risk
8. Unit test: synthetic values validate no floating point errors
9. Integration test: 1000 random calculations never exceed risk limits
10. Logging: debug log actual vs intended risk percentage

## Tasks / Subtasks

- [x] Create PositionSizing data model in backend/src/models/ (AC: 1, 2, 7)
  - [x] Define PositionSizing Pydantic model with Decimal types for all financial fields
  - [x] Include fields: shares (int), entry (Decimal), stop (Decimal), risk_amount (Decimal), risk_pct (Decimal), account_equity (Decimal)
  - [x] Add validation: actual_risk ≤ intended_risk
  - [x] Use Decimal with 8 decimal places precision (decimal_places=8, max_digits=18)
  - [x] Add Config for JSON encoding of Decimal as string

- [x] Implement calculate_position_size function in backend/src/risk_management/position_calculator.py (AC: 1, 2, 3, 4, 5, 6, 7)
  - [x] Import Decimal from decimal module and set context precision to 8 places
  - [x] Accept parameters: account_equity (Decimal), pattern_type (str), entry (Decimal), stop (Decimal)
  - [x] Retrieve pattern risk percentage using get_pattern_risk_pct(pattern_type) from Story 7.1
  - [x] Calculate dollar risk: account_equity × (risk_pct / 100) using Decimal arithmetic
  - [x] Calculate stop distance: abs(entry - stop) using Decimal arithmetic
  - [x] Calculate raw shares: dollar_risk / stop_distance
  - [x] Round down to whole shares using Decimal quantize with ROUND_DOWN
  - [x] Validate minimum position: return None if shares < 1 (AC: 5)
  - [x] Calculate position value: shares × entry
  - [x] Validate maximum position value ≤ 20% account equity (AC: 6)
  - [x] Calculate actual risk: shares × stop_distance
  - [x] Validate actual risk ≤ intended dollar_risk (AC: 7)
  - [x] Return PositionSizing object with all calculated values
  - [x] Add error handling for division by zero (entry == stop)
  - [x] Add debug logging for actual vs intended risk percentage (AC: 10)

- [x] Add unit tests in backend/tests/unit/test_position_calculator.py (AC: 8)
  - [x] Test fixture: synthetic account_equity, entry, stop values that could expose floating point errors
  - [x] Test case: verify Decimal precision prevents floating point errors
  - [x] Test case: verify round down behavior (shares should never round up)
  - [x] Test case: minimum position validation (< 1 share rejected)
  - [x] Test case: maximum position value validation (> 20% equity rejected)
  - [x] Test case: actual risk never exceeds intended risk
  - [x] Test case: edge case where entry == stop (division by zero)
  - [x] Test case: each pattern type (Spring, SOS, LPS, UTAD) calculates correctly
  - [x] Test case: very small stop distances don't cause oversized positions

- [x] Add integration tests in backend/tests/integration/test_risk_management.py (AC: 9)
  - [x] Generate 1000 random position calculations with varying account sizes, entries, stops
  - [x] Use pytest parametrize or factory-boy for randomized test data
  - [x] Assert: actual_risk ≤ intended_risk for ALL 1000 calculations
  - [x] Assert: position_value ≤ 20% account_equity for ALL calculations
  - [x] Assert: shares are always whole integers (no fractional shares)
  - [x] Assert: no floating point precision errors using Decimal comparison
  - [x] Log any failures with full calculation details for debugging

- [x] Update risk_management module structure (Project Structure Alignment)
  - [x] Ensure backend/src/risk_management/ directory exists
  - [x] Create position_calculator.py in risk_management module
  - [x] Create __init__.py to export calculate_position_size function
  - [x] Verify imports align with project structure standards

## Dev Notes

### Previous Story Insights
This is the first story in Epic 7 (Risk Management). Story 7.1 (Pattern-Specific Risk Allocation) should be implemented first, as this story depends on `get_pattern_risk_pct(pattern_type)` function from Story 7.1 to retrieve the risk percentage per pattern.

### Data Models

**PositionSizing Model** (to be created in `backend/src/models/position_sizing.py`):
[Source: docs/architecture/4-data-models.md#OHLCVBar - following same Decimal pattern]

```python
from decimal import Decimal
from pydantic import BaseModel, Field, validator

class PositionSizing(BaseModel):
    """Position sizing calculation result with fixed-point arithmetic"""
    shares: int = Field(..., ge=1, description="Number of shares to purchase")
    entry: Decimal = Field(..., decimal_places=8, max_digits=18)
    stop: Decimal = Field(..., decimal_places=8, max_digits=18)
    target: Decimal = Field(..., decimal_places=8, max_digits=18)  # Optional for this story
    risk_amount: Decimal = Field(..., decimal_places=2, max_digits=12, description="Dollar amount at risk")
    risk_pct: Decimal = Field(..., decimal_places=4, max_digits=10, description="Percentage of account at risk")
    account_equity: Decimal = Field(..., decimal_places=2, max_digits=18)
    position_value: Decimal = Field(..., decimal_places=2, max_digits=18, description="Total position cost")
    actual_risk: Decimal = Field(..., decimal_places=2, max_digits=12, description="Actual dollar risk based on shares")
    pattern_type: str = Field(..., max_length=10)

    @validator('actual_risk')
    def validate_actual_risk(cls, v, values):
        """Ensure actual risk never exceeds intended risk"""
        if 'risk_amount' in values and v > values['risk_amount']:
            raise ValueError(f"Actual risk {v} exceeds intended risk {values['risk_amount']}")
        return v

    @validator('position_value')
    def validate_position_value(cls, v, values):
        """Ensure position value ≤ 20% of account equity (FR18)"""
        if 'account_equity' in values:
            max_position = values['account_equity'] * Decimal('0.20')
            if v > max_position:
                raise ValueError(f"Position value {v} exceeds 20% of account equity")
        return v

    class Config:
        json_encoders = {
            Decimal: str  # Serialize Decimal as string to preserve precision
        }
```

**Reference to Pattern Model**:
[Source: docs/architecture/4-data-models.md#Pattern]
- Pattern model has `entry_price` (Decimal), `stop_loss` (Decimal) fields
- This story will use pattern data to extract entry/stop for calculations

**Reference to Signal Model**:
[Source: docs/architecture/9-database-schema.md#Signals table, lines 74-96]
- Signals table has `position_size NUMERIC(18,8) NOT NULL` field
- This story's output will populate the position_size field when signals are generated

### API Specifications
No direct API endpoints for this story. The `calculate_position_size` function will be used internally by the RiskManager module (Story 7.8) and signal generation logic.

### File Locations
[Source: docs/architecture/10-unified-project-structure.md#Backend Structure, lines 52-54]

- **New file**: `backend/src/risk_management/position_calculator.py` - Core position sizing calculation function
- **New file**: `backend/src/models/position_sizing.py` - PositionSizing Pydantic model
- **Test file**: `backend/tests/unit/test_position_calculator.py` - Unit tests
- **Test file**: `backend/tests/integration/test_risk_management.py` - Integration tests with randomized data

### Technical Constraints

**Decimal Precision** (CRITICAL):
[Source: docs/architecture/15-coding-standards.md#Critical Fullstack Rules, lines 17-19]
- ✅ **DO**: Use `Decimal` (Python) for financial calculations
- ❌ **DON'T**: Use `float` for prices

**Decimal Implementation Details**:
[Source: docs/architecture/4-data-models.md#OHLCVBar Pydantic Model, lines 25-56]
- Import: `from decimal import Decimal`
- Field definition: `Field(..., decimal_places=8, max_digits=18)` for prices
- Field definition: `Field(..., decimal_places=2, max_digits=12)` for dollar amounts
- Validator: Use Decimal arithmetic for all operations (no float conversion)
- JSON encoding: `Decimal: str` to preserve precision in API responses

**Rounding Behavior**:
- Must use `ROUND_DOWN` when converting shares to integer (AC: 4)
- Python Decimal: Use `quantize(Decimal('1'), rounding=ROUND_DOWN)` method
- Rationale: Rounding up could exceed risk limits, which violates FR18

**Database Precision**:
[Source: docs/architecture/9-database-schema.md#Signals table, line 85]
- `position_size NUMERIC(18,8) NOT NULL` - Database stores position size with 8 decimal precision
- Although shares are integers, DB schema allows fractional shares for flexibility

**Python Version**:
[Source: docs/architecture/3-tech-stack.md#Backend Language, line 16]
- Python 3.11+ required for improved Decimal performance and typing support

**Pattern Risk Percentages** (from Story 7.1 dependency):
[Source: docs/prd/epic-7-risk-management-position-sizing.md#Story 7.1, AC 1]
- Spring: 0.5%, SOS: 1.0%, LPS: 0.6%, UTAD: 0.5%
- Maximum per-trade risk: 2.0% (FR18)
- This story will call `get_pattern_risk_pct(pattern_type)` to retrieve these values

**Risk Limit Constraints** (FR18):
[Source: docs/prd/epic-7-risk-management-position-sizing.md#Story 7.2, AC 6]
- Maximum position value: 20% of account equity
- This prevents over-concentration in a single position

### Testing

[Source: docs/architecture/12-testing-strategy.md#Backend Testing]

**Test File Locations**:
- Unit tests: `backend/tests/unit/test_position_calculator.py`
- Integration tests: `backend/tests/integration/test_risk_management.py`

**Testing Framework**:
[Source: docs/architecture/3-tech-stack.md#Backend Testing, line 29]
- pytest 8.0+ with async test support
- pytest-mock for mocking get_pattern_risk_pct dependency
- factory-boy for generating randomized test data (AC: 9)

**Unit Test Requirements** (AC: 8):
- Use synthetic test values that could expose floating point errors
- Example: account_equity=10000.33, entry=123.456789, stop=120.123456
- Verify Decimal calculations maintain precision throughout
- Test all pattern types (Spring, SOS, LPS, UTAD)
- Test edge cases: very small stops, very large positions, minimum shares

**Integration Test Requirements** (AC: 9):
- Generate 1000 random calculations using pytest.mark.parametrize or factory-boy
- Random ranges: account_equity (1000-1000000), entry (1.0-5000.0), stop (entry * 0.90 to entry * 0.99)
- Assert NO failures across all 1000 runs
- Performance: All 1000 calculations should complete in <1 second

**Test Standards**:
- Test file naming: `test_<module_name>.py`
- Test function naming: `test_<function_name>_<scenario>`
- Use pytest fixtures for reusable test data
- Use parametrize for multiple test cases
- Assert actual behavior matches expected with clear error messages

**Logging Validation** (AC: 10):
- Verify debug logs contain: pattern_type, intended_risk_pct, actual_risk_pct, shares, entry, stop
- Use structlog for structured logging (project standard)

### Dependencies
**Story 7.1 (Pattern-Specific Risk Allocation)** - MUST be implemented first
- Provides: `get_pattern_risk_pct(pattern_type) -> float` function
- Located in: `backend/src/risk_management/service.py` (assumed location)
- This story cannot be completed without Story 7.1's function

### Security Considerations
No specific guidance found in architecture docs for position sizing security. Standard input validation via Pydantic models is sufficient.

### Performance Considerations
- Decimal arithmetic is slower than float, but negligible for single calculations
- Target: <1ms per position size calculation (sufficient for signal generation)
- Integration test should validate 1000 calculations complete in <1 second

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
None

### Completion Notes List
- Successfully implemented fixed-point position sizing with Decimal arithmetic (AC 1, NFR20)
- All acceptance criteria met and validated through comprehensive testing
- 20 unit tests covering all edge cases and validations (AC 8)
- 10 integration tests including 1000-iteration stress test (AC 9)
- All 30 tests passing with ZERO failures
- Fixed config path issue for test environment compatibility
- Pydantic model validators ensure risk limits never violated (AC 6, AC 7)
- ROUND_DOWN behavior prevents risk limit overflow (AC 4)
- Proper exception handling for edge cases (entry == stop, < 1 share, > 20% position)
- Debug logging includes actual vs intended risk percentages (AC 10)

### File List
**New Files Created:**
- `backend/src/models/position_sizing.py` - PositionSizing Pydantic model with Decimal validation
- `backend/src/risk_management/position_calculator.py` - Core position sizing calculation function
- `backend/tests/unit/test_position_calculator.py` - 20 unit tests covering all AC requirements
- `backend/tests/integration/risk_management/test_position_calculator_integration.py` - 10 integration tests with 1000-iteration stress testing

**Modified Files:**
- `backend/src/risk_management/__init__.py` - Added calculate_position_size export
- `backend/src/models/__init__.py` - Added PositionSizing export
- `backend/src/config.py` - Updated risk_allocation_config_path to "config/risk_allocation.yaml" (relative to backend/)

## QA Results
(To be populated by QA agent)
