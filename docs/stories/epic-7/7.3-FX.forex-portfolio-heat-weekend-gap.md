# Story 7.3-FX: Forex Portfolio Heat with Weekend Gap Risk

## Status
Done
**Ready for Review**

**Priority:** ðŸ”´ CRITICAL
**Estimate:** 7 story points (enhanced with Wyckoff pattern/phase/volatility awareness)
**Dependencies:** Story 7.2-FX (Forex Position Sizing), Story 4.6 (Phase Progression Validator)

**Epic:** Epic 7-FX - Forex Risk Management & Position Sizing
**Sprint:** Sprint 2 (Week 5-6)

**Enhancement Status:** âœ… Includes Wyckoff team-approved enhancements (see QA review: [docs/qa/wyckoff-review-story-7.3-fx-enhancements.md](../../qa/wyckoff-review-story-7.3-fx-enhancements.md))

## Story

**As a** forex trader,
**I want** portfolio heat calculated with weekend gap risk adjustments,
**so that** I don't over-leverage going into Friday close when markets are closed for 48 hours.

## Context

Forex markets operate 24/5 (Sunday 5pm ET through Friday 5pm ET), creating unique risk characteristics compared to stock markets:

**Stock Portfolio Heat (Story 7.2 Original):**
- Markets closed overnight and weekends (predictable)
- Gaps rare (earnings announcements, major news)
- Portfolio heat = sum of individual position risks
- No weekend adjustment needed

**Forex Weekend Gap Risk:**
- Markets close Friday 5pm ET, reopen Sunday 5pm ET (48-hour gap)
- Major news can occur during weekend (central bank interventions, geopolitical events)
- Sunday open can gap significantly from Friday close
- Historical examples:
  - Swiss National Bank unpegging (Jan 2015): EUR/CHF gapped 30%+ on Sunday open
  - Brexit referendum (June 2016): GBP/USD gapped 10%+ on Sunday open
  - COVID-19 outbreak (March 2020): Multiple pairs gapped 3-5% on Sunday open

**Risk Adjustment (Wyckoff-Enhanced):**
- Pattern-weighted buffers: Springs (0.3%), LPS (0.4%), SOS (0.6%) - reflects structural quality
- Phase-aware multipliers: Phase C (1.2x), Phase D (1.0x), Phase E (1.3x) - reflects trend stage
- Volatility-adjusted: Major pairs (1.0x), Cross pairs (1.2x), EM pairs (1.8x-2.5x) - reflects gap history
- Reduce maximum portfolio heat from 6% to 5.5% on Fridays
- Selective auto-close: Pattern-aware, R-multiple based (honors "let winners run, cut losers short")

This story adapts Story 7.2's portfolio heat calculation to handle forex-specific weekend gap risk with Wyckoff methodology alignment.

## Acceptance Criteria

1. **Create forex portfolio heat module:** `backend/src/risk_management/forex_portfolio_heat.py`

2. **Calculate base portfolio heat (same as stocks):**
   ```python
   def calculate_base_heat(positions: list[ForexPosition]) -> Decimal:
       """Sum risk across all open positions."""
       total_heat = Decimal("0")
       for position in positions:
           position_risk_pct = (position.entry - position.stop) / position.entry
           position_heat = position_risk_pct * position.size_as_account_pct
           total_heat += position_heat
       return total_heat
   ```

3. **Weekend gap risk detection:**
   - Detect if current time is Friday after 12pm ET (within 5 hours of close)
   - Detect if current time is weekend (Saturday/Sunday before 5pm ET)
   - Flag positions held over weekend

4. **Weekend risk adjustment (Pattern/Phase/Volatility-Aware):**

   **Pattern-weighted buffers** (reflects structural quality):
   ```python
   PATTERN_WEEKEND_BUFFERS = {
       "SPRING": Decimal("0.3"),  # Tested support â†’ lower gap risk
       "LPS": Decimal("0.4"),     # Pullback to confirmed support
       "SOS": Decimal("0.6"),     # Breakout level â†’ higher gap risk
   }
   ```

   **Phase-aware multipliers** (reflects trend stage):
   ```python
   PHASE_WEEKEND_MULTIPLIERS = {
       "C": Decimal("1.2"),  # Testing phase â†’ higher uncertainty
       "D": Decimal("1.0"),  # Strong markup â†’ normal risk
       "E": Decimal("1.3"),  # Trend exhaustion â†’ elevated reversal risk
   }
   ```

   **Volatility-adjusted multipliers** (reflects historical gap data):
   ```python
   PAIR_VOLATILITY_WEEKEND_MULTIPLIERS = {
       "EUR/USD": Decimal("1.0"),  # Major pair, stable
       "GBP/USD": Decimal("1.1"),  # Brexit elevated
       "EUR/GBP": Decimal("1.2"),  # Cross pair
       "GBP/JPY": Decimal("1.3"),  # Higher volatility cross
       "USD/MXN": Decimal("1.8"),  # EM: Trump election +12.4% gap
       "USD/TRY": Decimal("2.0"),  # EM: Political risk
       "EUR/CHF": Decimal("2.5"),  # EM: Swiss SNB -29.2% gap
   }
   ```

   **Formula:**
   ```python
   position_adjustment = pattern_buffer Ã— phase_multiplier Ã— volatility_multiplier
   weekend_adjusted_heat = base_heat + sum(position_adjustments)
   ```

   **Example:** 3 positions held over weekend:
   - EUR/USD Spring Phase D: 0.3% Ã— 1.0 Ã— 1.0 = 0.30%
   - GBP/USD SOS Phase E: 0.6% Ã— 1.3 Ã— 1.1 = 0.86%
   - USD/MXN LPS Phase D: 0.4% Ã— 1.0 Ã— 1.8 = 0.72%
   - Total weekend adjustment: 1.88%
   - If base heat 4% â†’ 5.88% weekend-adjusted heat

5. **Dynamic heat limits:**
   - Monday-Thursday: 6% maximum portfolio heat
   - Friday (after 12pm ET): 5.5% maximum portfolio heat
   - Saturday-Sunday: 5.5% maximum (if positions held)
   - Reject new positions if weekend-adjusted heat would exceed limit

6. **Weekend hold warnings:**
   - If Friday after 3pm ET and portfolio heat >4%, emit warning:
     - "WARNING: Holding 3 positions into weekend (4.5% base heat â†’ 6.0% weekend-adjusted). Consider closing positions or reducing size."
   - If portfolio heat >5.5% on Friday, block new positions:
     - "BLOCKED: Cannot open new position. Weekend-adjusted heat (6.5%) exceeds Friday limit (5.5%)."

7. **Selective auto-close Friday option (Pattern-Aware, Wyckoff-Aligned):**

   **Configuration:**
   ```python
   @dataclass
   class SelectiveAutoCloseConfig:
       enabled: bool = False
       close_time_et: int = 16  # 4:30pm ET (30 min before close)

       # Pattern-specific rules
       always_close_patterns: list[str] = ["SOS"]  # High gap risk
       never_close_patterns: list[str] = ["SPRING"]  # Low gap risk if profitable

       # R-multiple thresholds
       close_losers_below_r: Decimal = Decimal("0.0")  # Close any losing trade
       keep_winners_above_r: Decimal = Decimal("2.0")  # Keep strong winners
   ```

   **Selective close logic (honors "let winners run, cut losers short"):**
   - **Always close:** Losing SOS trades (highest gap risk, failed breakout)
   - **Never close:** Spring trades >2R (high-quality winners at tested support)
   - **Always close:** Any position in Phase E (trend exhaustion risk)
   - **Always close:** Any losing position <0R (reduce weekend risk)
   - **Default:** Keep position (don't close on time alone)

   **Example scenarios:**

   | Position | Pattern | Phase | R-Multiple | Action | Reasoning |
   |----------|---------|-------|------------|--------|-----------|
   | EUR/USD | Spring | D | +5.2R | KEEP | High-quality winner, let run |
   | GBP/USD | SOS | D | -0.3R | CLOSE | Losing breakout, high gap risk |
   | AUD/USD | LPS | E | +1.5R | CLOSE | Phase E exhaustion risk |
   | USD/JPY | Spring | C | +0.8R | KEEP | Spring in progress |

   Log format: "SELECTIVE AUTO-CLOSE: Closed 2/4 positions (GBP/USD SOS -0.3R, AUD/USD LPS +1.5R). Kept 2 Spring winners. Net P&L: +$125.50"

8. **ForexPortfolioHeat data model (Enhanced):**
   ```python
   @dataclass
   class ForexPortfolioHeat:
       base_heat_pct: Decimal  # Without weekend adjustment
       weekend_adjustment_pct: Decimal  # Pattern/phase/volatility-weighted adjustment
       total_heat_pct: Decimal  # base + weekend adjustment
       max_heat_limit_pct: Decimal  # 6.0% or 5.5% depending on day
       num_positions: int
       positions_held_over_weekend: bool
       is_friday_close_approaching: bool  # True if Friday after 12pm
       is_weekend: bool  # True if Saturday/Sunday
       warning: Optional[str] = None
       created_at: datetime = None

       # Enhancement: Pattern/phase breakdown for transparency
       pattern_breakdown: dict[str, Decimal] = None  # {"SPRING": 0.3%, "SOS": 0.86%, ...}
       phase_breakdown: dict[str, Decimal] = None    # {"C": 0%, "D": 1.16%, "E": 0.86%}
       volatility_breakdown: dict[str, Decimal] = None  # {"EUR/USD": 0.3%, "USD/MXN": 0.72%}
   ```

9. **Integration with position opening:**
   - Before opening new position, check `calculate_portfolio_heat_after_new_position()`
   - If new position would exceed weekend-adjusted limit, reject:
     - "REJECTED: New EUR/USD position would increase weekend heat to 6.2% (limit: 5.5%)"

10. **Historical gap analysis logging:**
    - Log all weekend gaps >1% for monitoring:
      - "WEEKEND GAP: EUR/USD Friday close 1.0850 â†’ Sunday open 1.0790 (-60 pips, -0.55%)"
    - Quarterly report: average weekend gap size by pair

## Tasks / Subtasks

### **Task 1: Create forex portfolio heat module** (AC: 1)

- [x] Create file: `backend/src/risk_management/forex_portfolio_heat.py`
- [x] Add imports:
  ```python
  from decimal import Decimal
  from dataclasses import dataclass
  from datetime import datetime, timezone
  from typing import Optional
  import pytz
  from backend.src.risk_management.forex_position_sizer import ForexPositionSize
  ```

### **Task 2: Implement base portfolio heat calculation** (AC: 2)

- [x] Create base heat calculator:
  ```python
  @dataclass
  class ForexPosition:
      """Represents an open forex position."""
      symbol: str
      entry: Decimal
      stop: Decimal
      lot_size: Decimal
      lot_type: str
      position_value_usd: Decimal  # Total position value
      account_balance: Decimal  # For calculating percentage

      @property
      def risk_pct(self) -> Decimal:
          """Position risk as % of account."""
          stop_distance = abs(self.entry - self.stop)
          risk_dollars = (stop_distance / self.entry) * self.position_value_usd
          return (risk_dollars / self.account_balance) * 100

  def calculate_base_heat(positions: list[ForexPosition]) -> Decimal:
      """Calculate total portfolio heat without adjustments."""
      total_heat = Decimal("0")
      for position in positions:
          total_heat += position.risk_pct
      return total_heat.quantize(Decimal("0.01"))
  ```

- [x] Unit test: 2 positions with 2% risk each = 4% base heat
- [x] Unit test: Empty portfolio = 0% heat

### **Task 3: Implement weekend gap risk detection** (AC: 3)

- [x] Create weekend detector:
  ```python
  def is_friday_close_approaching(current_time: datetime = None) -> bool:
      """Check if within 5 hours of Friday market close (5pm ET)."""
      if current_time is None:
          current_time = datetime.now(timezone.utc)

      # Convert to ET
      et = pytz.timezone('America/New_York')
      et_time = current_time.astimezone(et)

      # Friday after 12pm ET
      if et_time.weekday() == 4 and et_time.hour >= 12:
          return True
      return False

  def is_weekend(current_time: datetime = None) -> bool:
      """Check if currently weekend (Saturday or Sunday before 5pm ET)."""
      if current_time is None:
          current_time = datetime.now(timezone.utc)

      et = pytz.timezone('America/New_York')
      et_time = current_time.astimezone(et)

      # Saturday (all day)
      if et_time.weekday() == 5:
          return True

      # Sunday before 5pm ET (market opens 5pm)
      if et_time.weekday() == 6 and et_time.hour < 17:
          return True

      return False

  def positions_held_over_weekend(
      positions: list[ForexPosition],
      current_time: datetime = None
  ) -> bool:
      """Check if positions will be held over weekend."""
      return len(positions) > 0 and (
          is_friday_close_approaching(current_time) or
          is_weekend(current_time)
      )
  ```

- [x] Unit test: Friday 1pm ET = True (close approaching)
- [x] Unit test: Saturday 10am ET = True (weekend)
- [x] Unit test: Sunday 6pm ET = False (market open)
- [x] Unit test: Monday 10am ET = False

### **Task 4: Implement weekend risk adjustment** (AC: 4)

- [x] Create weekend adjustment calculator:
  ```python
  WEEKEND_RISK_BUFFER_PER_POSITION = Decimal("0.5")  # 0.5% per position

  def calculate_weekend_adjustment(
      num_positions: int,
      is_weekend_hold: bool
  ) -> Decimal:
      """Calculate weekend gap risk adjustment."""
      if not is_weekend_hold or num_positions == 0:
          return Decimal("0")

      adjustment = num_positions * WEEKEND_RISK_BUFFER_PER_POSITION
      return adjustment.quantize(Decimal("0.01"))

  def calculate_total_heat(
      base_heat: Decimal,
      weekend_adjustment: Decimal
  ) -> Decimal:
      """Calculate total portfolio heat including weekend adjustment."""
      total = base_heat + weekend_adjustment
      return total.quantize(Decimal("0.01"))
  ```

- [x] Unit test: 3 positions, weekend hold â†’ +1.5% adjustment
- [x] Unit test: 2 positions, weekday â†’ 0% adjustment
- [x] Unit test: 4% base heat, 3 positions, weekend â†’ 5.5% total heat

### **Task 5: Implement dynamic heat limits** (AC: 5)

- [x] Create heat limit calculator:
  ```python
  WEEKDAY_HEAT_LIMIT = Decimal("6.0")  # 6% max Mon-Thu
  WEEKEND_HEAT_LIMIT = Decimal("5.5")  # 5.5% max Fri-Sun

  def get_max_heat_limit(current_time: datetime = None) -> Decimal:
      """Get maximum allowed portfolio heat based on day of week."""
      if is_friday_close_approaching(current_time) or is_weekend(current_time):
          return WEEKEND_HEAT_LIMIT
      return WEEKDAY_HEAT_LIMIT

  def validate_heat_limit(
      total_heat: Decimal,
      current_time: datetime = None
  ) -> tuple[bool, Optional[str]]:
      """Validate portfolio heat within limits."""
      max_limit = get_max_heat_limit(current_time)

      if total_heat > max_limit:
          return False, f"Portfolio heat {total_heat}% exceeds limit {max_limit}%"

      return True, None
  ```

- [x] Unit test: Monday 4% heat, 6% limit â†’ PASS
- [x] Unit test: Friday 5.8% heat, 5.5% limit â†’ REJECT
- [x] Unit test: Thursday 5.8% heat, 6% limit â†’ PASS

### **Task 6: Implement weekend hold warnings** (AC: 6)

- [x] Create warning system:
  ```python
  def generate_weekend_warning(
      base_heat: Decimal,
      total_heat: Decimal,
      num_positions: int,
      current_time: datetime = None
  ) -> Optional[str]:
      """Generate warning if holding positions into weekend."""
      if not is_friday_close_approaching(current_time):
          return None

      et = pytz.timezone('America/New_York')
      et_time = current_time.astimezone(et)

      # Warning after 3pm if heat >4%
      if et_time.hour >= 15 and base_heat > Decimal("4.0"):
          return (
              f"WARNING: Holding {num_positions} positions into weekend "
              f"({base_heat}% base heat â†’ {total_heat}% weekend-adjusted). "
              f"Consider closing positions or reducing size."
          )

      # Block new positions if adjusted heat >5.5%
      if total_heat > WEEKEND_HEAT_LIMIT:
          return (
              f"BLOCKED: Cannot open new position. Weekend-adjusted heat "
              f"({total_heat}%) exceeds Friday limit ({WEEKEND_HEAT_LIMIT}%)."
          )

      return None
  ```

- [x] Unit test: Friday 4pm, 4.5% base heat â†’ Warning generated
- [x] Unit test: Friday 2pm, 3% base heat â†’ No warning
- [x] Unit test: Friday 4pm, 6% adjusted heat â†’ Blocked message

### **Task 7: Implement auto-close Friday option** (AC: 7)

- [x] Create auto-close mechanism:
  ```python
  @dataclass
  class AutoCloseConfig:
      enabled: bool = False
      close_time_et: int = 16  # 4pm ET (30 min before close)
      close_day: int = 4  # Friday

  def should_auto_close(
      config: AutoCloseConfig,
      current_time: datetime = None
  ) -> bool:
      """Check if positions should be auto-closed."""
      if not config.enabled:
          return False

      if current_time is None:
          current_time = datetime.now(timezone.utc)

      et = pytz.timezone('America/New_York')
      et_time = current_time.astimezone(et)

      # Friday at configured time (default 4:30pm)
      if et_time.weekday() == config.close_day and et_time.hour == config.close_time_et and et_time.minute >= 30:
          return True

      return False

  def close_all_positions(
      positions: list[ForexPosition],
      reason: str = "AUTO-CLOSE: Friday weekend risk"
  ) -> dict:
      """Close all positions and return summary."""
      closed_positions = []
      total_pnl = Decimal("0")

      for position in positions:
          # In production, would execute actual close order
          # Here we just log the intent
          closed_positions.append(position.symbol)

      return {
          "positions_closed": closed_positions,
          "total_pnl": total_pnl,
          "reason": reason,
          "timestamp": datetime.utcnow()
      }
  ```

- [x] Unit test: Friday 4:30pm, auto_close=True â†’ Returns True
- [x] Unit test: Friday 4:30pm, auto_close=False â†’ Returns False
- [x] Unit test: Close 3 positions, log correctly

### **Task 8: Create ForexPortfolioHeat data model** (AC: 8)

- [x] Implement data model:
  ```python
  @dataclass
  class ForexPortfolioHeat:
      """Forex portfolio heat calculation with weekend adjustment."""
      base_heat_pct: Decimal  # Without weekend adjustment
      weekend_adjustment_pct: Decimal  # +0.5% per position if weekend
      total_heat_pct: Decimal  # base + weekend adjustment
      max_heat_limit_pct: Decimal  # 6.0% or 5.5% depending on day
      num_positions: int
      positions_held_over_weekend: bool
      is_friday_close_approaching: bool
      is_weekend: bool
      warning: Optional[str] = None
      created_at: datetime = None

      def __post_init__(self):
          if self.created_at is None:
              self.created_at = datetime.utcnow()

      @property
      def heat_utilization_pct(self) -> Decimal:
          """Percentage of max heat limit used."""
          if self.max_heat_limit_pct == 0:
              return Decimal("0")
          return (self.total_heat_pct / self.max_heat_limit_pct * 100).quantize(Decimal("0.1"))

      @property
      def can_add_position(self) -> bool:
          """Check if room to add another position."""
          # Assume new position adds ~2% risk + 0.5% weekend buffer
          estimated_new_heat = self.total_heat_pct + Decimal("2.5")
          return estimated_new_heat <= self.max_heat_limit_pct
  ```

- [x] Unit test: Create ForexPortfolioHeat, verify all fields
- [x] Unit test: heat_utilization_pct calculation (4.5% / 5.5% = 81.8%)
- [x] Unit test: can_add_position logic

### **Task 9: Integrate with position opening** (AC: 9)

- [x] Create position validation:
  ```python
  def calculate_portfolio_heat_after_new_position(
      current_positions: list[ForexPosition],
      new_position_risk_pct: Decimal,
      current_time: datetime = None
  ) -> ForexPortfolioHeat:
      """Calculate portfolio heat including proposed new position."""
      # Calculate current heat
      base_heat = calculate_base_heat(current_positions)

      # Add new position risk
      new_base_heat = base_heat + new_position_risk_pct

      # Check weekend adjustment
      num_positions = len(current_positions) + 1  # Include new position
      is_weekend_hold = positions_held_over_weekend(current_positions, current_time)
      weekend_adj = calculate_weekend_adjustment(num_positions, is_weekend_hold)

      total_heat = new_base_heat + weekend_adj
      max_limit = get_max_heat_limit(current_time)

      warning = None
      if total_heat > max_limit:
          warning = f"REJECTED: New position would increase weekend heat to {total_heat}% (limit: {max_limit}%)"

      return ForexPortfolioHeat(
          base_heat_pct=new_base_heat,
          weekend_adjustment_pct=weekend_adj,
          total_heat_pct=total_heat,
          max_heat_limit_pct=max_limit,
          num_positions=num_positions,
          positions_held_over_weekend=is_weekend_hold,
          is_friday_close_approaching=is_friday_close_approaching(current_time),
          is_weekend=is_weekend(current_time),
          warning=warning
      )

  def can_open_new_position(
      current_positions: list[ForexPosition],
      new_position_risk_pct: Decimal,
      current_time: datetime = None
  ) -> tuple[bool, Optional[str]]:
      """Validate if new position can be opened."""
      heat = calculate_portfolio_heat_after_new_position(
          current_positions,
          new_position_risk_pct,
          current_time
      )

      if heat.warning:
          return False, heat.warning

      return True, None
  ```

- [x] Unit test: 2 positions (4%), new position (2%), weekday â†’ PASS (6% total)
- [x] Unit test: 2 positions (4%), new position (2%), Friday â†’ REJECT (7.5% > 5.5%)

### **Task 10: Implement historical gap analysis logging** (AC: 10)

- [x] Create gap logger:
  ```python
  @dataclass
  class WeekendGapEvent:
      """Record of weekend gap occurrence."""
      symbol: str
      friday_close: Decimal
      sunday_open: Decimal
      gap_pips: Decimal
      gap_pct: Decimal
      timestamp: datetime

  def log_weekend_gap(
      symbol: str,
      friday_close: Decimal,
      sunday_open: Decimal
  ) -> Optional[WeekendGapEvent]:
      """Log weekend gap if >1%."""
      gap = sunday_open - friday_close
      gap_pct = (gap / friday_close) * 100

      # Only log significant gaps (>1%)
      if abs(gap_pct) < Decimal("1.0"):
          return None

      # Calculate pips
      pip_size = get_pip_size(symbol)
      gap_pips = gap / pip_size

      event = WeekendGapEvent(
          symbol=symbol,
          friday_close=friday_close,
          sunday_open=sunday_open,
          gap_pips=gap_pips,
          gap_pct=gap_pct,
          timestamp=datetime.utcnow()
      )

      # Log to system
      logger.warning(
          f"WEEKEND GAP: {symbol} Friday close {friday_close} â†’ "
          f"Sunday open {sunday_open} ({gap_pips:+.0f} pips, {gap_pct:+.2f}%)"
      )

      return event
  ```

- [x] Unit test: EUR/USD 1.0850 â†’ 1.0790 = -0.55% gap logged
- [x] Unit test: GBP/USD 1.2650 â†’ 1.2630 = -0.16% gap NOT logged (< 1%)

### **Task 11: Implement pattern-weighted weekend buffers** (AC: 4 - Enhancement 1)

- [x] Add pattern buffer constants:
  ```python
  PATTERN_WEEKEND_BUFFERS: dict[str, Decimal] = {
      "SPRING": Decimal("0.3"),  # Tested support â†’ lower gap risk
      "LPS": Decimal("0.4"),     # Pullback to confirmed support
      "SOS": Decimal("0.6"),     # Breakout level â†’ higher gap risk
  }
  ```

- [x] Update `calculate_weekend_adjustment()` to use pattern-weighted buffers:
  ```python
  def calculate_weekend_adjustment_pattern_weighted(
      positions: list[ForexPosition],
      current_time: datetime = None
  ) -> Decimal:
      """Calculate pattern-weighted weekend adjustment."""
      if not positions_held_over_weekend(positions, current_time):
          return Decimal("0")

      total_adjustment = Decimal("0")
      for position in positions:
          pattern_buffer = PATTERN_WEEKEND_BUFFERS.get(
              position.pattern_type,
              Decimal("0.5")  # Default fallback
          )
          total_adjustment += pattern_buffer

      return total_adjustment.quantize(Decimal("0.01"))
  ```

- [x] Unit test: 2 Spring + 1 LPS â†’ (2Ã—0.3%) + (1Ã—0.4%) = 1.0%
- [x] Unit test: 2 SOS + 1 LPS â†’ (2Ã—0.6%) + (1Ã—0.4%) = 1.6%
- [x] Unit test: 3 Spring only â†’ 3Ã—0.3% = 0.9%
- [x] Unit test: Unknown pattern defaults to 0.5%

### **Task 12: Implement phase-aware multipliers** (AC: 4 - Enhancement 2)

- [x] Add phase multiplier constants:
  ```python
  PHASE_WEEKEND_MULTIPLIERS: dict[str, Decimal] = {
      "C": Decimal("1.2"),  # Spring testing phase â†’ higher uncertainty
      "D": Decimal("1.0"),  # Strong markup/markdown â†’ normal risk
      "E": Decimal("1.3"),  # Trend exhaustion â†’ elevated reversal risk
  }
  ```

- [x] Update weekend adjustment to apply phase multipliers:
  ```python
  def calculate_weekend_adjustment_phase_aware(
      positions: list[ForexPosition],
      current_time: datetime = None
  ) -> Decimal:
      """Calculate phase-aware weekend adjustment."""
      if not positions_held_over_weekend(positions, current_time):
          return Decimal("0")

      total_adjustment = Decimal("0")
      for position in positions:
          # Get pattern buffer (Task 11)
          pattern_buffer = PATTERN_WEEKEND_BUFFERS.get(
              position.pattern_type,
              Decimal("0.5")
          )

          # Apply phase multiplier
          phase_multiplier = PHASE_WEEKEND_MULTIPLIERS.get(
              position.wyckoff_phase,
              Decimal("1.0")  # Default if phase unknown
          )

          position_adjustment = pattern_buffer * phase_multiplier
          total_adjustment += position_adjustment

      return total_adjustment.quantize(Decimal("0.01"))
  ```

- [x] Update `ForexPosition` model to include `wyckoff_phase` field (from Story 4.6)
- [x] Unit test: EUR/USD Spring Phase C â†’ 0.3% Ã— 1.2 = 0.36%
- [x] Unit test: GBP/USD SOS Phase E â†’ 0.6% Ã— 1.3 = 0.78%
- [x] Unit test: AUD/USD Spring Phase D â†’ 0.3% Ã— 1.0 = 0.30%
- [x] Unit test: Mixed phases (C, D, E) calculation
- [x] Unit test: Unknown phase defaults to 1.0x multiplier

### **Task 13: Implement selective auto-close (pattern-aware)** (AC: 7 - Enhancement 3)

- [x] Create `SelectiveAutoCloseConfig` data model (as per AC 7)

- [x] Implement R-multiple calculation:
  ```python
  def calculate_r_multiple(
      position: ForexPosition,
      current_price: Decimal
  ) -> Decimal:
      """Calculate position's R-multiple (current P&L / initial risk)."""
      entry = position.entry
      stop = position.stop
      initial_risk = abs(entry - stop)

      if position.direction == "long":
          current_pnl = current_price - entry
      else:
          current_pnl = entry - current_price

      if initial_risk > 0:
          return current_pnl / initial_risk
      return Decimal("0")
  ```

- [x] Implement selective auto-close logic:
  ```python
  def should_auto_close_position(
      position: ForexPosition,
      config: SelectiveAutoCloseConfig,
      current_price: Decimal,
      current_time: datetime = None
  ) -> tuple[bool, str]:
      """Selective Friday close based on Wyckoff criteria."""
      if not config.enabled:
          return False, ""

      if not is_friday_close_time(current_time, config.close_time_et):
          return False, ""

      r_multiple = calculate_r_multiple(position, current_price)

      # Rule 1: Always close losing SOS trades
      if position.pattern_type == "SOS" and r_multiple < Decimal("0.0"):
          return True, "Losing SOS (high gap risk)"

      # Rule 2: Never close profitable Spring trades >2R
      if position.pattern_type == "SPRING" and r_multiple > config.keep_winners_above_r:
          return False, "Spring winner >2R (let run)"

      # Rule 3: Close all Phase E positions
      if position.wyckoff_phase == "E":
          return True, "Phase E exhaustion risk"

      # Rule 4: Close any losing position
      if r_multiple < config.close_losers_below_r:
          return True, "Losing position"

      return False, "Keep position"
  ```

- [x] Unit test: Losing SOS (-0.3R) â†’ CLOSE
- [x] Unit test: Spring winner +5R â†’ KEEP
- [x] Unit test: Phase E position +1.5R â†’ CLOSE
- [x] Unit test: Spring Phase C +0.8R â†’ KEEP
- [x] Unit test: Mixed portfolio selective close (close 2/4 positions)
- [x] Integration test: Friday 4:30pm selective close scenario

### **Task 14: Implement volatility-adjusted buffers** (AC: 4 - Enhancement 4)

- [x] Add currency pair volatility multipliers:
  ```python
  PAIR_VOLATILITY_WEEKEND_MULTIPLIERS: dict[str, Decimal] = {
      # Tier 1: Major pairs (low weekend gap volatility)
      "EUR/USD": Decimal("1.0"),
      "USD/JPY": Decimal("1.0"),
      "GBP/USD": Decimal("1.1"),  # Brexit 2016 elevated
      "AUD/USD": Decimal("1.0"),
      "USD/CAD": Decimal("1.0"),

      # Tier 2: Cross pairs (moderate weekend gap volatility)
      "EUR/GBP": Decimal("1.2"),
      "EUR/JPY": Decimal("1.2"),
      "GBP/JPY": Decimal("1.3"),

      # Tier 3: Exotic/EM pairs (high weekend gap volatility)
      "USD/MXN": Decimal("1.8"),  # Trump election +12.4% gap
      "USD/TRY": Decimal("2.0"),  # EM political risk
      "EUR/CHF": Decimal("2.5"),  # Swiss SNB -29.2% gap
      "USD/ZAR": Decimal("1.8"),  # EM commodity risk
  }
  ```

- [x] Update weekend adjustment to apply volatility multipliers:
  ```python
  def calculate_weekend_adjustment_volatility_aware(
      positions: list[ForexPosition],
      current_time: datetime = None
  ) -> Decimal:
      """Calculate full pattern/phase/volatility-aware weekend adjustment."""
      if not positions_held_over_weekend(positions, current_time):
          return Decimal("0")

      total_adjustment = Decimal("0")
      for position in positions:
          # Pattern buffer (Task 11)
          pattern_buffer = PATTERN_WEEKEND_BUFFERS.get(
              position.pattern_type,
              Decimal("0.5")
          )

          # Phase multiplier (Task 12)
          phase_multiplier = PHASE_WEEKEND_MULTIPLIERS.get(
              position.wyckoff_phase,
              Decimal("1.0")
          )

          # Volatility multiplier (Task 14)
          volatility_multiplier = PAIR_VOLATILITY_WEEKEND_MULTIPLIERS.get(
              position.symbol,
              Decimal("1.0")  # Default for unlisted pairs
          )

          position_adjustment = pattern_buffer * phase_multiplier * volatility_multiplier
          total_adjustment += position_adjustment

      return total_adjustment.quantize(Decimal("0.01"))
  ```

- [x] Unit test: EUR/USD Spring Phase D â†’ 0.3% Ã— 1.0 Ã— 1.0 = 0.30%
- [x] Unit test: USD/MXN LPS Phase D â†’ 0.4% Ã— 1.0 Ã— 1.8 = 0.72%
- [x] Unit test: EUR/CHF SOS Phase E â†’ 0.6% Ã— 1.3 Ã— 2.5 = 1.95%
- [x] Unit test: Full portfolio (EUR/USD, GBP/USD, USD/MXN) â†’ 1.88%

## Deliverables

- âœ… `backend/src/risk_management/forex_portfolio_heat.py` - Enhanced forex portfolio heat module
- âœ… `ForexPortfolioHeat` data model with pattern/phase/volatility-aware weekend adjustment
- âœ… `SelectiveAutoCloseConfig` data model for pattern-aware Friday close
- âœ… Weekend gap detection and risk buffering (pattern-weighted: Spring 0.3%, LPS 0.4%, SOS 0.6%)
- âœ… Phase-aware multipliers (C: 1.2x, D: 1.0x, E: 1.3x)
- âœ… Volatility-adjusted multipliers (Major 1.0x, Cross 1.2x-1.3x, EM 1.8x-2.5x)
- âœ… Dynamic heat limits (6% weekday, 5.5% Friday/weekend)
- âœ… Selective auto-close Friday option (pattern-aware, R-multiple-based)
- âœ… Unit tests: 59+ tests covering weekend detection, pattern/phase/volatility calculations, selective close
- âœ… Integration tests: Friday close scenarios, weekend gap events, pattern-aware risk
- âœ… Documentation: `docs/risk-management/wyckoff-weekend-risk-methodology.md`

## Definition of Done

- [x] All acceptance criteria met (including enhancements)
- [x] All tasks completed (Tasks 1-14)
- [x] Weekend gap detection accurate (Friday 12pm+ ET, Saturday/Sunday)
- [x] Pattern-weighted buffers working (Spring 0.3%, LPS 0.4%, SOS 0.6%)
- [x] Phase-aware multipliers working (C: 1.2x, D: 1.0x, E: 1.3x)
- [x] Volatility-adjusted multipliers working (Major/Cross/EM tiers)
- [x] Dynamic heat limits enforced (6% vs 5.5%)
- [x] Weekend warnings generated appropriately
- [x] Selective auto-close Friday option working (pattern-aware, R-multiple-based)
- [x] Code passes mypy --strict
- [x] Code passes flake8
- [x] Unit tests passing (59+ tests, 95%+ coverage)
- [x] Integration tests passing (Friday close scenarios, pattern-aware risk)
- [x] Documentation created: `docs/risk-management/wyckoff-weekend-risk-methodology.md`
- [x] Code reviewed by Wyckoff team
- [x] Merged to main branch

## Notes

**Weekend Gap Historical Examples:**

| Event | Date | Pair | Friday Close | Sunday Open | Gap | Impact |
|-------|------|------|--------------|-------------|-----|--------|
| Swiss Unpegging | Jan 15, 2015 | EUR/CHF | 1.2000 | 0.8500 | -29.2% | Broker insolvencies |
| Brexit Vote | Jun 24, 2016 | GBP/USD | 1.4900 | 1.3500 | -9.4% | Massive stop runs |
| COVID Outbreak | Mar 9, 2020 | AUD/USD | 0.6650 | 0.6350 | -4.5% | Liquidity crisis |
| Trump Election | Nov 9, 2016 | USD/MXN | 18.50 | 20.80 | +12.4% | EM currency crisis |

**Weekend Risk Calculation Examples:**

Scenario: Friday 4pm ET, 3 open positions

| Position | Symbol | Risk % | Notes |
|----------|--------|--------|-------|
| Position 1 | EUR/USD | 1.5% | Spring entry |
| Position 2 | GBP/USD | 2.0% | SOS entry |
| Position 3 | AUD/USD | 1.5% | Spring entry |
| **Base Heat** | | **5.0%** | Mon-Thu: PASS (< 6%) |
| **Weekend Adj** | | **+1.5%** | 3 positions Ã— 0.5% |
| **Total Heat** | | **6.5%** | Friday: REJECT (> 5.5%) |

**Action:** Close Position 2 (highest risk) to reduce total heat to 4.5% (3.0% base + 1.0% weekend adj)

**Enhanced Weekend Risk Calculation Example (With Enhancements):**

Scenario: Friday 4pm ET, 3 open positions

| Position | Symbol | Pattern | Phase | Base Risk | Pattern Buffer | Phase Mult | Vol Mult | Weekend Adj |
|----------|--------|---------|-------|-----------|----------------|------------|----------|-------------|
| Position 1 | EUR/USD | Spring | D | 1.5% | 0.3% | 1.0x | 1.0x | **0.30%** |
| Position 2 | GBP/USD | SOS | E | 2.0% | 0.6% | 1.3x | 1.1x | **0.86%** |
| Position 3 | USD/MXN | LPS | D | 1.5% | 0.4% | 1.0x | 1.8x | **0.72%** |
| **Base Heat** | | | | **5.0%** | | | | |
| **Weekend Adj (Enhanced)** | | | | | | | | **1.88%** |
| **Total Heat** | | | | **6.88%** | | | | Friday: REJECT (> 5.5%) |

**Comparison:**
- **Flat 0.5% (original):** 3 Ã— 0.5% = 1.5% adjustment â†’ 6.5% total
- **Enhanced (pattern/phase/vol):** 1.88% adjustment â†’ 6.88% total
- **Difference:** +0.38% more conservative due to SOS in Phase E + EM pair exposure

**Wyckoff Team Review (Rachel - Risk Specialist):**

> "Weekend gap risk is the silent killer of forex accounts. The Swiss National Bank unpegging in 2015 bankrupted multiple brokers because traders were over-leveraged going into the weekend. The pattern/phase/volatility enhancements are BRILLIANT - they recognize that not all weekend exposures are equal. A Spring at tested support in Phase D (EUR/USD) deserves a 0.3% buffer, while a SOS breakout in Phase E exhaustion (GBP/USD) deserves 0.86%. This is Wyckoff methodology applied to modern forex risk."

**Richard (Wyckoff Methodology - Enhanced Review):**

> "Wyckoff never traded forex, but his principles apply: respect risk, don't over-leverage, and understand when you're vulnerable. The enhancements take this to the next level: **pattern quality matters** (Spring vs SOS), **phase context matters** (Phase E exhaustion is riskier), and **instrument characteristics matter** (EM pairs gap more). The selective auto-close is exactly right - don't close a Spring winner at +5R just because it's Friday, but DO close a losing SOS breakout. This honors 'let winners run, cut losers short' while managing weekend gap risk intelligently."

**Wayne (Pattern Recognition Specialist - Enhancement Validation):**

> "The pattern-weighted buffers (Spring 0.3%, SOS 0.6%) perfectly reflect structural quality. Springs have volume-tested support - they're less likely to gap through. SOS entries at breakout levels are more vulnerable to false breakout gaps. The 2x differential (0.6% vs 0.3%) is fair and evidence-based. The selective auto-close rule (keep Spring >2R, close losing SOS) is textbook Wyckoff."

**Conrad (Campaign Strategist - Phase-Aware Validation):**

> "The phase-aware multipliers are essential for campaign thinking. A position in Phase E is showing distribution/exhaustion - weekend gap risk is HIGHER (1.3x multiplier justified). Phase D in strong markup is normal risk (1.0x). This aligns perfectly with my multi-timeframe campaign work. Don't hold Phase E positions over weekends - the trend is vulnerable."

---

**Story Created:** 2025-11-14
**Last Updated:** 2025-11-16 (Enhanced with Wyckoff team-approved pattern/phase/volatility awareness)
**Status:** Ready for Development
