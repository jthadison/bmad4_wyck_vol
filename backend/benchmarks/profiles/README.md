# Performance Profiling Results

This directory contains flame graphs generated by py-spy for analyzing CPU hot paths.

## Contents

- `signal_generation_flamegraph.svg` - CPU profile of signal generation benchmarks
- `backtest_flamegraph.svg` - CPU profile of backtest execution benchmarks

## Generating Profiles

Run the profiling script to generate flame graphs:

```bash
# Profile signal generation
poetry run python benchmarks/profile_hot_paths.py signal

# Profile backtest execution
poetry run python benchmarks/profile_hot_paths.py backtest

# Profile all benchmarks
poetry run python benchmarks/profile_hot_paths.py all
```

## Reading Flame Graphs

Flame graphs visualize where your code spends time:

- **Width**: Time spent in function (wider = more CPU time)
- **Height**: Call stack depth (deeper = more nested calls)
- **Color**: Different colors represent different modules (visual separation only)

### How to Find Bottlenecks

1. **Look for wide boxes at the bottom** - These are hot paths consuming the most CPU
2. **Check parent functions** - Wide boxes higher up indicate functions calling many sub-functions
3. **Interactive SVG** - Click boxes to zoom in, search for function names

### Example Hot Path Analysis

If you see a wide box labeled `numpy.mean`:
- **Width**: Function consumes 15% of total CPU time
- **Location**: Inside `VolumeAnalyzer.calculate_volume_ratio`
- **Action**: Optimize by pre-calculating means or using vectorized operations

## Common Performance Issues

### 1. Iterating Over DataFrame Rows
**Symptom**: Wide box for `pandas.DataFrame.iterrows`
**Fix**: Use vectorized operations with `.loc[]` or `.apply()`

**Before**:
```python
for index, row in df.iterrows():
    result.append(calculate(row['value']))
```

**After**:
```python
result = df['value'].apply(calculate)
```

### 2. Repeated Database Queries
**Symptom**: Wide boxes for `sqlalchemy.execute` inside loops
**Fix**: Batch queries or use bulk operations

**Before**:
```python
for symbol in symbols:
    bars = session.query(OHLCVBar).filter_by(symbol=symbol).all()
```

**After**:
```python
bars = session.query(OHLCVBar).filter(OHLCVBar.symbol.in_(symbols)).all()
```

### 3. Unnecessary Object Creation
**Symptom**: Wide boxes for `__init__` or constructor methods
**Fix**: Cache or reuse objects

**Before**:
```python
for bar in bars:
    detector = SpringDetector()  # Creates new object each iteration
    pattern = detector.detect(bar)
```

**After**:
```python
detector = SpringDetector()  # Create once
for bar in bars:
    pattern = detector.detect(bar)
```

## Optimization Workflow

1. **Profile**: Run `profile_hot_paths.py all`
2. **Analyze**: Open flame graphs and identify hot paths
3. **Optimize**: Fix the widest/hottest functions first
4. **Verify**: Re-run benchmarks to measure improvement
5. **Repeat**: Profile again to find next bottleneck

## Performance Targets (NFR1 and NFR7)

- **NFR1**: Signal generation <1 second per symbol per bar
  - Currently: **0.78ms** (1,282x faster than target) ✅

- **NFR7**: Backtest speed >100 bars/second
  - Target: >100 bars/s
  - Status: Blocked by BacktestEngine bugs ⚠️

## Files Not Committed

Flame graph SVG files are **not committed to git** (`.gitignore`).

They can be large (1-5 MB) and contain system-specific paths.

Regenerate them locally using `profile_hot_paths.py`.

## References

- [py-spy documentation](https://github.com/benfred/py-spy)
- [Flame graphs explained](http://www.brendangregg.com/flamegraphs.html)
- [Story 12.9 - Task 5: Profiling and Bottleneck Identification](../../docs/performance-benchmarking.md)
