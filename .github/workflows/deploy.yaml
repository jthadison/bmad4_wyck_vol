# Deploy to Production
#
# Required secrets:
#   DOCKER_USERNAME    - Docker Hub username for image push
#   DOCKER_PASSWORD    - Docker Hub password/token for image push
#   TEST_DB_PASSWORD   - PostgreSQL test database password (pre-deployment checks)
#   DEPLOY_HOST        - Production server hostname/IP
#   DEPLOY_USER        - SSH username for deployment
#   DEPLOY_SSH_KEY     - SSH private key for deployment
#
# Optional secrets:
#   SLACK_WEBHOOK_URL  - Slack webhook for deployment notifications

name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
  push:
    tags:
      - 'v*'

jobs:
  # Pre-deployment validation checks
  pre-deployment-checks:
    name: Pre-Deployment Validation
    runs-on: ubuntu-latest
    services:
      postgres:
        image: timescale/timescaledb:latest-pg15
        env:
          POSTGRES_USER: wyckoff_user
          POSTGRES_PASSWORD: ${{ secrets.TEST_DB_PASSWORD }}
          POSTGRES_DB: wyckoff_db_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U wyckoff_user"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332  # v4.2.2
        with:
          lfs: true

      - name: Checkout LFS objects
        run: git lfs pull

      - name: Setup Python 3.11
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065  # v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install Poetry
        uses: snok/install-poetry@76e04a911780d5b312d89783f7b1cd627778900a  # v1
        with:
          version: 1.7.1
          virtualenvs-create: true
          virtualenvs-in-project: true

      - name: Cache Poetry dependencies
        uses: actions/cache@0057852bfaa89a56745cba8c7296529d2fc39830  # v4
        with:
          path: ~/.cache/pypoetry
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-

      - name: Install dependencies
        working-directory: backend
        run: poetry install --with dev

      - name: Initialize database extensions
        run: |
          PGPASSWORD=${{ secrets.TEST_DB_PASSWORD }} psql -h localhost -U wyckoff_user -d wyckoff_db_test -c "CREATE EXTENSION IF NOT EXISTS timescaledb;"
          PGPASSWORD=${{ secrets.TEST_DB_PASSWORD }} psql -h localhost -U wyckoff_user -d wyckoff_db_test -c 'CREATE EXTENSION IF NOT EXISTS "uuid-ossp";'

      - name: Setup test database
        working-directory: backend
        env:
          DATABASE_URL: postgresql+psycopg://wyckoff_user:${{ secrets.TEST_DB_PASSWORD }}@localhost:5432/wyckoff_db_test
        run: |
          poetry run alembic upgrade head

      # CRITICAL: Accuracy tests MUST block deployment for trading system
      # Poor detector accuracy directly impacts real trading outcomes - failures are non-negotiable
      - name: Run accuracy tests (final validation)
        id: accuracy
        working-directory: backend
        env:
          DATABASE_URL: postgresql+psycopg://wyckoff_user:${{ secrets.TEST_DB_PASSWORD }}@localhost:5432/wyckoff_db_test
          ENVIRONMENT: test
        run: |
          poetry run pytest tests/integration/test_detector_accuracy_integration.py \
            -v \
            --json-report \
            --json-report-file=accuracy-report.json
          echo "accuracy_status=$?" >> $GITHUB_OUTPUT

      - name: Check accuracy thresholds
        working-directory: backend
        run: |
          # The accuracy test step above already enforces thresholds via pytest assertions
          # (precision >= 75%, recall >= 70% per NFR2/NFR3).
          # This step displays the parsed metrics report for the deployment audit trail.
          if [ -f accuracy-report.json ]; then
            echo "=== Accuracy Metrics Report ==="
            python ../.github/scripts/parse-accuracy-metrics.py accuracy-report.json
            # Verify at least one test actually ran (guards against skipped tests with no dataset)
            TESTS_RAN=$(python -c "import json; r=json.load(open('accuracy-report.json')); print(r.get('summary', {}).get('total', 0))")
            if [ "$TESTS_RAN" = "0" ]; then
              echo "::warning::Accuracy tests ran 0 tests (labeled dataset may be missing - Story 12.2)"
            else
              echo "Accuracy validation passed: $TESTS_RAN test(s) verified thresholds"
            fi
          else
            echo "::warning::No accuracy-report.json found - accuracy validation relies on pytest pass/fail only"
          fi

      # CRITICAL: Regression tests MUST block deployment
      # Degraded trading metrics (win rate, profit factor) indicate broken strategy - non-negotiable
      - name: Run backtest regression tests
        id: regression
        working-directory: backend
        run: |
          # Uses check_backtest_regression.py which:
          # - Loads baselines from tests/datasets/baselines/backtest/
          # - Regenerates synthetic data with same RNG seeds
          # - Compares metrics with 5% tolerance (uniform for all: win_rate, profit_factor, sharpe, drawdown)
          # - Returns 0 if passing or if no baselines exist yet (safe first-run behavior)
          # - Returns 1 if any metric regresses beyond 5%
          poetry run python scripts/check_backtest_regression.py

      - name: Check test coverage
        working-directory: backend
        env:
          DATABASE_URL: postgresql+psycopg://wyckoff_user:${{ secrets.TEST_DB_PASSWORD }}@localhost:5432/wyckoff_db_test
          ENVIRONMENT: test
        run: |
          poetry run pytest tests/ \
            --cov=src \
            --cov-fail-under=90 \
            --cov-report=term

      - name: Install pip-audit
        run: pip install pip-audit

      - name: Security vulnerability scan (pip-audit)
        working-directory: backend
        run: |
          # Real vulnerability scan - same pattern as pr-ci.yaml security-scan job
          # --strict: fail on any known vulnerability
          poetry export -f requirements.txt --without-hashes > requirements.txt
          pip-audit -r requirements.txt --strict

      - name: Deployment gate summary
        if: always()
        run: |
          echo "=== Pre-Deployment Gate Summary ==="
          echo "All preceding steps must pass for deployment to proceed."
          echo ""
          echo "Gates enforced:"
          echo "  - Accuracy tests (pytest assertions enforce precision >= 75%, recall >= 70%)"
          echo "  - Backtest regression (5% tolerance on win_rate, profit_factor, sharpe, drawdown)"
          echo "  - Test coverage (>= 90%)"
          echo "  - Security scan (pip-audit --strict, no known vulnerabilities)"
          echo ""
          echo "If this step is reached, all gates passed."
          echo "=== Deployment APPROVED ==="

  # Build and push Docker images
  build-and-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332  # v4.2.2

      - name: Validate required secrets
        run: |
          missing=""
          if [ -z "$DOCKER_USERNAME" ]; then missing="$missing DOCKER_USERNAME"; fi
          if [ -z "$DOCKER_PASSWORD" ]; then missing="$missing DOCKER_PASSWORD"; fi
          if [ -n "$missing" ]; then
            echo "::error::Missing required secrets:$missing"
            exit 1
          fi
        env:
          DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
          DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f  # v3

      - name: Log in to Docker Hub
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9  # v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract version tag
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            VERSION=${GITHUB_REF#refs/tags/}
          else
            VERSION=latest
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build and push backend Docker image
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25  # v5
        with:
          context: ./backend
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-backend:${{ steps.version.outputs.version }}
            ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend Docker image
        uses: docker/build-push-action@ca052bb54ab0790a636c9b5f226502c73d547a25  # v5
        with:
          context: ./frontend
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-frontend:${{ steps.version.outputs.version }}
            ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Image push summary
        run: |
          echo "Images pushed successfully with tag: ${{ steps.version.outputs.version }}"
          echo "Backend: ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-backend:${{ steps.version.outputs.version }}"
          echo "Frontend: ${{ secrets.DOCKER_USERNAME }}/bmad-wyckoff-frontend:${{ steps.version.outputs.version }}"

  # Create pre-deployment snapshot tag before deploying
  create-pre-deploy-tag:
    name: Create Pre-Deploy Tag
    runs-on: ubuntu-latest
    needs: build-and-push
    if: success()
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332  # v4.2.2

      # Non-critical: Pre-deploy tag creation is informational/operational - doesn't affect deployment success
      - name: Create pre-deploy tag
        run: |
          PRE_DEPLOY_TAG="pre-deploy-$(date +%Y%m%d-%H%M%S)"
          echo "Creating pre-deploy tag: $PRE_DEPLOY_TAG"
          git tag -a "$PRE_DEPLOY_TAG" -m "Pre-deployment snapshot"
          git push origin "$PRE_DEPLOY_TAG"
          echo "Pre-deploy tag created and pushed: $PRE_DEPLOY_TAG"
          echo "To rollback, trigger deployment with tag: $PRE_DEPLOY_TAG"
        continue-on-error: true

  deploy-to-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-push, create-pre-deploy-tag]
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332  # v4.2.2

      - name: Deploy via SSH
        uses: appleboy/ssh-action@25ce8cbbcb08177468c7ff7ec5cbfa236f9341e1  # v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            cd /opt/bmad-wyckoff

            # Pull latest images
            docker compose -f docker-compose.prod.yml pull

            # Run database migrations
            docker compose -f docker-compose.prod.yml run --rm backend \
              poetry run alembic upgrade head

            # Restart services with zero-downtime
            docker compose -f docker-compose.prod.yml up -d --remove-orphans

            # Wait for services to be healthy with retry polling
            echo "Waiting for services to be healthy..."
            for i in $(seq 1 30); do
              if curl -sf http://localhost:8000/health > /dev/null 2>&1; then
                echo "Backend healthy after $((i * 2)) seconds"
                break
              fi
              if [ "$i" -eq 30 ]; then
                echo "ERROR: Backend health check failed after 60 seconds"
                docker compose -f docker-compose.prod.yml logs backend --tail 50
                exit 1
              fi
              sleep 2
            done

            # Verify frontend is also healthy
            curl -f http://localhost/health || {
              echo "ERROR: Frontend health check failed"
              exit 1
            }

            echo "Deployment successful!"

      - name: Verify deployment health
        uses: appleboy/ssh-action@25ce8cbbcb08177468c7ff7ec5cbfa236f9341e1  # v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            # Check all containers are running
            docker compose -f /opt/bmad-wyckoff/docker-compose.prod.yml ps --format json

            # Check detailed health with dependency validation
            HEALTH=$(curl -sf http://localhost:8000/api/v1/health)
            echo "$HEALTH" | python3 -m json.tool
            STATUS=$(echo "$HEALTH" | python3 -c "import json,sys; print(json.load(sys.stdin).get('status','unknown'))")
            if [ "$STATUS" = "degraded" ] || [ "$STATUS" = "unhealthy" ]; then
              echo "ERROR: Backend health check returned status: $STATUS"
              docker compose -f /opt/bmad-wyckoff/docker-compose.prod.yml logs backend --tail 20
              exit 1
            fi
            echo "Backend health verified: $STATUS"

      - name: Deployment notification
        if: always()
        run: |
          STATUS="${{ job.status }}"
          echo "Deployment to ${{ github.event.inputs.environment || 'production' }}: ${STATUS}"
          echo "Version: ${{ github.ref_name }}"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

          # Send Slack notification if webhook is configured
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            curl -X POST -H 'Content-type: application/json' \
              --data "{\"text\":\"Deployment ${STATUS}: ${{ github.ref_name }} to ${{ github.event.inputs.environment || 'production' }}\"}" \
              ${{ secrets.SLACK_WEBHOOK_URL }} || true
          fi
